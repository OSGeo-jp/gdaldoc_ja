<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geographic Network C++ API &mdash; GDAL  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d10597a4" />
      <link rel="stylesheet" type="text/css" href="../_static/css/gdal.css?v=e152ac3b" />

  
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="canonical" href="https://gdal.org/api/gnm_cpp.html"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=c033477b"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/translations.js?v=91613774"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="General information" href="python_bindings.html" />
    <link rel="prev" title="Common Portability Library C++ API" href="cpl_cpp.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../index.html">
            
              <img src="../_static/gdalicon.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../download.html">ダウンロード</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programs/index.html">プログラム</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/raster/index.html">ラスタードライバー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/vector/index.html">ベクタードライバー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">ユーザー</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">チュートリアル</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">開発</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community/index.html">コミュニティ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sponsors/index.html">スポンサー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">どのように貢献できますか?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">ライセンス</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDAL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html"> GDAL  ドキュメント </a> &raquo;</li>
      
          <li><a href="index.html">API</a> &raquo;</li>
      
      <li>Geographic Network C++ API</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/edit/master/doc/source/api/gnm_cpp.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="python_bindings.html" class="btn btn-neutral float-right" title="General information" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cpl_cpp.html" class="btn btn-neutral float-left" title="Common Portability Library C++ API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="geographic-network-c-api">
<span id="gnm-cpp"></span><h1>Geographic Network C++ API<a class="headerlink" href="#geographic-network-c-api" title="Link to this heading"></a></h1>
<section id="include-file">
<h2>Include file<a class="headerlink" href="#include-file" title="Link to this heading"></a></h2>
<p><code class="file docutils literal notranslate"><span class="pre">gnm.h</span></code></p>
</section>
<section id="id1">
<h2>Geographic Network C++ API<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-defines">Defines</p>
<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_NAME">
<span class="target" id="gnm_8h_1aa6340a1a9abfd81707df7430f7cc9295"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_NAME</span></span></span><a class="headerlink" href="#c.GNM_MD_NAME" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_DESCR">
<span class="target" id="gnm_8h_1a277f114b53b6c270bd1428dd0c650afe"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_DESCR</span></span></span><a class="headerlink" href="#c.GNM_MD_DESCR" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_SRS">
<span class="target" id="gnm_8h_1ac3582762f8ba35ae1673d40adec87fdc"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_SRS</span></span></span><a class="headerlink" href="#c.GNM_MD_SRS" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_VERSION">
<span class="target" id="gnm_8h_1a75057902f2927bcb916d901731dcee35"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_VERSION</span></span></span><a class="headerlink" href="#c.GNM_MD_VERSION" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_RULE">
<span class="target" id="gnm_8h_1a4ee2f51460b3d95c6e814ae820c20cda"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_RULE</span></span></span><a class="headerlink" href="#c.GNM_MD_RULE" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_FORMAT">
<span class="target" id="gnm_8h_1a7aa07344f109ac44a27c32ed211b0833"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_FORMAT</span></span></span><a class="headerlink" href="#c.GNM_MD_FORMAT" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_FETCHEDGES">
<span class="target" id="gnm_8h_1a94fef6f340cf7a2b3d5156397e4683dc"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_FETCHEDGES</span></span></span><a class="headerlink" href="#c.GNM_MD_FETCHEDGES" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_FETCHVERTEX">
<span class="target" id="gnm_8h_1a113e8883a4e30b582e3f79ac1468e595"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_FETCHVERTEX</span></span></span><a class="headerlink" href="#c.GNM_MD_FETCHVERTEX" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_NUM_PATHS">
<span class="target" id="gnm_8h_1a93e8177e83f113423b24f50dd0e94e26"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_NUM_PATHS</span></span></span><a class="headerlink" href="#c.GNM_MD_NUM_PATHS" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp macro">
<dt class="sig sig-object cpp" id="c.GNM_MD_EMITTER">
<span class="target" id="gnm_8h_1af57d039cbbe97049efb21407b6196006"></span><span class="sig-name descname"><span class="n"><span class="pre">GNM_MD_EMITTER</span></span></span><a class="headerlink" href="#c.GNM_MD_EMITTER" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv412GNMDirection">
<span id="_CPPv312GNMDirection"></span><span id="_CPPv212GNMDirection"></span><span id="GNMDirection"></span><span class="target" id="gnm_8h_1aebbc6ce88c3ebb460bf652b8b6063aa9"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMDirection</span></span></span><a class="headerlink" href="#_CPPv412GNMDirection" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-enums">Enums</p>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv421GNMGraphAlgorithmType">
<span id="_CPPv321GNMGraphAlgorithmType"></span><span id="_CPPv221GNMGraphAlgorithmType"></span><span class="target" id="gnm_8h_1a91c930f047b81939c30c36371d2ab4df"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMGraphAlgorithmType</span></span></span><a class="headerlink" href="#_CPPv421GNMGraphAlgorithmType" title="Link to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N21GNMGraphAlgorithmType23GATDijkstraShortestPathE">
<span id="_CPPv3N21GNMGraphAlgorithmType23GATDijkstraShortestPathE"></span><span id="_CPPv2N21GNMGraphAlgorithmType23GATDijkstraShortestPathE"></span><span class="target" id="gnm_8h_1a91c930f047b81939c30c36371d2ab4dfa216828c3a1fb956c9c14035208d5f589"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GATDijkstraShortestPath</span></span></span><a class="headerlink" href="#_CPPv4N21GNMGraphAlgorithmType23GATDijkstraShortestPathE" title="Link to this definition"></a><br /></dt>
<dd><p>Dijkstra shortest path. </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N21GNMGraphAlgorithmType16GATKShortestPathE">
<span id="_CPPv3N21GNMGraphAlgorithmType16GATKShortestPathE"></span><span id="_CPPv2N21GNMGraphAlgorithmType16GATKShortestPathE"></span><span class="target" id="gnm_8h_1a91c930f047b81939c30c36371d2ab4dfaa442b9aed3d0663b4dd887453d3af86b"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GATKShortestPath</span></span></span><a class="headerlink" href="#_CPPv4N21GNMGraphAlgorithmType16GATKShortestPathE" title="Link to this definition"></a><br /></dt>
<dd><p>KShortest Paths </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N21GNMGraphAlgorithmType22GATConnectedComponentsE">
<span id="_CPPv3N21GNMGraphAlgorithmType22GATConnectedComponentsE"></span><span id="_CPPv2N21GNMGraphAlgorithmType22GATConnectedComponentsE"></span><span class="target" id="gnm_8h_1a91c930f047b81939c30c36371d2ab4dfab8b851d1f9b001714a11902d022530e6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GATConnectedComponents</span></span></span><a class="headerlink" href="#_CPPv4N21GNMGraphAlgorithmType22GATConnectedComponentsE" title="Link to this definition"></a><br /></dt>
<dd><p>Recursive Breadth-first search. </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv411GNMRuleType">
<span id="_CPPv311GNMRuleType"></span><span id="_CPPv211GNMRuleType"></span><span class="target" id="gnm_8h_1aba9138e79af9ec52544b12107ad80c3f"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMRuleType</span></span></span><a class="headerlink" href="#_CPPv411GNMRuleType" title="Link to this definition"></a><br /></dt>
<dd><p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N11GNMRuleType13GRTConnectionE">
<span id="_CPPv3N11GNMRuleType13GRTConnectionE"></span><span id="_CPPv2N11GNMRuleType13GRTConnectionE"></span><span class="target" id="gnm_8h_1aba9138e79af9ec52544b12107ad80c3fa0b46dbd1f03209dc545ee1295f8805cf"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GRTConnection</span></span></span><a class="headerlink" href="#_CPPv4N11GNMRuleType13GRTConnectionE" title="Link to this definition"></a><br /></dt>
<dd><p>Rule for connect features. </p>
</dd></dl>

</dd></dl>

</div>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv410GNMNetwork">
<span id="_CPPv310GNMNetwork"></span><span id="_CPPv210GNMNetwork"></span><span id="GNMNetwork"></span><span class="target" id="classGNMNetwork"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMNetwork</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><a class="reference internal" href="gdaldataset_cpp.html#_CPPv411GDALDataset" title="GDALDataset"><span class="n"><span class="pre">GDALDataset</span></span></a><a class="headerlink" href="#_CPPv410GNMNetwork" title="Link to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;gnm.h&gt;</em></div>
<p>General GNM class which represents a geography network of common format. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classGNMGenericNetwork"><span class="std std-ref">GNMGenericNetwork</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork10GNMNetworkEv">
<span id="_CPPv3N10GNMNetwork10GNMNetworkEv"></span><span id="_CPPv2N10GNMNetwork10GNMNetworkEv"></span><span id="GNMNetwork::GNMNetwork"></span><span class="target" id="classGNMNetwork_1a5e14e63cc4dddaefbe5fa010e6b122da"></span><span class="sig-name descname"><span class="n"><span class="pre">GNMNetwork</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10GNMNetwork10GNMNetworkEv" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetworkD0Ev">
<span id="_CPPv3N10GNMNetworkD0Ev"></span><span id="_CPPv2N10GNMNetworkD0Ev"></span><span id="GNMNetwork::~GNMNetwork"></span><span class="target" id="classGNMNetwork_1a7396bdaba1dc883fbf13980c2a046cfa"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">~GNMNetwork</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10GNMNetworkD0Ev" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10GNMNetwork13GetSpatialRefEv">
<span id="_CPPv3NK10GNMNetwork13GetSpatialRefEv"></span><span id="_CPPv2NK10GNMNetwork13GetSpatialRefEv"></span><span id="GNMNetwork::GetSpatialRefC"></span><span class="target" id="classGNMNetwork_1a6fb1073d8731f74b1c11d3e3b627a5ad"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="ogrspatialref.html#_CPPv419OGRSpatialReference" title="OGRSpatialReference"><span class="n"><span class="pre">OGRSpatialReference</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetSpatialRef</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4NK10GNMNetwork13GetSpatialRefEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the spatial reference for this dataset. </p>
<p>Same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1a1647a3fc0871363ce8e35ddf4a48b341"><span class="std std-ref">GDALGetSpatialRef()</span></a>.</p>
<p>When a projection definition is not available, null is returned. If used on a dataset where there are GCPs and not a geotransform, this method returns null. Use <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1a6a2560997e2a8adf7aa111d0f69eec83"><span class="std std-ref">GetGCPSpatialRef()</span></a> instead.</p>
<p><div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference external" href="https://gdal.org/tutorials/osr_api_tut.html">https://gdal.org/tutorials/osr_api_tut.html</a></p>
</div>
<dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 3.0</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>a pointer to an internal object. It should not be altered or freed. Its lifetime will be the one of the dataset object, or until the next call to this method.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork11GetFileListEv">
<span id="_CPPv3N10GNMNetwork11GetFileListEv"></span><span id="_CPPv2N10GNMNetwork11GetFileListEv"></span><span id="GNMNetwork::GetFileList__void"></span><span class="target" id="classGNMNetwork_1a08b3c8eb37b59875b6a80cf85ee461df"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetFileList</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork11GetFileListEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch files forming dataset. </p>
<p>Returns a list of files believed to be part of this dataset. If it returns an empty list of files it means there is believed to be no local file system files associated with the dataset (for instance a virtual dataset). The returned file list is owned by the caller and should be deallocated with <a class="reference internal" href="cpl.html#cpl__string_8h_1a5a39b9c5896a273cc6f06c1d5be93238"><span class="std std-ref">CSLDestroy()</span></a>.</p>
<p>The returned filenames will normally be relative or absolute paths depending on the path used to originally open the dataset. The strings will be UTF-8 encoded.</p>
<p>This method is the same as the C <a class="reference internal" href="raster_c_api.html#gdal_8h_1a3e833f20787e138cbeee23ff78ccf76d"><span class="std std-ref">GDALGetFileList()</span></a> function.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>NULL or a NULL terminated array of file names. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork6CreateEPKcPPc">
<span id="_CPPv3N10GNMNetwork6CreateEPKcPPc"></span><span id="_CPPv2N10GNMNetwork6CreateEPKcPPc"></span><span id="GNMNetwork::Create__cCP.cPP"></span><span class="target" id="classGNMNetwork_1ac69a73a3c53b8823fb7ff8886d152e13"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszFilename</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork6CreateEPKcPPc" title="Link to this definition"></a><br /></dt>
<dd><p>Create network system layers. </p>
<p>Creates the connectivity (the &quot;network path&quot; of data) over the dataset and returns the resulting network. NOTE: This method does not create any connections among features but creates the necessary set of fields, layers, etc. NOTE: After the successful creation the passed dataset must not be modified outside (but can be read as usual). NOTE: For the common network format the creation is forbidden if the passed dataset already has network system layers and OVERWRITE creation option is FALSE.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pszFilename</strong> -- - A path there the network folder (schema, etc.) will be created. The folder (schema, etc.) name get options. </p></li>
<li><p><strong>papszOptions</strong> -- - create network options. The create options specific for gnm driver. </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork4OpenEP12GDALOpenInfo">
<span id="_CPPv3N10GNMNetwork4OpenEP12GDALOpenInfo"></span><span id="_CPPv2N10GNMNetwork4OpenEP12GDALOpenInfo"></span><span id="GNMNetwork::Open__GDALOpenInfoP"></span><span class="target" id="classGNMNetwork_1ac1c2f5a4a6b28c9d54a53a930955fd12"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Open</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GDALOpenInfo</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poOpenInfo</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork4OpenEP12GDALOpenInfo" title="Link to this definition"></a><br /></dt>
<dd><p>Open a network. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poOpenInfo</strong> -- GDALOpenInfo pointer </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork6DeleteEv">
<span id="_CPPv3N10GNMNetwork6DeleteEv"></span><span id="_CPPv2N10GNMNetwork6DeleteEv"></span><span id="GNMNetwork::Delete"></span><span class="target" id="classGNMNetwork_1a24e800e8f49bce65bf4305c0b68d2cd5"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Delete</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork6DeleteEv" title="Link to this definition"></a><br /></dt>
<dd><p>Delete network. </p>
<p>Delete all dependent layers </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10GNMNetwork7GetNameEv">
<span id="_CPPv3NK10GNMNetwork7GetNameEv"></span><span id="_CPPv2NK10GNMNetwork7GetNameEv"></span><span id="GNMNetwork::GetNameC"></span><span class="target" id="classGNMNetwork_1a14a47a0aafe4e7347482aa64fe054499"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10GNMNetwork7GetNameEv" title="Link to this definition"></a><br /></dt>
<dd><p>GetName - a network name. </p>
<p>The value provided to create function in GNM_MD_NAME key. While creation this value used to create the folder or db schema name. But can be changed after creation. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>Network name string </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10GNMNetwork10GetVersionEv">
<span id="_CPPv3NK10GNMNetwork10GetVersionEv"></span><span id="_CPPv2NK10GNMNetwork10GetVersionEv"></span><span id="GNMNetwork::GetVersionC"></span><span class="target" id="classGNMNetwork_1a9287b5bf8bf81477841d12f739e2fbd7"></span><span class="k"><span class="pre">inline</span></span><span class="w"> </span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetVersion</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10GNMNetwork10GetVersionEv" title="Link to this definition"></a><br /></dt>
<dd><p>GetVersion return the network version if applicable. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>version value </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork13DisconnectAllEv">
<span id="_CPPv3N10GNMNetwork13DisconnectAllEv"></span><span id="_CPPv2N10GNMNetwork13DisconnectAllEv"></span><span id="GNMNetwork::DisconnectAll"></span><span class="target" id="classGNMNetwork_1a30526ad61c2dcdb0cef0d7da3dc4beab"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DisconnectAll</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork13DisconnectAllEv" title="Link to this definition"></a><br /></dt>
<dd><p>DisconnectAll method clears the network graph. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork21GetFeatureByGlobalFIDE7GNMGFID">
<span id="_CPPv3N10GNMNetwork21GetFeatureByGlobalFIDE7GNMGFID"></span><span id="_CPPv2N10GNMNetwork21GetFeatureByGlobalFIDE7GNMGFID"></span><span id="GNMNetwork::GetFeatureByGlobalFID__GNMGFID"></span><span class="target" id="classGNMNetwork_1a312920f0f60ef3057b2db3fb35acfd42"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetFeatureByGlobalFID</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nGFID</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork21GetFeatureByGlobalFIDE7GNMGFID" title="Link to this definition"></a><br /></dt>
<dd><p>GetFeatureByGlobalFID search all network layers for given feature identificator. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nGFID</strong> -- feature identificator. </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> pointer or NULL. The pointer should be freed via <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2602d11f21567119da0ca6b6c5ad45"><span class="std std-ref">OGRFeature::DestroyFeature()</span></a>. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc">
<span id="_CPPv3N10GNMNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc"></span><span id="_CPPv2N10GNMNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc"></span><span id="GNMNetwork::GetPath__GNMGFID.GNMGFID.GNMGraphAlgorithmType.cPP"></span><span class="target" id="classGNMNetwork_1a228df4b00948b08a7c6066734b77e87e"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetPath</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nStartFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nEndFID</span></span>, <a class="reference internal" href="#_CPPv421GNMGraphAlgorithmType" title="GNMGraphAlgorithmType"><span class="n"><span class="pre">GNMGraphAlgorithmType</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eAlgorithm</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc" title="Link to this definition"></a><br /></dt>
<dd><p>Create path between start and end GFIDs. </p>
<p><div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1ab2c2b105b8f76a279e6a53b9b4a182e0"><span class="std std-ref">ReleaseResultSet()</span></a>. </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nStartFID</strong> -- - start identificator </p></li>
<li><p><strong>nEndFID</strong> -- - end identificator </p></li>
<li><p><strong>eAlgorithm</strong> -- - The algorithm to get path </p></li>
<li><p><strong>papszOptions</strong> -- - algorithm specific options </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>In memory <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> pointer with features constituting the shortest path (or paths). The caller have to free the pointer via </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-protected-functions">Protected Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10GNMNetwork17CheckNetworkExistEPKcPPc">
<span id="_CPPv3N10GNMNetwork17CheckNetworkExistEPKcPPc"></span><span id="_CPPv2N10GNMNetwork17CheckNetworkExistEPKcPPc"></span><span id="GNMNetwork::CheckNetworkExist__cCP.cPP"></span><span class="target" id="classGNMNetwork_1afd7c7febe8edf17cda04fbad5f09a692"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CheckNetworkExist</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszFilename</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N10GNMNetwork17CheckNetworkExistEPKcPPc" title="Link to this definition"></a><br /></dt>
<dd><p>Check if network already exist. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pszFilename</strong> -- - path to network (folder or database </p></li>
<li><p><strong>papszOptions</strong> -- - create options </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>TRUE if exist and not overwrite or FALSE </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv417GNMGenericNetwork">
<span id="_CPPv317GNMGenericNetwork"></span><span id="_CPPv217GNMGenericNetwork"></span><span id="GNMGenericNetwork"></span><span class="target" id="classGNMGenericNetwork"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMGenericNetwork</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv410GNMNetwork" title="GNMNetwork"><span class="n"><span class="pre">GNMNetwork</span></span></a><a class="headerlink" href="#_CPPv417GNMGenericNetwork" title="Link to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;gnm.h&gt;</em></div>
<p>GNM class which represents a geography network of generic format. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork17GNMGenericNetworkEv">
<span id="_CPPv3N17GNMGenericNetwork17GNMGenericNetworkEv"></span><span id="_CPPv2N17GNMGenericNetwork17GNMGenericNetworkEv"></span><span id="GNMGenericNetwork::GNMGenericNetwork"></span><span class="target" id="classGNMGenericNetwork_1a2a05b91f15e76ea330707474da5b8c58"></span><span class="sig-name descname"><span class="n"><span class="pre">GNMGenericNetwork</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork17GNMGenericNetworkEv" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetworkD0Ev">
<span id="_CPPv3N17GNMGenericNetworkD0Ev"></span><span id="_CPPv2N17GNMGenericNetworkD0Ev"></span><span id="GNMGenericNetwork::~GNMGenericNetwork"></span><span class="target" id="classGNMGenericNetwork_1a3f40667920aaea11bb20e4a26ea6a57e"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">~GNMGenericNetwork</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetworkD0Ev" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork13GetLayerCountEv">
<span id="_CPPv3N17GNMGenericNetwork13GetLayerCountEv"></span><span id="_CPPv2N17GNMGenericNetwork13GetLayerCountEv"></span><span id="GNMGenericNetwork::GetLayerCount"></span><span class="target" id="classGNMGenericNetwork_1a60be29b9b6a343bc33fbb160ea4faedd"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetLayerCount</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork13GetLayerCountEv" title="Link to this definition"></a><br /></dt>
<dd><p>Get the number of layers in this dataset. </p>
<p>This method is the same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1a8c9297e5115d559b27267b14122043ee"><span class="std std-ref">GDALDatasetGetLayerCount()</span></a>, and the deprecated <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ac6da541cb655ab631df729e71da2e762"><span class="std std-ref">OGR_DS_GetLayerCount()</span></a>.</p>
<p>In GDAL 1.X, this method used to be in the OGRDataSource class.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>layer count. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork8GetLayerEi">
<span id="_CPPv3N17GNMGenericNetwork8GetLayerEi"></span><span id="_CPPv2N17GNMGenericNetwork8GetLayerEi"></span><span id="GNMGenericNetwork::GetLayer__i"></span><span class="target" id="classGNMGenericNetwork_1a5c7fad64871d7d57f579e3865ffd5dc1"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetLayer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork8GetLayerEi" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch a layer by index. </p>
<p>The returned layer remains owned by the <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a> and should not be deleted by the application.</p>
<p>See <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1a8cfa4d17c68e441614118931b17cd7fa"><span class="std std-ref">GetLayers()</span></a> for a C++ iterator version of this method.</p>
<p>This method is the same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1a4c42c52e24e02fead69a3189db5585ab"><span class="std std-ref">GDALDatasetGetLayer()</span></a> and the deprecated <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a03998029f904d1c3b12de40114e7503e"><span class="std std-ref">OGR_DS_GetLayer()</span></a>.</p>
<p>In GDAL 1.X, this method used to be in the OGRDataSource class.</p>
<p><div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1a8cfa4d17c68e441614118931b17cd7fa"><span class="std std-ref">GetLayers()</span></a></p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iLayer</strong> -- a layer number between 0 and <a class="reference internal" href="#classGNMGenericNetwork_1a60be29b9b6a343bc33fbb160ea4faedd"><span class="std std-ref">GetLayerCount()</span></a>-1.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>the layer, or NULL if iLayer is out of range or an error occurs.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork11DeleteLayerEi">
<span id="_CPPv3N17GNMGenericNetwork11DeleteLayerEi"></span><span id="_CPPv2N17GNMGenericNetwork11DeleteLayerEi"></span><span id="GNMGenericNetwork::DeleteLayer__i"></span><span class="target" id="classGNMGenericNetwork_1afa12729a5fe66041f5ba0b35bf1f8da0"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DeleteLayer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork11DeleteLayerEi" title="Link to this definition"></a><br /></dt>
<dd><p>Delete the indicated layer from the datasource. </p>
<p>If this method is supported the ODsCDeleteLayer capability will test TRUE on the <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a>.</p>
<p>This method is the same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1a6c71ac6976dbf150a5131f509669e56e"><span class="std std-ref">GDALDatasetDeleteLayer()</span></a> and the deprecated <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a85827a79cd2ddb5a55126e785bee427d"><span class="std std-ref">OGR_DS_DeleteLayer()</span></a>.</p>
<p>In GDAL 1.X, this method used to be in the OGRDataSource class.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iLayer</strong> -- the index of the layer to delete.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success, or OGRERR_UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork14TestCapabilityEPKc">
<span id="_CPPv3N17GNMGenericNetwork14TestCapabilityEPKc"></span><span id="_CPPv2N17GNMGenericNetwork14TestCapabilityEPKc"></span><span id="GNMGenericNetwork::TestCapability__cCP"></span><span class="target" id="classGNMGenericNetwork_1a49c07deb5b9b5d243cc71a8b74dfb376"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TestCapability</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork14TestCapabilityEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Test if capability is available. </p>
<p>One of the following dataset capability names can be passed into this method, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<p><ul>
<li><p><strong>ODsCCreateLayer</strong>: True if this datasource can create new layers.</p>
<p></p>
</li>
<li><p><strong>ODsCDeleteLayer</strong>: True if this datasource can delete existing layers.</p>
<p></p>
</li>
<li><p><strong>ODsCCreateGeomFieldAfterCreateLayer</strong>: True if the layers of this datasource support CreateGeomField() just after layer creation.</p>
<p></p>
</li>
<li><p><strong>ODsCCurveGeometries</strong>: True if this datasource supports curve geometries.</p>
<p></p>
</li>
<li><p><strong>ODsCTransactions</strong>: True if this datasource supports (efficient) transactions.</p>
<p></p>
</li>
<li><p><strong>ODsCEmulatedTransactions</strong>: True if this datasource supports transactions through emulation.</p>
<p></p>
</li>
<li><p><strong>ODsCRandomLayerRead</strong>: True if this datasource has a dedicated <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1ac71c86b48ecb54fc2c1a844ee1ca33e7"><span class="std std-ref">GetNextFeature()</span></a> implementation, potentially returning features from layers in a non sequential way.</p>
<p></p>
</li>
<li><p><strong>ODsCRandomLayerWrite</strong>: True if this datasource supports calling CreateFeature() on layers in a non sequential way.</p>
<p></p>
</li>
</ul>
</p>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<p>This method is the same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1a8dc635a536f123e1b03004dc74b4da86"><span class="std std-ref">GDALDatasetTestCapability()</span></a> and the deprecated <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ad0fefab726442fa71ab5ef74fe8549a6"><span class="std std-ref">OGR_DS_TestCapability()</span></a>.</p>
<p>In GDAL 1.X, this method used to be in the OGRDataSource class.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszCap</strong> -- the capability to test.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>TRUE if capability available otherwise FALSE. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork9CopyLayerEP8OGRLayerPKcPPc">
<span id="_CPPv3N17GNMGenericNetwork9CopyLayerEP8OGRLayerPKcPPc"></span><span id="_CPPv2N17GNMGenericNetwork9CopyLayerEP8OGRLayerPKcPPc"></span><span id="GNMGenericNetwork::CopyLayer__OGRLayerP.cCP.cPP"></span><span class="target" id="classGNMGenericNetwork_1a778b7bf19164768f3f198653c15f6d6c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">CopyLayer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poSrcLayer</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszNewName</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork9CopyLayerEP8OGRLayerPKcPPc" title="Link to this definition"></a><br /></dt>
<dd><p>Duplicate an existing layer. </p>
<p>This method creates a new layer, duplicate the field definitions of the source layer and then duplicate each features of the source layer. The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation. The source layer may come from another dataset.</p>
<p>This method is the same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1ad6bbc8895f27768a4ad644231b22cb24"><span class="std std-ref">GDALDatasetCopyLayer()</span></a> and the deprecated <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a628d34530517b618696c97b73de31df7"><span class="std std-ref">OGR_DS_CopyLayer()</span></a>.</p>
<p>In GDAL 1.X, this method used to be in the OGRDataSource class.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poSrcLayer</strong> -- source layer. </p></li>
<li><p><strong>pszNewName</strong> -- the name of the layer to create. </p></li>
<li><p><strong>papszOptions</strong> -- a StringList of name=value options. Options are driver specific. There is a common option to set output layer spatial reference: DST_SRSWKT. The option should be in WKT format. Starting with GDAL 3.7, the common option COPY_MD can be set to NO to prevent the default copying of the metadata from the source layer to the target layer.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>a handle to the layer, or NULL if an error occurs. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork22CloseDependentDatasetsEv">
<span id="_CPPv3N17GNMGenericNetwork22CloseDependentDatasetsEv"></span><span id="_CPPv2N17GNMGenericNetwork22CloseDependentDatasetsEv"></span><span id="GNMGenericNetwork::CloseDependentDatasets"></span><span class="target" id="classGNMGenericNetwork_1aa40238f5963be9bf3d0f21e927a4ddc8"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CloseDependentDatasets</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork22CloseDependentDatasetsEv" title="Link to this definition"></a><br /></dt>
<dd><p>Drop references to any other datasets referenced by this dataset. </p>
<p>This method should release any reference to other datasets (e.g. a VRT dataset to its sources), but not close the current dataset itself.</p>
<p>If at least, one reference to a dependent dataset has been dropped, this method should return TRUE. Otherwise it <em>should</em> return FALSE. (Failure to return the proper value might result in infinite loop)</p>
<p>This method can be called several times on a given dataset. After the first time, it should not do anything and return FALSE.</p>
<p>The driver implementation may choose to destroy its raster bands, so be careful not to call any method on the raster bands afterwards.</p>
<p>Basically the only safe action you can do after calling <a class="reference internal" href="#classGNMGenericNetwork_1aa40238f5963be9bf3d0f21e927a4ddc8"><span class="std std-ref">CloseDependentDatasets()</span></a> is to call the destructor.</p>
<p>Note: the only legitimate caller of <a class="reference internal" href="#classGNMGenericNetwork_1aa40238f5963be9bf3d0f21e927a4ddc8"><span class="std std-ref">CloseDependentDatasets()</span></a> is GDALDriverManager::~GDALDriverManager()</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>TRUE if at least one reference to another dataset has been dropped. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork10FlushCacheEb">
<span id="_CPPv3N17GNMGenericNetwork10FlushCacheEb"></span><span id="_CPPv2N17GNMGenericNetwork10FlushCacheEb"></span><span id="GNMGenericNetwork::FlushCache__b"></span><span class="target" id="classGNMGenericNetwork_1a4fa73ad000de09cf172d3872a6aa706a"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FlushCache</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bAtClosing</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork10FlushCacheEb" title="Link to this definition"></a><br /></dt>
<dd><p>Flush all write cached data to disk. </p>
<p>Any raster (or other GDAL) data written via GDAL calls, but buffered internally will be written to disk.</p>
<p>The default implementation of this method just calls the <a class="reference internal" href="#classGNMGenericNetwork_1a4fa73ad000de09cf172d3872a6aa706a"><span class="std std-ref">FlushCache()</span></a> method on each of the raster bands and the SyncToDisk() method on each of the layers. Conceptionally, calling <a class="reference internal" href="#classGNMGenericNetwork_1a4fa73ad000de09cf172d3872a6aa706a"><span class="std std-ref">FlushCache()</span></a> on a dataset should include any work that might be accomplished by calling SyncToDisk() on layers in that dataset.</p>
<p>Using this method does not prevent use from calling GDALClose() to properly close a dataset and ensure that important data not addressed by <a class="reference internal" href="#classGNMGenericNetwork_1a4fa73ad000de09cf172d3872a6aa706a"><span class="std std-ref">FlushCache()</span></a> is written in the file.</p>
<p>This method is the same as the C function <a class="reference internal" href="raster_c_api.html#gdal_8h_1ad950554d036296b31cd67a6c84dbb747"><span class="std std-ref">GDALFlushCache()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bAtClosing</strong> -- Whether this is called from a <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset"><span class="std std-ref">GDALDataset</span></a> destructor </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None in case of success (note: return value added in GDAL 3.7) </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork6CreateEPKcPPc">
<span id="_CPPv3N17GNMGenericNetwork6CreateEPKcPPc"></span><span id="_CPPv2N17GNMGenericNetwork6CreateEPKcPPc"></span><span id="GNMGenericNetwork::Create__cCP.cPP"></span><span class="target" id="classGNMGenericNetwork_1aa77a88021c05f12c4dbfa14ea4301ec8"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Create</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszFilename</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork6CreateEPKcPPc" title="Link to this definition"></a><br /></dt>
<dd><p>Create network system layers. </p>
<p>Creates the connectivity (the &quot;network path&quot; of data) over the dataset and returns the resulting network. NOTE: This method does not create any connections among features but creates the necessary set of fields, layers, etc. NOTE: After the successful creation the passed dataset must not be modified outside (but can be read as usual). NOTE: For the common network format the creation is forbidden if the passed dataset already has network system layers and OVERWRITE creation option is FALSE.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pszFilename</strong> -- - A path there the network folder (schema, etc.) will be created. The folder (schema, etc.) name get options. </p></li>
<li><p><strong>papszOptions</strong> -- - create network options. The create options specific for gnm driver. </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork6DeleteEv">
<span id="_CPPv3N17GNMGenericNetwork6DeleteEv"></span><span id="_CPPv2N17GNMGenericNetwork6DeleteEv"></span><span id="GNMGenericNetwork::Delete"></span><span class="target" id="classGNMGenericNetwork_1af32011126446dfaeb1a60470ce24e218"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Delete</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork6DeleteEv" title="Link to this definition"></a><br /></dt>
<dd><p>Delete network. </p>
<p>Delete all dependent layers </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK17GNMGenericNetwork10GetVersionEv">
<span id="_CPPv3NK17GNMGenericNetwork10GetVersionEv"></span><span id="_CPPv2NK17GNMGenericNetwork10GetVersionEv"></span><span id="GNMGenericNetwork::GetVersionC"></span><span class="target" id="classGNMGenericNetwork_1a934dd6683afc8f74d1d8007fdaed365b"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetVersion</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4NK17GNMGenericNetwork10GetVersionEv" title="Link to this definition"></a><br /></dt>
<dd><p>GetVersion return the network version if applicable. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>version value </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork15GetNewGlobalFIDEv">
<span id="_CPPv3N17GNMGenericNetwork15GetNewGlobalFIDEv"></span><span id="_CPPv2N17GNMGenericNetwork15GetNewGlobalFIDEv"></span><span id="GNMGenericNetwork::GetNewGlobalFID"></span><span class="target" id="classGNMGenericNetwork_1ad25b9f921f0c147774004a870d1cdd18"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetNewGlobalFID</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork15GetNewGlobalFIDEv" title="Link to this definition"></a><br /></dt>
<dd><p>GetNewGlobalFID increase the global ID counter. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>New global feature ID. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork16GetAlgorithmNameE12GNMDirectionb">
<span id="_CPPv3N17GNMGenericNetwork16GetAlgorithmNameE12GNMDirectionb"></span><span id="_CPPv2N17GNMGenericNetwork16GetAlgorithmNameE12GNMDirectionb"></span><span id="GNMGenericNetwork::GetAlgorithmName__GNMDirection.b"></span><span class="target" id="classGNMGenericNetwork_1a61498808bf3d9c80707bbf3a2e11da49"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetAlgorithmName</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412GNMDirection" title="GNMDirection"><span class="n"><span class="pre">GNMDirection</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eAlgorithm</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bShortName</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork16GetAlgorithmNameE12GNMDirectionb" title="Link to this definition"></a><br /></dt>
<dd><p>Get the algorithm name. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eAlgorithm</strong> -- GNM algorithm type </p></li>
<li><p><strong>bShortName</strong> -- Indicator which name to return - short or long </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>String with algorithm name </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork19AddFeatureGlobalFIDE7GNMGFIDPKc">
<span id="_CPPv3N17GNMGenericNetwork19AddFeatureGlobalFIDE7GNMGFIDPKc"></span><span id="_CPPv2N17GNMGenericNetwork19AddFeatureGlobalFIDE7GNMGFIDPKc"></span><span id="GNMGenericNetwork::AddFeatureGlobalFID__GNMGFID.cCP"></span><span class="target" id="classGNMGenericNetwork_1a1557ed0456d1c027d4560b0d765df218"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">AddFeatureGlobalFID</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nFID</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszLayerName</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork19AddFeatureGlobalFIDE7GNMGFIDPKc" title="Link to this definition"></a><br /></dt>
<dd><p>AddFeatureGlobalFID add the FID &lt;-&gt; Layer name link to fast access features by global FID. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nFID</strong> -- - global FID </p></li>
<li><p><strong>pszLayerName</strong> -- - layer name </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork15ConnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection">
<span id="_CPPv3N17GNMGenericNetwork15ConnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection"></span><span id="_CPPv2N17GNMGenericNetwork15ConnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection"></span><span id="GNMGenericNetwork::ConnectFeatures__GNMGFID.GNMGFID.GNMGFID.double.double.GNMDirection"></span><span class="target" id="classGNMGenericNetwork_1a75053c44125b84185f6390b7cb994f9e"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ConnectFeatures</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSrcFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nTgtFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nConFID</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="o"><span class="pre">-</span></span><span class="m"><span class="pre">1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfCost</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfInvCost</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span>, <a class="reference internal" href="#_CPPv412GNMDirection" title="GNMDirection"><span class="n"><span class="pre">GNMDirection</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eDir</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">GNM_EDGE_DIR_BOTH</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork15ConnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection" title="Link to this definition"></a><br /></dt>
<dd><p>Connects two features via third feature (may be virtual, so the identificator should be -1). </p>
<p>The features may be at the same layer or different layers. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nSrcFID</strong> -- - source feature identificator </p></li>
<li><p><strong>nTgtFID</strong> -- - target feature identificator </p></li>
<li><p><strong>nConFID</strong> -- - connection feature identificator (-1 for virtual connection) </p></li>
<li><p><strong>dfCost</strong> -- - cost moving from source to target (default 1) </p></li>
<li><p><strong>dfInvCost</strong> -- - cost moving from target to source (default 1) </p></li>
<li><p><strong>eDir</strong> -- - direction, may be source to target, target to source or both. (default - both) </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork18DisconnectFeaturesE7GNMGFID7GNMGFID7GNMGFID">
<span id="_CPPv3N17GNMGenericNetwork18DisconnectFeaturesE7GNMGFID7GNMGFID7GNMGFID"></span><span id="_CPPv2N17GNMGenericNetwork18DisconnectFeaturesE7GNMGFID7GNMGFID7GNMGFID"></span><span id="GNMGenericNetwork::DisconnectFeatures__GNMGFID.GNMGFID.GNMGFID"></span><span class="target" id="classGNMGenericNetwork_1a958eb33070f3880fce535df6490ace5e"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DisconnectFeatures</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSrcFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nTgtFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nConFID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork18DisconnectFeaturesE7GNMGFID7GNMGFID7GNMGFID" title="Link to this definition"></a><br /></dt>
<dd><p>Remove features connection. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nSrcFID</strong> -- - source feature identificator </p></li>
<li><p><strong>nTgtFID</strong> -- - target feature identificator </p></li>
<li><p><strong>nConFID</strong> -- - connection feature identificator </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork24DisconnectFeaturesWithIdE7GNMGFID">
<span id="_CPPv3N17GNMGenericNetwork24DisconnectFeaturesWithIdE7GNMGFID"></span><span id="_CPPv2N17GNMGenericNetwork24DisconnectFeaturesWithIdE7GNMGFID"></span><span id="GNMGenericNetwork::DisconnectFeaturesWithId__GNMGFID"></span><span class="target" id="classGNMGenericNetwork_1a77a0dcc47c5b84537a0d23f183785315"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DisconnectFeaturesWithId</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nFID</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork24DisconnectFeaturesWithIdE7GNMGFID" title="Link to this definition"></a><br /></dt>
<dd><p>Find the corresponding identificator in graph (source, target, connector) and remove such connections. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nFID</strong> -- - identificator to find. </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork17ReconnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection">
<span id="_CPPv3N17GNMGenericNetwork17ReconnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection"></span><span id="_CPPv2N17GNMGenericNetwork17ReconnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection"></span><span id="GNMGenericNetwork::ReconnectFeatures__GNMGFID.GNMGFID.GNMGFID.double.double.GNMDirection"></span><span class="target" id="classGNMGenericNetwork_1a5c046a4ee9a18f4788abb297584d23ee"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ReconnectFeatures</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nSrcFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nTgtFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nConFID</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfCost</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfInvCost</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span>, <a class="reference internal" href="#_CPPv412GNMDirection" title="GNMDirection"><span class="n"><span class="pre">GNMDirection</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eDir</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">GNM_EDGE_DIR_BOTH</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork17ReconnectFeaturesE7GNMGFID7GNMGFID7GNMGFIDdd12GNMDirection" title="Link to this definition"></a><br /></dt>
<dd><p>Change connection attributes. </p>
<p>Search the connection by source feature identificator, target feature identificator and connection identificator. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nSrcFID</strong> -- - source feature identificator </p></li>
<li><p><strong>nTgtFID</strong> -- - target feature identificator </p></li>
<li><p><strong>nConFID</strong> -- - connection feature identificator </p></li>
<li><p><strong>dfCost</strong> -- - new cost moving from source to target </p></li>
<li><p><strong>dfInvCost</strong> -- - new cost moving from target to source </p></li>
<li><p><strong>eDir</strong> -- - new direction </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork13DisconnectAllEv">
<span id="_CPPv3N17GNMGenericNetwork13DisconnectAllEv"></span><span id="_CPPv2N17GNMGenericNetwork13DisconnectAllEv"></span><span id="GNMGenericNetwork::DisconnectAll"></span><span class="target" id="classGNMGenericNetwork_1a058ea589c0c3dac4d35261ec542fceaa"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DisconnectAll</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork13DisconnectAllEv" title="Link to this definition"></a><br /></dt>
<dd><p>DisconnectAll method clears the network graph. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork21GetFeatureByGlobalFIDE7GNMGFID">
<span id="_CPPv3N17GNMGenericNetwork21GetFeatureByGlobalFIDE7GNMGFID"></span><span id="_CPPv2N17GNMGenericNetwork21GetFeatureByGlobalFIDE7GNMGFID"></span><span id="GNMGenericNetwork::GetFeatureByGlobalFID__GNMGFID"></span><span class="target" id="classGNMGenericNetwork_1a71362afd2e1c8c6e93033ab3cc154cce"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetFeatureByGlobalFID</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nFID</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork21GetFeatureByGlobalFIDE7GNMGFID" title="Link to this definition"></a><br /></dt>
<dd><p>GetFeatureByGlobalFID search all network layers for given feature identificator. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nGFID</strong> -- feature identificator. </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> pointer or NULL. The pointer should be freed via <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2602d11f21567119da0ca6b6c5ad45"><span class="std std-ref">OGRFeature::DestroyFeature()</span></a>. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork10CreateRuleEPKc">
<span id="_CPPv3N17GNMGenericNetwork10CreateRuleEPKc"></span><span id="_CPPv2N17GNMGenericNetwork10CreateRuleEPKc"></span><span id="GNMGenericNetwork::CreateRule__cCP"></span><span class="target" id="classGNMGenericNetwork_1ad8f2c39e4e5d06ea26dfab89eb3609b1"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CreateRule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszRuleStr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork10CreateRuleEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Create network rule. </p>
<p>Creates the rule in the network according to the special syntax. These rules are declarative and make an effect for the network when they exist. Each rule for layer can be created only if the corresponding layer existed and removed when the layer is being deleted.</p>
<p>Rules syntax for the common network format in GNM contains the key words (words in capital letters or signs) and the modifiers which refers to the network objects. All the following combinations are available:</p>
<p>Notation: layer1, layer2, layer3 - a layer names (the corresponding layers must be exist; field1 - a field name (field must be exist); constant1 - any double constant; string1 - any string;</p>
<p>Rules describing which layer can be connected or not connected with each other, and (optional) which layer must serve as a connector. By default all connections are forbidden. But while network creation process the rule to allow any connection added. During the connection process each rule tested if this connection can be created.</p>
<p>&quot;ALLOW CONNECTS ANY&quot; &quot;DENY CONNECTS ANY&quot; &quot;DENY CONNECTS layer1 WITH layer2&quot; &quot;ALLOW CONNECTS layer1 WITH layer2 VIA layer3&quot;</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszRuleStr</strong> -- Rule string which will parsed. If the parsing was successful, the rule will start having effect immediately. </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork14DeleteAllRulesEv">
<span id="_CPPv3N17GNMGenericNetwork14DeleteAllRulesEv"></span><span id="_CPPv2N17GNMGenericNetwork14DeleteAllRulesEv"></span><span id="GNMGenericNetwork::DeleteAllRules"></span><span class="target" id="classGNMGenericNetwork_1a5113bb1b5205bfbe4be1d647b627c417"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DeleteAllRules</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork14DeleteAllRulesEv" title="Link to this definition"></a><br /></dt>
<dd><p>Delete all rules from network. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>CE_None on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork10DeleteRuleEPKc">
<span id="_CPPv3N17GNMGenericNetwork10DeleteRuleEPKc"></span><span id="_CPPv2N17GNMGenericNetwork10DeleteRuleEPKc"></span><span id="GNMGenericNetwork::DeleteRule__cCP"></span><span class="target" id="classGNMGenericNetwork_1a2d634a7bd0966af5450625a5906d232d"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DeleteRule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszRuleStr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork10DeleteRuleEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Delete the specified rule. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszRuleStr</strong> -- - the rule to delete </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK17GNMGenericNetwork8GetRulesEv">
<span id="_CPPv3NK17GNMGenericNetwork8GetRulesEv"></span><span id="_CPPv2NK17GNMGenericNetwork8GetRulesEv"></span><span id="GNMGenericNetwork::GetRulesC"></span><span class="target" id="classGNMGenericNetwork_1a3c4c68662a4040771ff8c08af99a62f3"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetRules</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK17GNMGenericNetwork8GetRulesEv" title="Link to this definition"></a><br /></dt>
<dd><p>Get the rule list. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of rule strings. The caller have to free the lis via CPLDestroy. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork20ConnectPointsByLinesEPPcddd12GNMDirection">
<span id="_CPPv3N17GNMGenericNetwork20ConnectPointsByLinesEPPcddd12GNMDirection"></span><span id="_CPPv2N17GNMGenericNetwork20ConnectPointsByLinesEPPcddd12GNMDirection"></span><span id="GNMGenericNetwork::ConnectPointsByLines__cPP.double.double.double.GNMDirection"></span><span class="target" id="classGNMGenericNetwork_1adfd4d1c7cb24e7610bfc15f0cbd1b476"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ConnectPointsByLines</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszLayerList</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfTolerance</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfCost</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfInvCost</span></span>, <a class="reference internal" href="#_CPPv412GNMDirection" title="GNMDirection"><span class="n"><span class="pre">GNMDirection</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eDir</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork20ConnectPointsByLinesEPPcddd12GNMDirection" title="Link to this definition"></a><br /></dt>
<dd><p>Attempts to build the network topology automatically. </p>
<p>The method simply gets point and line or multiline layers from the papszLayerList and searches for each line which connects two points: start and end, so it can be not so effective in performance when it is called on huge networks. Note, when passing your tolerance value: this value will depend of spatial reference system of the network, and especially of its 0,0 position because dfTolerance is just divided by 2 and added/subtracted to/from both sides of each line-feature end point forming thus the square area around it. The first point-feature occurred inside this area will be given as a start/end point for the current connection. So it is also desirable that at least two layers are passed in papszLayerList (one point and one line), and they are already connected &quot;visually&quot; (&quot;geometrically&quot;).</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>papszLayerList</strong> -- A list of layers to connect. The list should be freed via CSLDestroy. </p></li>
<li><p><strong>dfTolerance</strong> -- Snapping tolerance. </p></li>
<li><p><strong>dfCost</strong> -- Direct cost. </p></li>
<li><p><strong>dfInvCost</strong> -- Inverse cost. </p></li>
<li><p><strong>eDir</strong> -- Direction. </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork16ChangeBlockStateE7GNMGFIDb">
<span id="_CPPv3N17GNMGenericNetwork16ChangeBlockStateE7GNMGFIDb"></span><span id="_CPPv2N17GNMGenericNetwork16ChangeBlockStateE7GNMGFIDb"></span><span id="GNMGenericNetwork::ChangeBlockState__GNMGFID.b"></span><span class="target" id="classGNMGenericNetwork_1ae715f88098caf13603c44f21475351bf"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ChangeBlockState</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nFID</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bIsBlock</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork16ChangeBlockStateE7GNMGFIDb" title="Link to this definition"></a><br /></dt>
<dd><p>Change the block state of edge or vertex. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nFID</strong> -- Identificator </p></li>
<li><p><strong>bIsBlock</strong> -- Block or unblock </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork19ChangeAllBlockStateEb">
<span id="_CPPv3N17GNMGenericNetwork19ChangeAllBlockStateEb"></span><span id="_CPPv2N17GNMGenericNetwork19ChangeAllBlockStateEb"></span><span id="GNMGenericNetwork::ChangeAllBlockState__b"></span><span class="target" id="classGNMGenericNetwork_1a81f9bea3a45ea134ec443677c05ef61c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ChangeAllBlockState</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bIsBlock</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">false</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork19ChangeAllBlockStateEb" title="Link to this definition"></a><br /></dt>
<dd><p>Change all vertices and edges block state. </p>
<p>This is mainly use for unblock all vertices and edges.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bIsBlock</strong> -- Block or unblock </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None on success </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc">
<span id="_CPPv3N17GNMGenericNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc"></span><span id="_CPPv2N17GNMGenericNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc"></span><span id="GNMGenericNetwork::GetPath__GNMGFID.GNMGFID.GNMGraphAlgorithmType.cPP"></span><span class="target" id="classGNMGenericNetwork_1a922338fd67e1b2a2f5dad873964931b4"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetPath</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nStartFID</span></span>, <span class="n"><span class="pre">GNMGFID</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nEndFID</span></span>, <a class="reference internal" href="#_CPPv421GNMGraphAlgorithmType" title="GNMGraphAlgorithmType"><span class="n"><span class="pre">GNMGraphAlgorithmType</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">eAlgorithm</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork7GetPathE7GNMGFID7GNMGFID21GNMGraphAlgorithmTypePPc" title="Link to this definition"></a><br /></dt>
<dd><p>Create path between start and end GFIDs. </p>
<p><div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1ab2c2b105b8f76a279e6a53b9b4a182e0"><span class="std std-ref">ReleaseResultSet()</span></a>. </p>
</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nStartFID</strong> -- - start identificator </p></li>
<li><p><strong>nEndFID</strong> -- - end identificator </p></li>
<li><p><strong>eAlgorithm</strong> -- - The algorithm to get path </p></li>
<li><p><strong>papszOptions</strong> -- - algorithm specific options </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>In memory <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> pointer with features constituting the shortest path (or paths). The caller have to free the pointer via </p>
</dd>
</dl>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-protected-functions">Protected Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork16CheckLayerDriverEPKcPPc">
<span id="_CPPv3N17GNMGenericNetwork16CheckLayerDriverEPKcPPc"></span><span id="_CPPv2N17GNMGenericNetwork16CheckLayerDriverEPKcPPc"></span><span id="GNMGenericNetwork::CheckLayerDriver__cCP.cPP"></span><span class="target" id="classGNMGenericNetwork_1a4dc7cfae77cde3e55d8a64d8b587f772"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv46CPLErr" title="CPLErr"><span class="n"><span class="pre">CPLErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CheckLayerDriver</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszDefaultDriverName</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork16CheckLayerDriverEPKcPPc" title="Link to this definition"></a><br /></dt>
<dd><p>Check or create layer OGR driver. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pszDefaultDriverName</strong> -- - default driver name </p></li>
<li><p><strong>papszOptions</strong> -- - create options </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>CE_None if driver is exist or CE_Failure </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N17GNMGenericNetwork25CheckStorageDriverSupportEPKc">
<span id="_CPPv3N17GNMGenericNetwork25CheckStorageDriverSupportEPKc"></span><span id="_CPPv2N17GNMGenericNetwork25CheckStorageDriverSupportEPKc"></span><span id="GNMGenericNetwork::CheckStorageDriverSupport__cCP"></span><span class="target" id="classGNMGenericNetwork_1ab00a1f1cb9fc57ef0f6a90bd23567f6c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CheckStorageDriverSupport</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszDriverName</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="m"><span class="pre">0</span></span><a class="headerlink" href="#_CPPv4N17GNMGenericNetwork25CheckStorageDriverSupportEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Check if provided OGR driver accepted as storage for network data. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszDriverName</strong> -- The driver name </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>true if supported, else false </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv415GNMGenericLayer">
<span id="_CPPv315GNMGenericLayer"></span><span id="_CPPv215GNMGenericLayer"></span><span id="GNMGenericLayer"></span><span class="target" id="classGNMGenericLayer"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMGenericLayer</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><a class="headerlink" href="#_CPPv415GNMGenericLayer" title="Link to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;gnm.h&gt;</em></div>
<p>GNM layer which represents a geography network layer of generic format. </p>
<p>The class override some <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> methods to fulfill the network requirements.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer15GNMGenericLayerEP8OGRLayerP17GNMGenericNetwork">
<span id="_CPPv3N15GNMGenericLayer15GNMGenericLayerEP8OGRLayerP17GNMGenericNetwork"></span><span id="_CPPv2N15GNMGenericLayer15GNMGenericLayerEP8OGRLayerP17GNMGenericNetwork"></span><span id="GNMGenericLayer::GNMGenericLayer__OGRLayerP.GNMGenericNetworkP"></span><span class="target" id="classGNMGenericLayer_1ae548d3a02284e50e01a994abbe120c9c"></span><span class="sig-name descname"><span class="n"><span class="pre">GNMGenericLayer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poLayer</span></span>, <a class="reference internal" href="#_CPPv417GNMGenericNetwork" title="GNMGenericNetwork"><span class="n"><span class="pre">GNMGenericNetwork</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poNetwork</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer15GNMGenericLayerEP8OGRLayerP17GNMGenericNetwork" title="Link to this definition"></a><br /></dt>
<dd><p><a class="reference internal" href="#classGNMGenericLayer"><span class="std std-ref">GNMGenericLayer</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayerD0Ev">
<span id="_CPPv3N15GNMGenericLayerD0Ev"></span><span id="_CPPv2N15GNMGenericLayerD0Ev"></span><span id="GNMGenericLayer::~GNMGenericLayer"></span><span class="target" id="classGNMGenericLayer_1a42fff7c6b0216f2eac292789edd7fc6b"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">~GNMGenericLayer</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayerD0Ev" title="Link to this definition"></a><br /></dt>
<dd><p>~GNMGenericLayer </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer16GetSpatialFilterEv">
<span id="_CPPv3N15GNMGenericLayer16GetSpatialFilterEv"></span><span id="_CPPv2N15GNMGenericLayer16GetSpatialFilterEv"></span><span id="GNMGenericLayer::GetSpatialFilter"></span><span class="target" id="classGNMGenericLayer_1aae3e82b584b59d94ec34e2c4ab8beced"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrgeometry_cpp.html#_CPPv411OGRGeometry" title="OGRGeometry"><span class="n"><span class="pre">OGRGeometry</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetSpatialFilter</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer16GetSpatialFilterEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a36d61f311c9f8c172ad118659358c60a"><span class="std std-ref">OGR_L_GetSpatialFilter()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>spatial filter geometry. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer16SetSpatialFilterEP11OGRGeometry">
<span id="_CPPv3N15GNMGenericLayer16SetSpatialFilterEP11OGRGeometry"></span><span id="_CPPv2N15GNMGenericLayer16SetSpatialFilterEP11OGRGeometry"></span><span id="GNMGenericLayer::SetSpatialFilter__OGRGeometryP"></span><span class="target" id="classGNMGenericLayer_1a605821b486c96a1691ba3701f9946299"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetSpatialFilter</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrgeometry_cpp.html#_CPPv411OGRGeometry" title="OGRGeometry"><span class="n"><span class="pre">OGRGeometry</span></span></a><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer16SetSpatialFilterEP11OGRGeometry" title="Link to this definition"></a><br /></dt>
<dd><p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aa3d42b06ae6f7bbef6d1a2886da8d398"><span class="std std-ref">OGRGeometry::getEnvelope()</span></a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>Starting with GDAL 2.3, features with null or empty geometries will never be considered as matching a spatial filter.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a75c06b4993f8eb76b569f37365cd19ab"><span class="std std-ref">OGRLayer::GetSpatialRef()</span></a>). In the future this may be generalized.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a678d1735bc82533614ac005691d1138c"><span class="std std-ref">OGR_L_SetSpatialFilter()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poFilter</strong> -- the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer20SetSpatialFilterRectEdddd">
<span id="_CPPv3N15GNMGenericLayer20SetSpatialFilterRectEdddd"></span><span id="_CPPv2N15GNMGenericLayer20SetSpatialFilterRectEdddd"></span><span id="GNMGenericLayer::SetSpatialFilterRect__double.double.double.double"></span><span class="target" id="classGNMGenericLayer_1a81c7e3b89822cbd078b5fb3118471d98"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetSpatialFilterRect</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMinX</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMinY</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMaxX</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMaxY</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer20SetSpatialFilterRectEdddd" title="Link to this definition"></a><br /></dt>
<dd><p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a75c06b4993f8eb76b569f37365cd19ab"><span class="std std-ref">OGRLayer::GetSpatialRef()</span></a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">OGRLayer::SetSpatialFilter()</span></a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a5cba569e0779a02a95327f041d9f7a13"><span class="std std-ref">OGR_L_SetSpatialFilterRect()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dfMinX</strong> -- the minimum X coordinate for the rectangular region. </p></li>
<li><p><strong>dfMinY</strong> -- the minimum Y coordinate for the rectangular region. </p></li>
<li><p><strong>dfMaxX</strong> -- the maximum X coordinate for the rectangular region. </p></li>
<li><p><strong>dfMaxY</strong> -- the maximum Y coordinate for the rectangular region. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer16SetSpatialFilterEiP11OGRGeometry">
<span id="_CPPv3N15GNMGenericLayer16SetSpatialFilterEiP11OGRGeometry"></span><span id="_CPPv2N15GNMGenericLayer16SetSpatialFilterEiP11OGRGeometry"></span><span id="GNMGenericLayer::SetSpatialFilter__i.OGRGeometryP"></span><span class="target" id="classGNMGenericLayer_1a7dd9f62ec3a5e334a6a8ae5b32f2cbda"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetSpatialFilter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">iGeomField</span></span>, <a class="reference internal" href="ogrgeometry_cpp.html#_CPPv411OGRGeometry" title="OGRGeometry"><span class="n"><span class="pre">OGRGeometry</span></span></a><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer16SetSpatialFilterEiP11OGRGeometry" title="Link to this definition"></a><br /></dt>
<dd><p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="reference internal" href="ogrgeometry_cpp.html#classOGRGeometry_1aa3d42b06ae6f7bbef6d1a2886da8d398"><span class="std std-ref">OGRGeometry::getEnvelope()</span></a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;<a class="reference internal" href="#classGNMGenericLayer_1a6da7edd25c416684f858cb4a81ab92b2"><span class="std std-ref">GetSpatialRef()</span></a>). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>Note to driver implementer: if you implement <a class="reference internal" href="#classGNMGenericLayer_1a7dd9f62ec3a5e334a6a8ae5b32f2cbda"><span class="std std-ref">SetSpatialFilter(int,OGRGeometry*)</span></a>, you must also implement <a class="reference internal" href="#classGNMGenericLayer_1a605821b486c96a1691ba3701f9946299"><span class="std std-ref">SetSpatialFilter(OGRGeometry*)</span></a> to make it call SetSpatialFilter(0,OGRGeometry*).</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a00c8a1a968542d389f86ed1b4edd5823"><span class="std std-ref">OGR_L_SetSpatialFilterEx()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iGeomField</strong> -- index of the geometry field on which the spatial filter operates. </p></li>
<li><p><strong>poFilter</strong> -- the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer20SetSpatialFilterRectEidddd">
<span id="_CPPv3N15GNMGenericLayer20SetSpatialFilterRectEidddd"></span><span id="_CPPv2N15GNMGenericLayer20SetSpatialFilterRectEidddd"></span><span id="GNMGenericLayer::SetSpatialFilterRect__i.double.double.double.double"></span><span class="target" id="classGNMGenericLayer_1abde8cd58988f17b2f7d6c6e997f22293"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetSpatialFilterRect</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">iGeomField</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMinX</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMinY</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMaxX</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">dfMaxY</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer20SetSpatialFilterRectEidddd" title="Link to this definition"></a><br /></dt>
<dd><p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;<a class="reference internal" href="#classGNMGenericLayer_1a6da7edd25c416684f858cb4a81ab92b2"><span class="std std-ref">GetSpatialRef()</span></a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">OGRLayer::SetSpatialFilter()</span></a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a489241dfe65d6e089809d3258c4f79f5"><span class="std std-ref">OGR_L_SetSpatialFilterRectEx()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 1.11 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iGeomField</strong> -- index of the geometry field on which the spatial filter operates. </p></li>
<li><p><strong>dfMinX</strong> -- the minimum X coordinate for the rectangular region. </p></li>
<li><p><strong>dfMinY</strong> -- the minimum Y coordinate for the rectangular region. </p></li>
<li><p><strong>dfMaxX</strong> -- the maximum X coordinate for the rectangular region. </p></li>
<li><p><strong>dfMaxY</strong> -- the maximum Y coordinate for the rectangular region.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer18SetAttributeFilterEPKc">
<span id="_CPPv3N15GNMGenericLayer18SetAttributeFilterEPKc"></span><span id="_CPPv2N15GNMGenericLayer18SetAttributeFilterEPKc"></span><span id="GNMGenericLayer::SetAttributeFilter__cCP"></span><span class="target" id="classGNMGenericLayer_1aa900b33c9e5272514739266f70f57383"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetAttributeFilter</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer18SetAttributeFilterEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Set a new attribute query. </p>
<p>This method sets the attribute query string to be used when fetching features via the <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> method. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance &quot;population &gt; 1000000 and population &lt; 5000000&quot; where population is an attribute in the layer. The query format is normally a SQL WHERE clause as described in the <a class="reference external" href="https://gdal.org/user/ogr_sql_dialect.html#where">&quot;WHERE&quot;</a> section of the OGR SQL dialect documentation. In some cases (RDBMS backed drivers, SQLite, GeoPackage) the native capabilities of the database may be used to to interpret the WHERE clause, in which case the capabilities will be broader than those of OGR SQL.</p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="reference internal" href="#classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"><span class="std std-ref">ResetReading()</span></a>).</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a4000d426bf26ad7cc7d4012634c93f09"><span class="std std-ref">OGR_L_SetAttributeFilter()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszQuery</strong> -- query in restricted SQL WHERE format, or NULL to clear the current query.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer12ResetReadingEv">
<span id="_CPPv3N15GNMGenericLayer12ResetReadingEv"></span><span id="_CPPv2N15GNMGenericLayer12ResetReadingEv"></span><span id="GNMGenericLayer::ResetReading"></span><span class="target" id="classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ResetReading</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer12ResetReadingEv" title="Link to this definition"></a><br /></dt>
<dd><p>Reset feature reading to start on the first feature. </p>
<p>This affects <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> and <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a3ffa8511632cbb7cff06a908e6668f55"><span class="std std-ref">GetArrowStream()</span></a>.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"><span class="std std-ref">OGR_L_ResetReading()</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer14GetNextFeatureEv">
<span id="_CPPv3N15GNMGenericLayer14GetNextFeatureEv"></span><span id="_CPPv2N15GNMGenericLayer14GetNextFeatureEv"></span><span id="GNMGenericLayer::GetNextFeature"></span><span class="target" id="classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetNextFeature</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer14GetNextFeatureEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2602d11f21567119da0ca6b6c5ad45"><span class="std std-ref">OGRFeature::DestroyFeature()</span></a>. It is critical that all features associated with an <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> (more specifically an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with <a class="reference internal" href="#classGNMGenericLayer_1a605821b486c96a1691ba3701f9946299"><span class="std std-ref">SetSpatialFilter()</span></a>) will be returned.</p>
<p>This method implements sequential access to the features of a layer. The <a class="reference internal" href="#classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"><span class="std std-ref">ResetReading()</span></a> method can be used to start at the beginning again.</p>
<p>Starting with GDAL 3.6, it is possible to retrieve them by batches, with a column-oriented memory layout, using the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a3ffa8511632cbb7cff06a908e6668f55"><span class="std std-ref">GetArrowStream()</span></a> method.</p>
<p>Features returned by <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="reference internal" href="#classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"><span class="std std-ref">ResetReading()</span></a> on layers where <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="reference internal" href="#classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"><span class="std std-ref">ResetReading()</span></a> might be needed.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a6708c067521ab7b7f9c4ec0ebe221b5b"><span class="std std-ref">OGR_L_GetNextFeature()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>a feature, or NULL if no more features are available. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer14SetNextByIndexE7GIntBig">
<span id="_CPPv3N15GNMGenericLayer14SetNextByIndexE7GIntBig"></span><span id="_CPPv2N15GNMGenericLayer14SetNextByIndexE7GIntBig"></span><span id="GNMGenericLayer::SetNextByIndex__GIntBig"></span><span class="target" id="classGNMGenericLayer_1a67cd391cf8015675b45c7553cd02906e"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetNextByIndex</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nIndex</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer14SetNextByIndexE7GIntBig" title="Link to this definition"></a><br /></dt>
<dd><p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is <a class="reference internal" href="#classGNMGenericLayer_1a67cd391cf8015675b45c7553cd02906e"><span class="std std-ref">SetNextByIndex()</span></a> efficiently implemented. In all other cases the default implementation which calls <a class="reference internal" href="#classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"><span class="std std-ref">ResetReading()</span></a> and then calls <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> nIndex times is used. To determine if fast seeking is available on the current layer use the <a class="reference internal" href="#classGNMGenericLayer_1a6756f1d50d6aa06a66a5bb3483bdacfd"><span class="std std-ref">TestCapability()</span></a> method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a8b4427a82ea3de3bed7acff19b6e8e33"><span class="std std-ref">OGR_L_SetNextByIndex()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nIndex</strong> -- the index indicating how many steps into the result set to seek.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success or an error code. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer13DeleteFeatureE7GIntBig">
<span id="_CPPv3N15GNMGenericLayer13DeleteFeatureE7GIntBig"></span><span id="_CPPv2N15GNMGenericLayer13DeleteFeatureE7GIntBig"></span><span id="GNMGenericLayer::DeleteFeature__GIntBig"></span><span class="target" id="classGNMGenericLayer_1ade0d4b235a725ad16faac2e0b659e33b"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DeleteFeature</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nFID</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer13DeleteFeatureE7GIntBig" title="Link to this definition"></a><br /></dt>
<dd><p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="reference internal" href="#classGNMGenericLayer_1a6756f1d50d6aa06a66a5bb3483bdacfd"><span class="std std-ref">TestCapability()</span></a> layer method may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ae5acdeffac0c7a8ee33ac3a55db18949"><span class="std std-ref">OGR_L_DeleteFeature()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nFID</strong> -- the feature id to be deleted from the layer</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer7GetNameEv">
<span id="_CPPv3N15GNMGenericLayer7GetNameEv"></span><span id="_CPPv2N15GNMGenericLayer7GetNameEv"></span><span id="GNMGenericLayer::GetName"></span><span class="target" id="classGNMGenericLayer_1a14fea999cd24d7eb5b11657c82d78b8d"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer7GetNameEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return the layer name. </p>
<p>This returns the same content as <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ab8fa2428efb085a0b5dd78342b535aeb"><span class="std std-ref">OGRFeatureDefn::GetName()</span></a>, but for a few drivers, calling <a class="reference internal" href="#classGNMGenericLayer_1a14fea999cd24d7eb5b11657c82d78b8d"><span class="std std-ref">GetName()</span></a> directly can avoid lengthy layer definition initialization.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a88facf4f8e8b32278101d52ae094255c"><span class="std std-ref">OGR_L_GetName()</span></a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1ab8fa2428efb085a0b5dd78342b535aeb"><span class="std std-ref">OGRFeatureDefn::GetName()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>the layer name (must not been freed) </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer11GetGeomTypeEv">
<span id="_CPPv3N15GNMGenericLayer11GetGeomTypeEv"></span><span id="_CPPv2N15GNMGenericLayer11GetGeomTypeEv"></span><span id="GNMGenericLayer::GetGeomType"></span><span class="target" id="classGNMGenericLayer_1a831c4f8baebf8167196106cb8de71e26"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv418OGRwkbGeometryType" title="OGRwkbGeometryType"><span class="n"><span class="pre">OGRwkbGeometryType</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetGeomType</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer11GetGeomTypeEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return the layer geometry type. </p>
<p>This returns the same result as <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1acc3e3904d856b9c8b5b26204c68e916a"><span class="std std-ref">OGRFeatureDefn::GetGeomType()</span></a>, but for a few drivers, calling <a class="reference internal" href="#classGNMGenericLayer_1a831c4f8baebf8167196106cb8de71e26"><span class="std std-ref">GetGeomType()</span></a> directly can avoid lengthy layer definition initialization.</p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetType(). For layers without any geometry field, this method returns wkbNone.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a0adea8ce1ca795ce0a6a76505f90f078"><span class="std std-ref">OGR_L_GetGeomType()</span></a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1acc3e3904d856b9c8b5b26204c68e916a"><span class="std std-ref">OGRFeatureDefn::GetGeomType()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.8.0 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>the geometry type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer12GetLayerDefnEv">
<span id="_CPPv3N15GNMGenericLayer12GetLayerDefnEv"></span><span id="_CPPv2N15GNMGenericLayer12GetLayerDefnEv"></span><span id="GNMGenericLayer::GetLayerDefn"></span><span class="target" id="classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv414OGRFeatureDefn" title="OGRFeatureDefn"><span class="n"><span class="pre">OGRFeatureDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetLayerDefn</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer12GetLayerDefnEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the schema information for this layer. </p>
<p>The returned <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> is owned by the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a7b67ea4ab5892c6720460dc7f66eca2d"><span class="std std-ref">OGR_L_GetLayerDefn()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>feature definition. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer14FindFieldIndexEPKci">
<span id="_CPPv3N15GNMGenericLayer14FindFieldIndexEPKci"></span><span id="_CPPv2N15GNMGenericLayer14FindFieldIndexEPKci"></span><span id="GNMGenericLayer::FindFieldIndex__cCP.i"></span><span class="target" id="classGNMGenericLayer_1a3cf969adb8b5e2358846844a58b890fd"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FindFieldIndex</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszFieldName</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bExactMatch</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer14FindFieldIndexEPKci" title="Link to this definition"></a><br /></dt>
<dd><p>Find the index of field in the layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1affc3cef62be82ec4f811a89b1855cbd5"><span class="std std-ref">OGR_L_FindFieldIndex()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>field index, or -1 if the field doesn't exist </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer13GetSpatialRefEv">
<span id="_CPPv3N15GNMGenericLayer13GetSpatialRefEv"></span><span id="_CPPv2N15GNMGenericLayer13GetSpatialRefEv"></span><span id="GNMGenericLayer::GetSpatialRef"></span><span class="target" id="classGNMGenericLayer_1a6da7edd25c416684f858cb4a81ab92b2"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrspatialref.html#_CPPv419OGRSpatialReference" title="OGRSpatialReference"><span class="n"><span class="pre">OGRSpatialReference</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetSpatialRef</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer13GetSpatialRefEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> and should not be modified or freed by the application.</p>
<p>Starting with OGR 1.11, several geometry fields can be associated to a feature definition. Each geometry field can have its own spatial reference system, which is returned by <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1acdc7b11a77a8e3f838a2b33965e2971f"><span class="std std-ref">OGRGeomFieldDefn::GetSpatialRef()</span></a>. <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a75c06b4993f8eb76b569f37365cd19ab"><span class="std std-ref">OGRLayer::GetSpatialRef()</span></a> is equivalent to <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(0)-&gt;<a class="reference internal" href="#classGNMGenericLayer_1a6da7edd25c416684f858cb4a81ab92b2"><span class="std std-ref">GetSpatialRef()</span></a></p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a8b2a10085f410aa84172eba413408c39"><span class="std std-ref">OGR_L_GetSpatialRef()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>spatial reference, or NULL if there isn't one. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer15GetFeatureCountEi">
<span id="_CPPv3N15GNMGenericLayer15GetFeatureCountEi"></span><span id="_CPPv2N15GNMGenericLayer15GetFeatureCountEi"></span><span id="GNMGenericLayer::GetFeatureCount__i"></span><span class="target" id="classGNMGenericLayer_1a3f73cdc43100a0443da3e5549a152490"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetFeatureCount</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bForce</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer15GetFeatureCountEi" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a08524b6961e52e1561308d2b0c598fb2"><span class="std std-ref">OGR_L_GetFeatureCount()</span></a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bForce</strong> -- Flag indicating whether the count should be computed even if it is expensive.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>feature count, -1 if count not known. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer9GetExtentEP11OGREnvelopei">
<span id="_CPPv3N15GNMGenericLayer9GetExtentEP11OGREnvelopei"></span><span id="_CPPv2N15GNMGenericLayer9GetExtentEP11OGREnvelopei"></span><span id="GNMGenericLayer::GetExtent__OGREnvelopeP.i"></span><span class="target" id="classGNMGenericLayer_1a246b6f98cb4e51ea10514945ec505369"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetExtent</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="vector_c_api.html#_CPPv411OGREnvelope" title="OGREnvelope"><span class="n"><span class="pre">OGREnvelope</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">psExtent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bForce</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer9GetExtentEP11OGREnvelopei" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="reference internal" href="#classGNMGenericLayer_1a246b6f98cb4e51ea10514945ec505369"><span class="std std-ref">GetExtent()</span></a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1aa6c495581900c8301dff91d8cd3ee12f"><span class="std std-ref">OGR_L_GetExtent()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psExtent</strong> -- the structure in which the extent value will be returned. </p></li>
<li><p><strong>bForce</strong> -- Flag indicating whether the extent should be computed even if it is expensive.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer9GetExtentEiP11OGREnvelopei">
<span id="_CPPv3N15GNMGenericLayer9GetExtentEiP11OGREnvelopei"></span><span id="_CPPv2N15GNMGenericLayer9GetExtentEiP11OGREnvelopei"></span><span id="GNMGenericLayer::GetExtent__i.OGREnvelopeP.i"></span><span class="target" id="classGNMGenericLayer_1aa35416294aac0b338d5a2d881ff1fdee"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetExtent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">iGeomField</span></span>, <a class="reference internal" href="vector_c_api.html#_CPPv411OGREnvelope" title="OGREnvelope"><span class="n"><span class="pre">OGREnvelope</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">psExtent</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bForce</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer9GetExtentEiP11OGREnvelopei" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="reference internal" href="#classGNMGenericLayer_1a246b6f98cb4e51ea10514945ec505369"><span class="std std-ref">GetExtent()</span></a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>Note to driver implementer: if you implement <a class="reference internal" href="#classGNMGenericLayer_1aa35416294aac0b338d5a2d881ff1fdee"><span class="std std-ref">GetExtent(int,OGREnvelope*,int)</span></a>, you must also implement <a class="reference internal" href="#classGNMGenericLayer_1a246b6f98cb4e51ea10514945ec505369"><span class="std std-ref">GetExtent(OGREnvelope*, int)</span></a> to make it call GetExtent(0,OGREnvelope*,int).</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ac3dbfd4443c80dca0d93574f0c00d376"><span class="std std-ref">OGR_L_GetExtentEx()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iGeomField</strong> -- the index of the geometry field on which to compute the extent. </p></li>
<li><p><strong>psExtent</strong> -- the structure in which the extent value will be returned. </p></li>
<li><p><strong>bForce</strong> -- Flag indicating whether the extent should be computed even if it is expensive.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer14TestCapabilityEPKc">
<span id="_CPPv3N15GNMGenericLayer14TestCapabilityEPKc"></span><span id="_CPPv2N15GNMGenericLayer14TestCapabilityEPKc"></span><span id="GNMGenericLayer::TestCapability__cCP"></span><span class="target" id="classGNMGenericLayer_1a6756f1d50d6aa06a66a5bb3483bdacfd"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TestCapability</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">*</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer14TestCapabilityEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<p><ul>
<li><p><strong>OLCRandomRead</strong> / &quot;RandomRead&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ace902dfb44335fb1a877aa035ecff209"><span class="std std-ref">GetFeature()</span></a> method is implemented in an optimized way for this layer, as opposed to the default implementation using <a class="reference internal" href="#classGNMGenericLayer_1a479d90adb91ed34e34417e98caf787c2"><span class="std std-ref">ResetReading()</span></a> and <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> to find the requested feature id.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCSequentialWrite</strong> / &quot;SequentialWrite&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaa1e32016f481596a55e1d988a15a067"><span class="std std-ref">CreateFeature()</span></a> method works for this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCRandomWrite</strong> / &quot;RandomWrite&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a681139bfd585b74d7218e51a32144283"><span class="std std-ref">SetFeature()</span></a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCUpsertFeature</strong> / &quot;UpsertFeature&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0fde458509b0cccc23d2ce89c1fd9dfb"><span class="std std-ref">UpsertFeature()</span></a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastSpatialFilter</strong> / &quot;FastSpatialFilter&quot;: TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastFeatureCount</strong> / &quot;FastFeatureCount&quot;: TRUE if this layer can return a feature count (via <a class="reference internal" href="#classGNMGenericLayer_1a3f73cdc43100a0443da3e5549a152490"><span class="std std-ref">GetFeatureCount()</span></a>) efficiently. i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastGetExtent</strong> / &quot;FastGetExtent&quot;: TRUE if this layer can return its data extent (via <a class="reference internal" href="#classGNMGenericLayer_1a246b6f98cb4e51ea10514945ec505369"><span class="std std-ref">GetExtent()</span></a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastSetNextByIndex</strong> / &quot;FastSetNextByIndex&quot;: TRUE if this layer can perform the <a class="reference internal" href="#classGNMGenericLayer_1a67cd391cf8015675b45c7553cd02906e"><span class="std std-ref">SetNextByIndex()</span></a> call efficiently, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCreateField</strong> / &quot;CreateField&quot;: TRUE if this layer can create new fields on the current layer using <a class="reference internal" href="#classGNMGenericLayer_1aab7c696d435facb07d4e3eb4d09996a0"><span class="std std-ref">CreateField()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCreateGeomField</strong> / &quot;CreateGeomField&quot;: (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using <a class="reference internal" href="#classGNMGenericLayer_1a889597a2d838e3a83e98dd756d60d461"><span class="std std-ref">CreateGeomField()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCDeleteField</strong> / &quot;DeleteField&quot;: TRUE if this layer can delete existing fields on the current layer using <a class="reference internal" href="#classGNMGenericLayer_1a7958d03d3b963bce513902e7a94a1dd0"><span class="std std-ref">DeleteField()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCReorderFields</strong> / &quot;ReorderFields&quot;: TRUE if this layer can reorder existing fields on the current layer using <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ab4c02b991bfa78552eeb0cbcdcf1aed8"><span class="std std-ref">ReorderField()</span></a> or <a class="reference internal" href="#classGNMGenericLayer_1a171a2be1c00ce80a9ba93139fd5149ed"><span class="std std-ref">ReorderFields()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCAlterFieldDefn</strong> / &quot;AlterFieldDefn&quot;: TRUE if this layer can alter the definition of an existing field on the current layer using <a class="reference internal" href="#classGNMGenericLayer_1a69f80c8342c6ad3b6d16ad33d8b2153c"><span class="std std-ref">AlterFieldDefn()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCAlterGeomFieldDefn</strong> / &quot;AlterGeomFieldDefn&quot;: TRUE if this layer can alter the definition of an existing geometry field on the current layer using <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a49a87755bff79d25c5774280023dda0b"><span class="std std-ref">AlterGeomFieldDefn()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCDeleteFeature</strong> / &quot;DeleteFeature&quot;: TRUE if the <a class="reference internal" href="#classGNMGenericLayer_1ade0d4b235a725ad16faac2e0b659e33b"><span class="std std-ref">DeleteFeature()</span></a> method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCStringsAsUTF8</strong> / &quot;StringsAsUTF8&quot;: TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCTransactions</strong> / &quot;Transactions&quot;: TRUE if the <a class="reference internal" href="#classGNMGenericLayer_1aa51170039be88e1cafa99c9483408127"><span class="std std-ref">StartTransaction()</span></a>, <a class="reference internal" href="#classGNMGenericLayer_1a92933b3aeef549807394bf578416aad2"><span class="std std-ref">CommitTransaction()</span></a> and <a class="reference internal" href="#classGNMGenericLayer_1a50dfbdab339aa69aca5aea6d454567e8"><span class="std std-ref">RollbackTransaction()</span></a> methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCIgnoreFields</strong> / &quot;IgnoreFields&quot;: TRUE if fields, geometry and style will be omitted when fetching features as set by <a class="reference internal" href="#classGNMGenericLayer_1a8a5fbe69544693ae4b015592ea838f7c"><span class="std std-ref">SetIgnoredFields()</span></a> method.</p>
<p></p>
</li>
<li><p><strong>OLCCurveGeometries</strong> / &quot;CurveGeometries&quot;: TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p></p>
<p></p>
<p></p>
</li>
</ul>
</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a480adc8b839b04597f49583371d366fd"><span class="std std-ref">OGR_L_TestCapability()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszCap</strong> -- the name of the capability to test.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer11CreateFieldEPK12OGRFieldDefni">
<span id="_CPPv3N15GNMGenericLayer11CreateFieldEPK12OGRFieldDefni"></span><span id="_CPPv2N15GNMGenericLayer11CreateFieldEPK12OGRFieldDefni"></span><span id="GNMGenericLayer::CreateField__OGRFieldDefnCP.i"></span><span class="target" id="classGNMGenericLayer_1aab7c696d435facb07d4e3eb4d09996a0"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CreateField</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv412OGRFieldDefn" title="OGRFieldDefn"><span class="n"><span class="pre">OGRFieldDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poField</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bApproxOK</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer11CreateFieldEPK12OGRFieldDefni" title="Link to this definition"></a><br /></dt>
<dd><p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1aab585ef1166c61c4819f7fd46ee4a275"><span class="std std-ref">OGR_L_CreateField()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poField</strong> -- field definition to write to disk. </p></li>
<li><p><strong>bApproxOK</strong> -- If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer11DeleteFieldEi">
<span id="_CPPv3N15GNMGenericLayer11DeleteFieldEi"></span><span id="_CPPv2N15GNMGenericLayer11DeleteFieldEi"></span><span id="GNMGenericLayer::DeleteField__i"></span><span class="target" id="classGNMGenericLayer_1a7958d03d3b963bce513902e7a94a1dd0"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">DeleteField</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">iField</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer11DeleteFieldEi" title="Link to this definition"></a><br /></dt>
<dd><p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1afc861413683418eba5d31e487da2f9e2"><span class="std std-ref">OGR_L_DeleteField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iField</strong> -- index of the field to delete.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer13ReorderFieldsEPi">
<span id="_CPPv3N15GNMGenericLayer13ReorderFieldsEPi"></span><span id="_CPPv2N15GNMGenericLayer13ReorderFieldsEPi"></span><span id="GNMGenericLayer::ReorderFields__iP"></span><span class="target" id="classGNMGenericLayer_1a171a2be1c00ce80a9ba93139fd5149ed"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ReorderFields</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">panMap</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer13ReorderFieldsEPi" title="Link to this definition"></a><br /></dt>
<dd><p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot; initially. ReorderFields([0,2,3,1,4]) will reorder them as &quot;0&quot;,&quot;2&quot;,&quot;3&quot;,&quot;1&quot;,&quot;4&quot;.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a4cc576cb39e1dd4a1f074125199245bb"><span class="std std-ref">OGR_L_ReorderFields()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>panMap</strong> -- an array of <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a3abba98e1e957a01b3af0b9e0f73f493"><span class="std std-ref">OGRFeatureDefn::GetFieldCount()</span></a> elements which is a permutation of [0, <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn_1a3abba98e1e957a01b3af0b9e0f73f493"><span class="std std-ref">OGRFeatureDefn::GetFieldCount()</span></a>-1].</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer14AlterFieldDefnEiP12OGRFieldDefni">
<span id="_CPPv3N15GNMGenericLayer14AlterFieldDefnEiP12OGRFieldDefni"></span><span id="_CPPv2N15GNMGenericLayer14AlterFieldDefnEiP12OGRFieldDefni"></span><span id="GNMGenericLayer::AlterFieldDefn__i.OGRFieldDefnP.i"></span><span class="target" id="classGNMGenericLayer_1a69f80c8342c6ad3b6d16ad33d8b2153c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">AlterFieldDefn</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">iField</span></span>, <a class="reference internal" href="ogrfeature_cpp.html#_CPPv412OGRFieldDefn" title="OGRFieldDefn"><span class="n"><span class="pre">OGRFieldDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poNewFieldDefn</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nFlagsIn</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer14AlterFieldDefnEiP12OGRFieldDefni" title="Link to this definition"></a><br /></dt>
<dd><p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a679904d97c1084f309706ac3c6228cec"><span class="std std-ref">OGR_L_AlterFieldDefn()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.9.0 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iField</strong> -- index of the field whose definition must be altered. </p></li>
<li><p><strong>poNewFieldDefn</strong> -- new field definition </p></li>
<li><p><strong>nFlags</strong> -- combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer15CreateGeomFieldEPK16OGRGeomFieldDefni">
<span id="_CPPv3N15GNMGenericLayer15CreateGeomFieldEPK16OGRGeomFieldDefni"></span><span id="_CPPv2N15GNMGenericLayer15CreateGeomFieldEPK16OGRGeomFieldDefni"></span><span id="GNMGenericLayer::CreateGeomField__OGRGeomFieldDefnCP.i"></span><span class="target" id="classGNMGenericLayer_1a889597a2d838e3a83e98dd756d60d461"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CreateGeomField</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv416OGRGeomFieldDefn" title="OGRGeomFieldDefn"><span class="n"><span class="pre">OGRGeomFieldDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poField</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bApproxOK</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer15CreateGeomFieldEPK16OGRGeomFieldDefni" title="Link to this definition"></a><br /></dt>
<dd><p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateGeomField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1af6908931c4f3ad364fef8d6e831363bc"><span class="std std-ref">OGR_L_CreateGeomField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.11 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poField</strong> -- geometry field definition to write to disk. </p></li>
<li><p><strong>bApproxOK</strong> -- If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer10SyncToDiskEv">
<span id="_CPPv3N15GNMGenericLayer10SyncToDiskEv"></span><span id="_CPPv2N15GNMGenericLayer10SyncToDiskEv"></span><span id="GNMGenericLayer::SyncToDisk"></span><span class="target" id="classGNMGenericLayer_1a2c5b4e4b8e3d7a132d6a3d40c2a2dea7"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SyncToDisk</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer10SyncToDiskEv" title="Link to this definition"></a><br /></dt>
<dd><p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with OGRDataSource::DestroyDataSource() that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a9d845a6cf6652756925530418905471a"><span class="std std-ref">OGR_L_SyncToDisk()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer13GetStyleTableEv">
<span id="_CPPv3N15GNMGenericLayer13GetStyleTableEv"></span><span id="_CPPv2N15GNMGenericLayer13GetStyleTableEv"></span><span id="GNMGenericLayer::GetStyleTable"></span><span class="target" id="classGNMGenericLayer_1a5d4c6c2d6fd1330851749eb87fc9143a"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeaturestyle_cpp.html#_CPPv413OGRStyleTable" title="OGRStyleTable"><span class="n"><span class="pre">OGRStyleTable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetStyleTable</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer13GetStyleTableEv" title="Link to this definition"></a><br /></dt>
<dd><p>Returns layer style table. </p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1aceae9ba8158efda9d1bd016022c627ca"><span class="std std-ref">OGR_L_GetStyleTable()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>pointer to a style table which should not be modified or freed by the caller. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer21SetStyleTableDirectlyEP13OGRStyleTable">
<span id="_CPPv3N15GNMGenericLayer21SetStyleTableDirectlyEP13OGRStyleTable"></span><span id="_CPPv2N15GNMGenericLayer21SetStyleTableDirectlyEP13OGRStyleTable"></span><span id="GNMGenericLayer::SetStyleTableDirectly__OGRStyleTableP"></span><span class="target" id="classGNMGenericLayer_1ad3bd0cdf55e1249cdbe9b222e6100209"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetStyleTableDirectly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrfeaturestyle_cpp.html#_CPPv413OGRStyleTable" title="OGRStyleTable"><span class="n"><span class="pre">OGRStyleTable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poStyleTable</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer21SetStyleTableDirectlyEP13OGRStyleTable" title="Link to this definition"></a><br /></dt>
<dd><p>Set layer style table. </p>
<p>This method operate exactly as <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a33fa0802c0686fb0e6ca6337e11cd7d5"><span class="std std-ref">OGRLayer::SetStyleTable()</span></a> except that it assumes ownership of the passed table.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ab6b700a54fb41ade2b3b090b2e0ef4be"><span class="std std-ref">OGR_L_SetStyleTableDirectly()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poStyleTable</strong> -- pointer to style table to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer13SetStyleTableEP13OGRStyleTable">
<span id="_CPPv3N15GNMGenericLayer13SetStyleTableEP13OGRStyleTable"></span><span id="_CPPv2N15GNMGenericLayer13SetStyleTableEP13OGRStyleTable"></span><span id="GNMGenericLayer::SetStyleTable__OGRStyleTableP"></span><span class="target" id="classGNMGenericLayer_1a22b8c67af40323b91e191f05a0086eb2"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetStyleTable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrfeaturestyle_cpp.html#_CPPv413OGRStyleTable" title="OGRStyleTable"><span class="n"><span class="pre">OGRStyleTable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poStyleTable</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer13SetStyleTableEP13OGRStyleTable" title="Link to this definition"></a><br /></dt>
<dd><p>Set layer style table. </p>
<p>This method operate exactly as <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a2687d4312c044bb3a20bd13974ba8905"><span class="std std-ref">OGRLayer::SetStyleTableDirectly()</span></a> except that it does not assume ownership of the passed table.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a9c5965608098528549e585895cb62e92"><span class="std std-ref">OGR_L_SetStyleTable()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poStyleTable</strong> -- pointer to style table to set </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer16StartTransactionEv">
<span id="_CPPv3N15GNMGenericLayer16StartTransactionEv"></span><span id="_CPPv2N15GNMGenericLayer16StartTransactionEv"></span><span id="GNMGenericLayer::StartTransaction"></span><span class="target" id="classGNMGenericLayer_1aa51170039be88e1cafa99c9483408127"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StartTransaction</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer16StartTransactionEv" title="Link to this definition"></a><br /></dt>
<dd><p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>Note: as of GDAL 2.0, use of this API is discouraged when the dataset offers dataset level transaction with <a class="reference internal" href="gdaldataset_cpp.html#classGDALDataset_1a3e4161f148fac57dac5cfe4900421348"><span class="std std-ref">GDALDataset::StartTransaction()</span></a>. The reason is that most drivers can only offer transactions at dataset level, and not layer level. Very few drivers really support transactions at layer scope.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a8180ea56ca7f677eb5da05c8cfcb77be"><span class="std std-ref">OGR_L_StartTransaction()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>OGRERR_NONE on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer17CommitTransactionEv">
<span id="_CPPv3N15GNMGenericLayer17CommitTransactionEv"></span><span id="_CPPv2N15GNMGenericLayer17CommitTransactionEv"></span><span id="GNMGenericLayer::CommitTransaction"></span><span class="target" id="classGNMGenericLayer_1a92933b3aeef549807394bf578416aad2"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommitTransaction</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer17CommitTransactionEv" title="Link to this definition"></a><br /></dt>
<dd><p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a6135ef3b16c3cc974682365783603cc6"><span class="std std-ref">OGR_L_CommitTransaction()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>OGRERR_NONE on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer19RollbackTransactionEv">
<span id="_CPPv3N15GNMGenericLayer19RollbackTransactionEv"></span><span id="_CPPv2N15GNMGenericLayer19RollbackTransactionEv"></span><span id="GNMGenericLayer::RollbackTransaction"></span><span class="target" id="classGNMGenericLayer_1a50dfbdab339aa69aca5aea6d454567e8"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">RollbackTransaction</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer19RollbackTransactionEv" title="Link to this definition"></a><br /></dt>
<dd><p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. </p>
<p>If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a823a6c351dccf751777f67801dd7f9c5"><span class="std std-ref">OGR_L_RollbackTransaction()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>OGRERR_NONE on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer12GetFIDColumnEv">
<span id="_CPPv3N15GNMGenericLayer12GetFIDColumnEv"></span><span id="_CPPv2N15GNMGenericLayer12GetFIDColumnEv"></span><span id="GNMGenericLayer::GetFIDColumn"></span><span class="target" id="classGNMGenericLayer_1a1153cc46ed17cb4ac1398d6ac6b0cc5d"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetFIDColumn</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer12GetFIDColumnEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method returns the name of the underlying database column being used as the FID column, or &quot;&quot; if not supported. </p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1abfeb6e1258f113c6c45c8d6a43c8cfa5"><span class="std std-ref">OGR_L_GetFIDColumn()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>fid column name. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer17GetGeometryColumnEv">
<span id="_CPPv3N15GNMGenericLayer17GetGeometryColumnEv"></span><span id="_CPPv2N15GNMGenericLayer17GetGeometryColumnEv"></span><span id="GNMGenericLayer::GetGeometryColumn"></span><span class="target" id="classGNMGenericLayer_1aab97b4895cc5831b0e927d70e8f44961"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetGeometryColumn</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer17GetGeometryColumnEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method returns the name of the underlying database column being used as the geometry column, or &quot;&quot; if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the name of the first geometry column. For other columns, use <a class="reference internal" href="#classGNMGenericLayer_1a1a51b83925df6eee668a3417ac9105c8"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetNameRef().</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ab060e07e277cebd1d8504c449d97b29f"><span class="std std-ref">OGR_L_GetGeometryColumn()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>geometry column name. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer16SetIgnoredFieldsE12CSLConstList">
<span id="_CPPv3N15GNMGenericLayer16SetIgnoredFieldsE12CSLConstList"></span><span id="_CPPv2N15GNMGenericLayer16SetIgnoredFieldsE12CSLConstList"></span><span id="GNMGenericLayer::SetIgnoredFields__CSLConstList"></span><span class="target" id="classGNMGenericLayer_1a8a5fbe69544693ae4b015592ea838f7c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetIgnoredFields</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="cpl.html#_CPPv412CSLConstList" title="CSLConstList"><span class="n"><span class="pre">CSLConstList</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">papszFields</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer16SetIgnoredFieldsE12CSLConstList" title="Link to this definition"></a><br /></dt>
<dd><p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ace902dfb44335fb1a877aa035ecff209"><span class="std std-ref">GetFeature()</span></a> / <a class="reference internal" href="#classGNMGenericLayer_1a9103cc8308203034828993fc1e0b23db"><span class="std std-ref">GetNextFeature()</span></a> and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: &quot;OGR_GEOMETRY&quot; to ignore geometry and &quot;OGR_STYLE&quot; to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>Note that fields that are used in an attribute filter should generally not be set as ignored fields, as most drivers (such as those relying on the OGR SQL engine) will be unable to correctly evaluate the attribute filter.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a6d43f1474201356bed2e6f92e7d37154"><span class="std std-ref">OGR_L_SetIgnoredFields()</span></a></p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>papszFields</strong> -- an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer12IntersectionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer12IntersectionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer12IntersectionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::Intersection__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1aa592a7e479b74d289cb460b26bfe0a73"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Intersection</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer12IntersectionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>Intersection. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer5UnionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer5UnionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer5UnionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::Union__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1a3b1e7acbfb8dbe0d4043474f77f827f5"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Union</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer5UnionEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>Union. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer13SymDifferenceEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer13SymDifferenceEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer13SymDifferenceEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::SymDifference__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1ae47c1c1228ad08b7323e9c451bc8ab79"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SymDifference</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer13SymDifferenceEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>SymDifference. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer8IdentityEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer8IdentityEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer8IdentityEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::Identity__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1af68b55b62ba91bd95373bc838d079dee"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Identity</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer8IdentityEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>Identity. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer6UpdateEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer6UpdateEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer6UpdateEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::Update__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1a6c9b0f8ccdd63a212af3407f7e2f6f6f"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Update</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer6UpdateEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>Update. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer4ClipEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer4ClipEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer4ClipEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::Clip__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1a4f2d8efb2913012393a9e143d3770a67"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Clip</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer4ClipEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>Clip. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer5EraseEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv">
<span id="_CPPv3N15GNMGenericLayer5EraseEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="_CPPv2N15GNMGenericLayer5EraseEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv"></span><span id="GNMGenericLayer::Erase__OGRLayerP.OGRLayerP.cPP.GDALProgressFunc.voidP"></span><span class="target" id="classGNMGenericLayer_1afb41eca34d6ed6f0d92522c087333802"></span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Erase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerMethod</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pLayerResult</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">papszOptions</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <a class="reference internal" href="cpl.html#_CPPv416GDALProgressFunc" title="GDALProgressFunc"><span class="n"><span class="pre">GDALProgressFunc</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">pfnProgress</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pProgressArg</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">nullptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer5EraseEP8OGRLayerP8OGRLayerPPc16GDALProgressFuncPv" title="Link to this definition"></a><br /></dt>
<dd><p>Erase. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer15GetFeaturesReadEv">
<span id="_CPPv3N15GNMGenericLayer15GetFeaturesReadEv"></span><span id="_CPPv2N15GNMGenericLayer15GetFeaturesReadEv"></span><span id="GNMGenericLayer::GetFeaturesRead"></span><span class="target" id="classGNMGenericLayer_1a93a0bcbe51c151be05d30d7c5ea537c2"></span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetFeaturesRead</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer15GetFeaturesReadEv" title="Link to this definition"></a><br /></dt>
<dd><p>GetFeaturesRead. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N15GNMGenericLayer38AttributeFilterEvaluationNeedsGeometryEv">
<span id="_CPPv3N15GNMGenericLayer38AttributeFilterEvaluationNeedsGeometryEv"></span><span id="_CPPv2N15GNMGenericLayer38AttributeFilterEvaluationNeedsGeometryEv"></span><span id="GNMGenericLayer::AttributeFilterEvaluationNeedsGeometry"></span><span class="target" id="classGNMGenericLayer_1ac103415659cd503be92436420fedb0a9"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">AttributeFilterEvaluationNeedsGeometry</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N15GNMGenericLayer38AttributeFilterEvaluationNeedsGeometryEv" title="Link to this definition"></a><br /></dt>
<dd><p>AttributeFilterEvaluationNeedsGeometry. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv47GNMRule">
<span id="_CPPv37GNMRule"></span><span id="_CPPv27GNMRule"></span><span id="GNMRule"></span><span class="target" id="classGNMRule"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMRule</span></span></span><a class="headerlink" href="#_CPPv47GNMRule" title="Link to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;gnm.h&gt;</em></div>
<p>The simple class for rules. </p>
<p>By now we have only connect rules, so the one class is enough. Maybe in future the set of classes for different rule types will be needed.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRule7GNMRuleEv">
<span id="_CPPv3N7GNMRule7GNMRuleEv"></span><span id="_CPPv2N7GNMRule7GNMRuleEv"></span><span id="GNMRule::GNMRule"></span><span class="target" id="classGNMRule_1a05d64336bd3a441964215bb858266b73"></span><span class="sig-name descname"><span class="n"><span class="pre">GNMRule</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7GNMRule7GNMRuleEv" title="Link to this definition"></a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRule7GNMRuleERKNSt6stringE">
<span id="_CPPv3N7GNMRule7GNMRuleERKNSt6stringE"></span><span id="_CPPv2N7GNMRule7GNMRuleERKNSt6stringE"></span><span id="GNMRule::GNMRule__ssCR"></span><span class="target" id="classGNMRule_1aace0798a9bbbc28b65a38289135f6914"></span><span class="k"><span class="pre">explicit</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMRule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">string</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">oRule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7GNMRule7GNMRuleERKNSt6stringE" title="Link to this definition"></a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRule7GNMRuleEPKc">
<span id="_CPPv3N7GNMRule7GNMRuleEPKc"></span><span id="_CPPv2N7GNMRule7GNMRuleEPKc"></span><span id="GNMRule::GNMRule__cCP"></span><span class="target" id="classGNMRule_1a4ae042f43da44cd78e96513fdc4eaad5"></span><span class="k"><span class="pre">explicit</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GNMRule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszRule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7GNMRule7GNMRuleEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRule7GNMRuleERK7GNMRule">
<span id="_CPPv3N7GNMRule7GNMRuleERK7GNMRule"></span><span id="_CPPv2N7GNMRule7GNMRuleERK7GNMRule"></span><span id="GNMRule::GNMRule__GNMRuleCR"></span><span class="target" id="classGNMRule_1a5ba5041311461ab6419acbd6e9349581"></span><span class="sig-name descname"><span class="n"><span class="pre">GNMRule</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4N7GNMRule7GNMRuleERK7GNMRule" title="GNMRule::GNMRule"><span class="n"><span class="pre">GNMRule</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">oRule</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7GNMRule7GNMRuleERK7GNMRule" title="Link to this definition"></a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRuleaSERK7GNMRule">
<span id="_CPPv3N7GNMRuleaSERK7GNMRule"></span><span id="_CPPv2N7GNMRuleaSERK7GNMRule"></span><span id="GNMRule::assign-operator__GNMRuleCR"></span><span class="target" id="classGNMRule_1af15d586a23249c60df499336e23b8595"></span><a class="reference internal" href="#_CPPv47GNMRule" title="GNMRule"><span class="n"><span class="pre">GNMRule</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="sig-name descname"><span class="k"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv47GNMRule" title="GNMRule"><span class="n"><span class="pre">GNMRule</span></span></a><span class="p"><span class="pre">&amp;</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">default</span></span><a class="headerlink" href="#_CPPv4N7GNMRuleaSERK7GNMRule" title="Link to this definition"></a><br /></dt>
<dd><p>Assignment operator. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRuleD0Ev">
<span id="_CPPv3N7GNMRuleD0Ev"></span><span id="_CPPv2N7GNMRuleD0Ev"></span><span id="GNMRule::~GNMRule"></span><span class="target" id="classGNMRule_1ae76564ac3378ce7d94251ea542fe7fbc"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">~GNMRule</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7GNMRuleD0Ev" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule7IsValidEv">
<span id="_CPPv3NK7GNMRule7IsValidEv"></span><span id="_CPPv2NK7GNMRule7IsValidEv"></span><span id="GNMRule::IsValidC"></span><span class="target" id="classGNMRule_1ac011ee7ce15c0e509cfbc84441a35052"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IsValid</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule7IsValidEv" title="Link to this definition"></a><br /></dt>
<dd><p>This function indicate if rule string was parsed successfully. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if rule is valid </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule11IsAcceptAnyEv">
<span id="_CPPv3NK7GNMRule11IsAcceptAnyEv"></span><span id="_CPPv2NK7GNMRule11IsAcceptAnyEv"></span><span id="GNMRule::IsAcceptAnyC"></span><span class="target" id="classGNMRule_1a200ea1d487e46971c278b1a5cd73bc13"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IsAcceptAny</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule11IsAcceptAnyEv" title="Link to this definition"></a><br /></dt>
<dd><p>Indicator of any layer state. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if accept any layer </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule7GetTypeEv">
<span id="_CPPv3NK7GNMRule7GetTypeEv"></span><span id="_CPPv2NK7GNMRule7GetTypeEv"></span><span id="GNMRule::GetTypeC"></span><span class="target" id="classGNMRule_1afc0bbfbfd43ab38d7ec7cd4f69057d8c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv411GNMRuleType" title="GNMRuleType"><span class="n"><span class="pre">GNMRuleType</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetType</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule7GetTypeEv" title="Link to this definition"></a><br /></dt>
<dd><p>This is for future use to indicate the rule type/ Now return only GRTConnection type. </p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>the rule type </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRule10CanConnectERK9CPLStringRK9CPLStringRK9CPLString">
<span id="_CPPv3N7GNMRule10CanConnectERK9CPLStringRK9CPLStringRK9CPLString"></span><span id="_CPPv2N7GNMRule10CanConnectERK9CPLStringRK9CPLStringRK9CPLString"></span><span id="GNMRule::CanConnect__CPLStringCR.CPLStringCR.CPLStringCR"></span><span class="target" id="classGNMRule_1a2789e01ba67b7592133e9bed96280662"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CanConnect</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">soSrcLayerName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">soTgtLayerName</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">soConnLayerName</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="s"><span class="pre">&quot;&quot;</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N7GNMRule10CanConnectERK9CPLStringRK9CPLStringRK9CPLString" title="Link to this definition"></a><br /></dt>
<dd><p>Check if connection can take place. </p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>soSrcLayerName</strong> -- - the layer name </p></li>
<li><p><strong>soTgtLayerName</strong> -- - the layer name </p></li>
<li><p><strong>soConnLayerName</strong> -- - the layer name </p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>true if can connect features from soSrcLayerName and soTgtLayerName via soConnLayerName </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule18GetSourceLayerNameEv">
<span id="_CPPv3NK7GNMRule18GetSourceLayerNameEv"></span><span id="_CPPv2NK7GNMRule18GetSourceLayerNameEv"></span><span id="GNMRule::GetSourceLayerNameC"></span><span class="target" id="classGNMRule_1a9de4b03d07630074ac9177e6db246916"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetSourceLayerName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule18GetSourceLayerNameEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return source layer name. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule18GetTargetLayerNameEv">
<span id="_CPPv3NK7GNMRule18GetTargetLayerNameEv"></span><span id="_CPPv2NK7GNMRule18GetTargetLayerNameEv"></span><span id="GNMRule::GetTargetLayerNameC"></span><span class="target" id="classGNMRule_1a1680ce878d64f7aa7d17c737306e22be"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetTargetLayerName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule18GetTargetLayerNameEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return target layer name. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule21GetConnectorLayerNameEv">
<span id="_CPPv3NK7GNMRule21GetConnectorLayerNameEv"></span><span id="_CPPv2NK7GNMRule21GetConnectorLayerNameEv"></span><span id="GNMRule::GetConnectorLayerNameC"></span><span class="target" id="classGNMRule_1a72ba518fb829fe6b6959a3477dd966c2"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetConnectorLayerName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule21GetConnectorLayerNameEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return connector layer name. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRule5c_strEv">
<span id="_CPPv3NK7GNMRule5c_strEv"></span><span id="_CPPv2NK7GNMRule5c_strEv"></span><span id="GNMRule::c_strC"></span><span class="target" id="classGNMRule_1a7695181ad46bd262302cd630de0a5ab8"></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">c_str</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRule5c_strEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return rule as a string. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK7GNMRulecvPKcEv">
<span id="_CPPv3NK7GNMRulecvPKcEv"></span><span id="_CPPv2NK7GNMRulecvPKcEv"></span><span id="GNMRule::castto-cCP-operator__voidC"></span><span class="target" id="classGNMRule_1a9d8a1d445256ce5c88bf435274878dfa"></span><span class="sig-name descname"><span class="k"><span class="pre">operator</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">*</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK7GNMRulecvPKcEv" title="Link to this definition"></a><br /></dt>
<dd><p>Return rule as a string. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-private-functions">Private Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N7GNMRuleeqERR7GNMRule">
<span id="_CPPv3N7GNMRuleeqERR7GNMRule"></span><span id="_CPPv2N7GNMRuleeqERR7GNMRule"></span><span id="GNMRule::eq-operator__GNMRuleRR"></span><span class="target" id="classGNMRule_1abb510b07f1c9a5b8a8a52f813beb77aa"></span><a class="reference internal" href="#_CPPv47GNMRule" title="GNMRule"><span class="n"><span class="pre">GNMRule</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="sig-name descname"><span class="k"><span class="pre">operator</span></span><span class="o"><span class="pre">==</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv47GNMRule" title="GNMRule"><span class="n"><span class="pre">GNMRule</span></span></a><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">delete</span></span><a class="headerlink" href="#_CPPv4N7GNMRuleeqERR7GNMRule" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv424OGRGNMWrappedResultLayer">
<span id="_CPPv324OGRGNMWrappedResultLayer"></span><span id="_CPPv224OGRGNMWrappedResultLayer"></span><span id="OGRGNMWrappedResultLayer"></span><span class="target" id="classOGRGNMWrappedResultLayer"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">OGRGNMWrappedResultLayer</span></span></span><span class="w"> </span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="k"><span class="pre">public</span></span><span class="w"> </span><a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><a class="headerlink" href="#_CPPv424OGRGNMWrappedResultLayer" title="Link to this definition"></a><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;gnm.h&gt;</em></div>
<p>The <a class="reference internal" href="#classOGRGNMWrappedResultLayer"><span class="std std-ref">OGRGNMWrappedResultLayer</span></a> class for search paths queries results. </p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.1 </p>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-functions">Public Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer24OGRGNMWrappedResultLayerEP11GDALDatasetP8OGRLayer">
<span id="_CPPv3N24OGRGNMWrappedResultLayer24OGRGNMWrappedResultLayerEP11GDALDatasetP8OGRLayer"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer24OGRGNMWrappedResultLayerEP11GDALDatasetP8OGRLayer"></span><span id="OGRGNMWrappedResultLayer::OGRGNMWrappedResultLayer__GDALDatasetP.OGRLayerP"></span><span class="target" id="classOGRGNMWrappedResultLayer_1afa0a9094bad6e17f21659a4697ad5c26"></span><span class="sig-name descname"><span class="n"><span class="pre">OGRGNMWrappedResultLayer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="gdaldataset_cpp.html#_CPPv411GDALDataset" title="GDALDataset"><span class="n"><span class="pre">GDALDataset</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poDS</span></span>, <a class="reference internal" href="ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><span class="n"><span class="pre">OGRLayer</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poLayer</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer24OGRGNMWrappedResultLayerEP11GDALDatasetP8OGRLayer" title="Link to this definition"></a><br /></dt>
<dd><p>Constructor. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayerD0Ev">
<span id="_CPPv3N24OGRGNMWrappedResultLayerD0Ev"></span><span id="_CPPv2N24OGRGNMWrappedResultLayerD0Ev"></span><span id="OGRGNMWrappedResultLayer::~OGRGNMWrappedResultLayer"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a24dab0b04997624162c7873676f53974"></span><span class="sig-name descname"><span class="n"><span class="pre">~OGRGNMWrappedResultLayer</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayerD0Ev" title="Link to this definition"></a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer12ResetReadingEv">
<span id="_CPPv3N24OGRGNMWrappedResultLayer12ResetReadingEv"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer12ResetReadingEv"></span><span id="OGRGNMWrappedResultLayer::ResetReading"></span><span class="target" id="classOGRGNMWrappedResultLayer_1af7dde6c09cc4e2c51643433490f75958"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ResetReading</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer12ResetReadingEv" title="Link to this definition"></a><br /></dt>
<dd><p>Reset feature reading to start on the first feature. </p>
<p>This affects <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> and <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a3ffa8511632cbb7cff06a908e6668f55"><span class="std std-ref">GetArrowStream()</span></a>.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ab0383004bf637171648a9d03a80f15a4"><span class="std std-ref">OGR_L_ResetReading()</span></a>. </p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer14GetNextFeatureEv">
<span id="_CPPv3N24OGRGNMWrappedResultLayer14GetNextFeatureEv"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer14GetNextFeatureEv"></span><span id="OGRGNMWrappedResultLayer::GetNextFeature"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetNextFeature</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer14GetNextFeatureEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2602d11f21567119da0ca6b6c5ad45"><span class="std std-ref">OGRFeature::DestroyFeature()</span></a>. It is critical that all features associated with an <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> (more specifically an <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0b4ab45cf97cbc470f0d60474d3e4169"><span class="std std-ref">SetSpatialFilter()</span></a>) will be returned.</p>
<p>This method implements sequential access to the features of a layer. The <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1af7dde6c09cc4e2c51643433490f75958"><span class="std std-ref">ResetReading()</span></a> method can be used to start at the beginning again.</p>
<p>Starting with GDAL 3.6, it is possible to retrieve them by batches, with a column-oriented memory layout, using the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a3ffa8511632cbb7cff06a908e6668f55"><span class="std std-ref">GetArrowStream()</span></a> method.</p>
<p>Features returned by <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1af7dde6c09cc4e2c51643433490f75958"><span class="std std-ref">ResetReading()</span></a> on layers where <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1af7dde6c09cc4e2c51643433490f75958"><span class="std std-ref">ResetReading()</span></a> might be needed.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a6708c067521ab7b7f9c4ec0ebe221b5b"><span class="std std-ref">OGR_L_GetNextFeature()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>a feature, or NULL if no more features are available. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer14SetNextByIndexE7GIntBig">
<span id="_CPPv3N24OGRGNMWrappedResultLayer14SetNextByIndexE7GIntBig"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer14SetNextByIndexE7GIntBig"></span><span id="OGRGNMWrappedResultLayer::SetNextByIndex__GIntBig"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a1497ecb886f6cf53978d0897729ddf89"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SetNextByIndex</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nIndex</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer14SetNextByIndexE7GIntBig" title="Link to this definition"></a><br /></dt>
<dd><p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a1497ecb886f6cf53978d0897729ddf89"><span class="std std-ref">SetNextByIndex()</span></a> efficiently implemented. In all other cases the default implementation which calls <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1af7dde6c09cc4e2c51643433490f75958"><span class="std std-ref">ResetReading()</span></a> and then calls <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> nIndex times is used. To determine if fast seeking is available on the current layer use the <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1af24de6270f5b356e908d66f24cd097da"><span class="std std-ref">TestCapability()</span></a> method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a8b4427a82ea3de3bed7acff19b6e8e33"><span class="std std-ref">OGR_L_SetNextByIndex()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nIndex</strong> -- the index indicating how many steps into the result set to seek.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success or an error code. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer10GetFeatureE7GIntBig">
<span id="_CPPv3N24OGRGNMWrappedResultLayer10GetFeatureE7GIntBig"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer10GetFeatureE7GIntBig"></span><span id="OGRGNMWrappedResultLayer::GetFeature__GIntBig"></span><span class="target" id="classOGRGNMWrappedResultLayer_1ab321145e72ce0529719a8100d677efb0"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetFeature</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nFID</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer10GetFeatureE7GIntBig" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this method returns a non-NULL feature, it is guaranteed that its feature id (<a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1ae7254201e4d96e8429c2509194740d58"><span class="std std-ref">OGRFeature::GetFID()</span></a>) will be the same as nFID.</p>
<p>Use OGRLayer::TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1ab321145e72ce0529719a8100d677efb0"><span class="std std-ref">GetFeature()</span></a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a>) are generally considered interrupted by a <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1ab321145e72ce0529719a8100d677efb0"><span class="std std-ref">GetFeature()</span></a> call.</p>
<p>The returned feature should be free with <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature_1a5d2602d11f21567119da0ca6b6c5ad45"><span class="std std-ref">OGRFeature::DestroyFeature()</span></a>.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a29d378c5092db944966398de8d1ac964"><span class="std std-ref">OGR_L_GetFeature()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nFID</strong> -- the feature id of the feature to read.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>a feature now owned by the caller, or NULL on failure. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer12GetLayerDefnEv">
<span id="_CPPv3N24OGRGNMWrappedResultLayer12GetLayerDefnEv"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer12GetLayerDefnEv"></span><span id="OGRGNMWrappedResultLayer::GetLayerDefn"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a2b03e32b64d5dc5c8be95c815bc59c6a"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv414OGRFeatureDefn" title="OGRFeatureDefn"><span class="n"><span class="pre">OGRFeatureDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetLayerDefn</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer12GetLayerDefnEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the schema information for this layer. </p>
<p>The returned <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> is owned by the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a7b67ea4ab5892c6720460dc7f66eca2d"><span class="std std-ref">OGR_L_GetLayerDefn()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>feature definition. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer15GetFeatureCountEi">
<span id="_CPPv3N24OGRGNMWrappedResultLayer15GetFeatureCountEi"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer15GetFeatureCountEi"></span><span id="OGRGNMWrappedResultLayer::GetFeatureCount__i"></span><span class="target" id="classOGRGNMWrappedResultLayer_1acba3d4400f7b1c45a4ea3fe70019a196"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv47GIntBig" title="GIntBig"><span class="n"><span class="pre">GIntBig</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">GetFeatureCount</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bForce</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer15GetFeatureCountEi" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a08524b6961e52e1561308d2b0c598fb2"><span class="std std-ref">OGR_L_GetFeatureCount()</span></a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bForce</strong> -- Flag indicating whether the count should be computed even if it is expensive.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>feature count, -1 if count not known. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer14TestCapabilityEPKc">
<span id="_CPPv3N24OGRGNMWrappedResultLayer14TestCapabilityEPKc"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer14TestCapabilityEPKc"></span><span id="OGRGNMWrappedResultLayer::TestCapability__cCP"></span><span class="target" id="classOGRGNMWrappedResultLayer_1af24de6270f5b356e908d66f24cd097da"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">TestCapability</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">pszCap</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer14TestCapabilityEPKc" title="Link to this definition"></a><br /></dt>
<dd><p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<p><ul>
<li><p><strong>OLCRandomRead</strong> / &quot;RandomRead&quot;: TRUE if the <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1ab321145e72ce0529719a8100d677efb0"><span class="std std-ref">GetFeature()</span></a> method is implemented in an optimized way for this layer, as opposed to the default implementation using <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1af7dde6c09cc4e2c51643433490f75958"><span class="std std-ref">ResetReading()</span></a> and <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a702689eaf04e4d3379a301bd582eb82d"><span class="std std-ref">GetNextFeature()</span></a> to find the requested feature id.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCSequentialWrite</strong> / &quot;SequentialWrite&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaa1e32016f481596a55e1d988a15a067"><span class="std std-ref">CreateFeature()</span></a> method works for this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCRandomWrite</strong> / &quot;RandomWrite&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a681139bfd585b74d7218e51a32144283"><span class="std std-ref">SetFeature()</span></a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCUpsertFeature</strong> / &quot;UpsertFeature&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a0fde458509b0cccc23d2ce89c1fd9dfb"><span class="std std-ref">UpsertFeature()</span></a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastSpatialFilter</strong> / &quot;FastSpatialFilter&quot;: TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastFeatureCount</strong> / &quot;FastFeatureCount&quot;: TRUE if this layer can return a feature count (via <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1acba3d4400f7b1c45a4ea3fe70019a196"><span class="std std-ref">GetFeatureCount()</span></a>) efficiently. i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastGetExtent</strong> / &quot;FastGetExtent&quot;: TRUE if this layer can return its data extent (via <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a3be658ddb5b33d1ed95c31286774bbd2"><span class="std std-ref">GetExtent()</span></a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCFastSetNextByIndex</strong> / &quot;FastSetNextByIndex&quot;: TRUE if this layer can perform the <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a1497ecb886f6cf53978d0897729ddf89"><span class="std std-ref">SetNextByIndex()</span></a> call efficiently, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCreateField</strong> / &quot;CreateField&quot;: TRUE if this layer can create new fields on the current layer using <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a6c0dafbcce326f964adf0a9179066a9c"><span class="std std-ref">CreateField()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCCreateGeomField</strong> / &quot;CreateGeomField&quot;: (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a50f4f641ebb4a22134ddd66a59125316"><span class="std std-ref">CreateGeomField()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCDeleteField</strong> / &quot;DeleteField&quot;: TRUE if this layer can delete existing fields on the current layer using <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaebe7c671dca995549543eecf0f7a76a"><span class="std std-ref">DeleteField()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCReorderFields</strong> / &quot;ReorderFields&quot;: TRUE if this layer can reorder existing fields on the current layer using <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ab4c02b991bfa78552eeb0cbcdcf1aed8"><span class="std std-ref">ReorderField()</span></a> or <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aebd364a150d91f8d65d967646e0f92d3"><span class="std std-ref">ReorderFields()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCAlterFieldDefn</strong> / &quot;AlterFieldDefn&quot;: TRUE if this layer can alter the definition of an existing field on the current layer using <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1af52f539d34466c10b7c031a8270544b4"><span class="std std-ref">AlterFieldDefn()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCAlterGeomFieldDefn</strong> / &quot;AlterGeomFieldDefn&quot;: TRUE if this layer can alter the definition of an existing geometry field on the current layer using <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a49a87755bff79d25c5774280023dda0b"><span class="std std-ref">AlterGeomFieldDefn()</span></a>, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCDeleteFeature</strong> / &quot;DeleteFeature&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a2342e79e0248076c2205047e1928f296"><span class="std std-ref">DeleteFeature()</span></a> method is supported on this layer, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCStringsAsUTF8</strong> / &quot;StringsAsUTF8&quot;: TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCTransactions</strong> / &quot;Transactions&quot;: TRUE if the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a2855f6fae6f97fa1cebcc2f57a0f974f"><span class="std std-ref">StartTransaction()</span></a>, <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a6cafa399e8f3027158787c87c3d1b97e"><span class="std std-ref">CommitTransaction()</span></a> and <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1ab046dbffc4fbd5bacc6ef75da0686d82"><span class="std std-ref">RollbackTransaction()</span></a> methods work in a meaningful way, otherwise FALSE.</p>
<p></p>
<p></p>
</li>
<li><p><strong>OLCIgnoreFields</strong> / &quot;IgnoreFields&quot;: TRUE if fields, geometry and style will be omitted when fetching features as set by <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaf3f2e7ee476337082cea814226be11a"><span class="std std-ref">SetIgnoredFields()</span></a> method.</p>
<p></p>
</li>
<li><p><strong>OLCCurveGeometries</strong> / &quot;CurveGeometries&quot;: TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p></p>
<p></p>
<p></p>
</li>
</ul>
</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a480adc8b839b04597f49583371d366fd"><span class="std std-ref">OGR_L_TestCapability()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pszCap</strong> -- the name of the capability to test.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer11CreateFieldEPK12OGRFieldDefni">
<span id="_CPPv3N24OGRGNMWrappedResultLayer11CreateFieldEPK12OGRFieldDefni"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer11CreateFieldEPK12OGRFieldDefni"></span><span id="OGRGNMWrappedResultLayer::CreateField__OGRFieldDefnCP.i"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a6c0dafbcce326f964adf0a9179066a9c"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CreateField</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv412OGRFieldDefn" title="OGRFieldDefn"><span class="n"><span class="pre">OGRFieldDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poField</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bApproxOK</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer11CreateFieldEPK12OGRFieldDefni" title="Link to this definition"></a><br /></dt>
<dd><p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1aab585ef1166c61c4819f7fd46ee4a275"><span class="std std-ref">OGR_L_CreateField()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poField</strong> -- field definition to write to disk. </p></li>
<li><p><strong>bApproxOK</strong> -- If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer15CreateGeomFieldEPK16OGRGeomFieldDefni">
<span id="_CPPv3N24OGRGNMWrappedResultLayer15CreateGeomFieldEPK16OGRGeomFieldDefni"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer15CreateGeomFieldEPK16OGRGeomFieldDefni"></span><span id="OGRGNMWrappedResultLayer::CreateGeomField__OGRGeomFieldDefnCP.i"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a50f4f641ebb4a22134ddd66a59125316"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CreateGeomField</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv416OGRGeomFieldDefn" title="OGRGeomFieldDefn"><span class="n"><span class="pre">OGRGeomFieldDefn</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poField</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bApproxOK</span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">TRUE</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer15CreateGeomFieldEPK16OGRGeomFieldDefni" title="Link to this definition"></a><br /></dt>
<dd><p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeatureDefn"><span class="std std-ref">OGRFeatureDefn</span></a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateGeomField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1af6908931c4f3ad364fef8d6e831363bc"><span class="std std-ref">OGR_L_CreateGeomField()</span></a>.</p>
<p><dl class="simple">
<dt><strong>Since</strong></dt><dd><p>OGR 1.11 </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poField</strong> -- geometry field definition to write to disk. </p></li>
<li><p><strong>bApproxOK</strong> -- If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</p></li>
</ul>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success.</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer12GetFIDColumnEv">
<span id="_CPPv3N24OGRGNMWrappedResultLayer12GetFIDColumnEv"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer12GetFIDColumnEv"></span><span id="OGRGNMWrappedResultLayer::GetFIDColumn"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a8b6ed9ccfbb3ca2e74cf1e53e539c71e"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetFIDColumn</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer12GetFIDColumnEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method returns the name of the underlying database column being used as the FID column, or &quot;&quot; if not supported. </p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1abfeb6e1258f113c6c45c8d6a43c8cfa5"><span class="std std-ref">OGR_L_GetFIDColumn()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>fid column name. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer17GetGeometryColumnEv">
<span id="_CPPv3N24OGRGNMWrappedResultLayer17GetGeometryColumnEv"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer17GetGeometryColumnEv"></span><span id="OGRGNMWrappedResultLayer::GetGeometryColumn"></span><span class="target" id="classOGRGNMWrappedResultLayer_1ae1481f5db82eff33e5c2125ff050b065"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetGeometryColumn</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer17GetGeometryColumnEv" title="Link to this definition"></a><br /></dt>
<dd><p>This method returns the name of the underlying database column being used as the geometry column, or &quot;&quot; if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the name of the first geometry column. For other columns, use <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a2b03e32b64d5dc5c8be95c815bc59c6a"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetNameRef().</p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1ab060e07e277cebd1d8504c449d97b29f"><span class="std std-ref">OGR_L_GetGeometryColumn()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>geometry column name. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer13GetSpatialRefEv">
<span id="_CPPv3N24OGRGNMWrappedResultLayer13GetSpatialRefEv"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer13GetSpatialRefEv"></span><span id="OGRGNMWrappedResultLayer::GetSpatialRef"></span><span class="target" id="classOGRGNMWrappedResultLayer_1ad2c9ddba61367ddc95a28942378d101f"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="ogrspatialref.html#_CPPv419OGRSpatialReference" title="OGRSpatialReference"><span class="n"><span class="pre">OGRSpatialReference</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">GetSpatialRef</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer13GetSpatialRefEv" title="Link to this definition"></a><br /></dt>
<dd><p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer"><span class="std std-ref">OGRLayer</span></a> and should not be modified or freed by the application.</p>
<p>Starting with OGR 1.11, several geometry fields can be associated to a feature definition. Each geometry field can have its own spatial reference system, which is returned by <a class="reference internal" href="ogrfeature_cpp.html#classOGRGeomFieldDefn_1acdc7b11a77a8e3f838a2b33965e2971f"><span class="std std-ref">OGRGeomFieldDefn::GetSpatialRef()</span></a>. <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a75c06b4993f8eb76b569f37365cd19ab"><span class="std std-ref">OGRLayer::GetSpatialRef()</span></a> is equivalent to <a class="reference internal" href="#classOGRGNMWrappedResultLayer_1a2b03e32b64d5dc5c8be95c815bc59c6a"><span class="std std-ref">GetLayerDefn()</span></a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(0)-&gt;<a class="reference internal" href="#classOGRGNMWrappedResultLayer_1ad2c9ddba61367ddc95a28942378d101f"><span class="std std-ref">GetSpatialRef()</span></a></p>
<p>This method is the same as the C function <a class="reference internal" href="vector_c_api.html#ogr__api_8h_1a8b2a10085f410aa84172eba413408c39"><span class="std std-ref">OGR_L_GetSpatialRef()</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">戻り値<span class="colon">:</span></dt>
<dd class="field-odd"><p>spatial reference, or NULL if there isn't one. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer13InsertFeatureEP10OGRFeatureRK9CPLStringib">
<span id="_CPPv3N24OGRGNMWrappedResultLayer13InsertFeatureEP10OGRFeatureRK9CPLStringib"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer13InsertFeatureEP10OGRFeatureRK9CPLStringib"></span><span id="OGRGNMWrappedResultLayer::InsertFeature__OGRFeatureP.CPLStringCR.i.b"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a0cace10506dd7eb49d5932877bfadebf"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InsertFeature</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poFeature</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="cpl.html#_CPPv49CPLString" title="CPLString"><span class="n"><span class="pre">CPLString</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">soLayerName</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">nPathNo</span></span>, <span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">bIsEdge</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer13InsertFeatureEP10OGRFeatureRK9CPLStringib" title="Link to this definition"></a><br /></dt>
<dd><p>Undocumented. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-protected-functions">Protected Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer11ISetFeatureEP10OGRFeature">
<span id="_CPPv3N24OGRGNMWrappedResultLayer11ISetFeatureEP10OGRFeature"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer11ISetFeatureEP10OGRFeature"></span><span id="OGRGNMWrappedResultLayer::ISetFeature__OGRFeatureP"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a1ee20a5cab1d1a35e5a3a19a5f8e15f3"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ISetFeature</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poFeature</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer11ISetFeatureEP10OGRFeature" title="Link to this definition"></a><br /></dt>
<dd><p>Rewrite/replace an existing feature. </p>
<p>This method is implemented by drivers and not called directly. User code should use <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a681139bfd585b74d7218e51a32144283"><span class="std std-ref">SetFeature()</span></a> instead.</p>
<p>This method will write a feature to the layer, based on the feature id within the <a class="reference internal" href="ogrfeature_cpp.html#classOGRFeature"><span class="std std-ref">OGRFeature</span></a>.</p>
<p><div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1a681139bfd585b74d7218e51a32144283"><span class="std std-ref">SetFeature()</span></a></p>
</div>
<dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poFeature</strong> -- the feature to write.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N24OGRGNMWrappedResultLayer14ICreateFeatureEP10OGRFeature">
<span id="_CPPv3N24OGRGNMWrappedResultLayer14ICreateFeatureEP10OGRFeature"></span><span id="_CPPv2N24OGRGNMWrappedResultLayer14ICreateFeatureEP10OGRFeature"></span><span id="OGRGNMWrappedResultLayer::ICreateFeature__OGRFeatureP"></span><span class="target" id="classOGRGNMWrappedResultLayer_1a17144c16c9b1d4d4bd82dbfc111dc363"></span><span class="k"><span class="pre">virtual</span></span><span class="w"> </span><a class="reference internal" href="vector_c_api.html#_CPPv46OGRErr" title="OGRErr"><span class="n"><span class="pre">OGRErr</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ICreateFeature</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="ogrfeature_cpp.html#_CPPv410OGRFeature" title="OGRFeature"><span class="n"><span class="pre">OGRFeature</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">poFeature</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">override</span></span><a class="headerlink" href="#_CPPv4N24OGRGNMWrappedResultLayer14ICreateFeatureEP10OGRFeature" title="Link to this definition"></a><br /></dt>
<dd><p>Create and write a new feature within a layer. </p>
<p>This method is implemented by drivers and not called directly. User code should use <a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaa1e32016f481596a55e1d988a15a067"><span class="std std-ref">CreateFeature()</span></a> instead.</p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p><div class="admonition seealso">
<p class="admonition-title">参考</p>
<p><a class="reference internal" href="ogrlayer_cpp.html#classOGRLayer_1aaa1e32016f481596a55e1d988a15a067"><span class="std std-ref">CreateFeature()</span></a></p>
</div>
<dl class="simple">
<dt><strong>Since</strong></dt><dd><p>GDAL 2.0</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">パラメータ<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poFeature</strong> -- the feature to write to disk.</p>
</dd>
<dt class="field-even">戻り値<span class="colon">:</span></dt>
<dd class="field-even"><p>OGRERR_NONE on success. </p>
</dd>
</dl>
</dd></dl>

</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="python_bindings.html" class="btn btn-neutral float-right" title="General information" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cpl_cpp.html" class="btn btn-neutral float-left" title="Common Portability Library C++ API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2024 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
  </div>
</footer>
        </div>
      </div>
    </section>
  </div>
  
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>