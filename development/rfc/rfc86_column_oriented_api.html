<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RFC 86: Column-oriented read API for vector layers &mdash; GDAL  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d10597a4" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/gdal.css?v=e152ac3b" />

  
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
    <link rel="canonical" href="https://gdal.org/development/rfc/rfc86_column_oriented_api.html"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=c033477b"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/translations.js?v=4dbe4bdc"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="このドキュメントについて" href="../../about.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="検索" href="../../search.html" />
    <link rel="next" title="RFC 87: Signed int8 data type for raster" href="rfc87_signed_int8.html" />
    <link rel="prev" title="RFC 85: Policy regarding substantial code additions" href="rfc85_policy_code_additions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/gdalicon.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../download.html">ダウンロード</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../programs/index.html">プログラム</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers/raster/index.html">ラスタードライバー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drivers/vector/index.html">ベクタードライバー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">ユーザー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">チュートリアル</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">開発</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../building_from_source.html">Building GDAL from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dev_environment.html">Setting up a development environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dev_practices.html">Development practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing.html">Automated testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dev_documentation.html">Building documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cmake.html">Using GDAL in CMake projects</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">RFC list</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="rfc1_pmc.html">RFC 1: Project Management Committee Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc2_svn.html">RFC 2: Migration to OSGeo Subversion Repository</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc3_commiters.html">RFC 3: GDAL Committer Guildlines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc4_geolocate.html">RFC 4: Geolocation Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc5_unicode.html">RFC 5: Unicode support in GDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc6_sqlgeom.html">RFC 6: Geometry and Feature Style as OGR Special Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc7_vsilapi.html">RFC 7: Use VSILFILE for VSI*L Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc8_devguide.html">RFC 8: Developer Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc9_maintainer.html">RFC 9: GDAL Paid Maintainer Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc10_ogropen.html">RFC 10: OGR Open Parameters (not implemented)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc11_fastidentify.html">RFC 11: Fast Format Identification</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc12_filemanagement.html">RFC 12: Improved File Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc13_createfeatures.html">RFC 13: Improved Feature Insertion/Update/Delete Performance in Batch Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc14_imagestructure.html">RFC 14: Image Structure Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc15_nodatabitmask.html">RFC 15: Band Masks</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc16_ogr_reentrancy.html">RFC 16: OGR Thread Safety</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc17_python_namespaces.html">RFC 17: Python Namespaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc18_ogr_styles_c_api.html">RFC 18: OGR Style Support in C API</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc19_safememalloc.html">RFC 19: Safer memory allocation in GDAL</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc20_srs_axes.html">RFC 20: OGRSpatialReference Axis Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc21_ogrsqlcast.html">RFC 21: OGR SQL type cast and field name alias</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc22_rpc.html">RFC 22: RPC Georeferencing</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc23_ogr_unicode.html">RFC 23.1: Unicode support in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc24_progressive_data_support.html">RFC 24: GDAL Progressive Data Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc25_fast_open.html">RFC 25: Fast Open (withdrawn)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc26_blockcache.html">RFC 26: GDAL Block Cache Improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc27_supportdata.html">RFC 27: Improved Supporting Data File Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc28_sqlfunc.html">RFC 28: OGR SQL Generalized Expressions</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc29_desired_fields.html">RFC 29: OGR Set Ignored Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc30_utf8_filenames.html">RFC 30: Unicode Filenames</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc31_ogr_64.html">RFC 31: OGR 64bit Integer Fields and FIDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc32_gdallocationinfo.html">RFC 32: gdallocationinfo utility</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc33_gtiff_pixelispoint.html">RFC 33: GTiff - Fixing PixelIsPoint Interpretation</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc34_license_policy.html">RFC 34: License Policy Enforcement</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc35_deletereorderalterfielddefn.html">RFC 35: Delete, reorder and alter field definitions of OGR layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc36_open_by_drivername.html">RFC 36: Allow specification of intended driver on GDALOpen (withdrawn)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc37_cplerror_userdata.html">RFC 37: User data callbacks in CPLError</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc38_ogr_faster_open.html">RFC 38: OGR Faster Open (withdrawn)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc39_ogr_layer_algebra.html">RFC 39: OGR Layer Algebra</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc40_enhanced_rat_support.html">RFC 40: Improving performance of Raster Attribute Table implementation for large tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc41_multiple_geometry_fields.html">RFC 41 : Support for multiple geometry fields in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc42_find_laundered_fields.html">RFC 42: OGR Layer laundered field lookup</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc43_getmetadatadomainlist.html">RFC 43: GDALMajorObject::GetMetadataDomainList</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc44_gdalinfoxml.html">RFC 44: Add Parseable Output Formats for ogrinfo and gdalinfo</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc45_virtualmem.html">RFC 45: GDAL datasets and raster bands as virtual memory mappings</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc46_gdal_ogr_unification.html">RFC 46: GDAL/OGR unification</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc47_dataset_caching.html">RFC 47: Per Dataset Caching and GDALRasterBand Multithreading (not implemented)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc48_geographical_networks_support.html">RFC 48: Geographical networks support</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc49_curve_geometries.html">RFC 49: Curve geometries</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc50_ogr_field_subtype.html">RFC 50: OGR field subtypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc51_rasterio_resampling_progress.html">RFC 51: RasterIO() improvements : resampling and progress callback</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc52_strict_sql_quoting.html">RFC 52: Strict OGR SQL quoting</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc53_ogr_notnull_default.html">RFC 53: OGR not-null constraints and default values</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc54_dataset_transactions.html">RFC 54: Dataset transactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc55_refined_setfeature_deletefeature_semantics.html">RFC 55: Refined SetFeature() and DeleteFeature() semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc56_millisecond_precision.html">RFC 56: OFTTime/OFTDateTime millisecond accuracy</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc57_histogram_64bit_count.html">RFC 57: 64-bit bucket counts for histograms</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc58_removing_dataset_nodata_value.html">RFC 58: Removing Dataset Nodata Value</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc59.1_utilities_as_a_library.html">RFC 59.1 : GDAL/OGR utilities as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc59_utilities_as_a_library.html">RFC 59 : GDAL/OGR utilities as a library</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc60_improved_roundtripping_in_ogr.html">RFC 60 : Improved round-tripping in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc61_support_for_measured_geometries.html">RFC 61 : Support for measured geometries</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc62_raster_algebra.html">RFC 62 : Raster algebra</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc63_sparse_datasets_improvements.html">RFC 63 : Sparse datasets improvements</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc64_triangle_polyhedralsurface_tin.html">RFC 64: Triangle, Polyhedral surface and TIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc65_rfc7946_geojson.html">RFC 65: RFC 7946 GeoJSON</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc66_randomlayerreadwrite.html">RFC 66 : OGR random layer read/write capabilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc67_nullfieldvalues.html">RFC 67 : Null values in OGR</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc68_cplusplus11.html">RFC 68: C++11 Compilation Mode</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc69_cplusplus_formatting.html">RFC 69: C/C++ Code Formatting</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc70_output_format_guess.html">RFC 70: Guessing output format from output file name extension for utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc71_github_migration.html">RFC 71: Migration to GitHub</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc72_pytest.html">RFC 72: Update autotest suite to use pytest</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc73_proj6_wkt2_srsbarn.html">RFC 73: Integration of PROJ6 for WKT2, late binding capabilities, time-support and unified CRS database</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc74_sphinx.html">RFC 74: Migrate gdal.org to RTD-style Sphinx infrastructure</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc75_multidimensional_arrays.html">RFC 75: Multidimensional arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc76_ogrpythondrivers.html">RFC 76: OGR Python drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc77_drop_python2_support.html">RFC 77: Drop Python 2 support in favour of Python 3.6</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc78_gdal_utils_package.html">RFC 78: gdal-utils package</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc79_listing_service_providers.html">RFC 79: Listing of Service Providers on GDAL website</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc80_numfocus_relationship.html">RFC 80: NumFOCUS relationship and sponsorship program</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc81_coordinate_epoch.html">RFC 81: Support for coordinate epochs in geospatial formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc83_use_of_project_sponsorship.html">RFC 83: guidelines for the use of GDAL project sponsorship</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc84_cmake.html">RFC 84: Migrating build systems to CMake</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc85_policy_code_additions.html">RFC 85: Policy regarding substantial code additions</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">RFC 86: Column-oriented read API for vector layers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#details">Details</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-remarks">Other remarks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#impacted-drivers">Impacted drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bindings">Bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#benchmarks">Benchmarks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backward-compatibility">Backward compatibility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#new-dependencies">New dependencies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#documentation">Documentation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing">Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#related-prs">Related PRs:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#annexes">Annexes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#voting-history">Voting history</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="rfc87_signed_int8.html">RFC 87: Signed int8 data type for raster</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc88_googletest.html">RFC 88: Use GoogleTest framework for C/C++ unit tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc89_sql_logging_callback.html">RFC 89: SQL logging callback</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc90_read_compressed_data.html">RFC 90: Direct access to compressed raster data</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc91_dataset_close.html">RFC 91: GDALDataset::Close() method</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc92_wkb_only_geometries.html">RFC 92: WKB Only geometries (on hold)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc93_update_feature.html">RFC 93: OGRLayer::UpdateFeature() method</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc94_field_precision_width_metadata.html">RFC 94: Numeric fields width/precision metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc95_standard_int_types.html">RFC 95: Use standard C/C++ integer types (proposed, <em>NOT</em> adopted)</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc96_deferred_plugin_loading.html">RFC 96: Deferred C++ plugin loading</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc97_feature_and_fielddefn_sealing.html">RFC 97: OGRFeatureDefn, OGRFieldDefn and OGRGeomFieldDefn &quot;sealing&quot;</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc98_build_requirements_gdal_3_9.html">RFC 98: Build requirements for GDAL 3.9</a></li>
<li class="toctree-l3"><a class="reference internal" href="rfc99_geometry_coordinate_precision.html">RFC 99: Geometry coordinate precision</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../community/index.html">コミュニティ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sponsors/index.html">スポンサー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">どのように貢献できますか?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">ライセンス</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GDAL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html"> GDAL  ドキュメント </a> &raquo;</li>
      
          <li><a href="../index.html">開発</a> &raquo;</li>
      
          <li><a href="index.html">RFC list</a> &raquo;</li>
      
      <li>RFC 86: Column-oriented read API for vector layers</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/edit/master/doc/source/development/rfc/rfc86_column_oriented_api.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="rfc87_signed_int8.html" class="btn btn-neutral float-right" title="RFC 87: Signed int8 data type for raster" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rfc85_policy_code_additions.html" class="btn btn-neutral float-left" title="RFC 85: Policy regarding substantial code additions" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="rfc-86-column-oriented-read-api-for-vector-layers">
<span id="rfc-86"></span><h1>RFC 86: Column-oriented read API for vector layers<a class="headerlink" href="#rfc-86-column-oriented-read-api-for-vector-layers" title="Link to this heading"></a></h1>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Author:</p></td>
<td><p>Even Rouault</p></td>
</tr>
<tr class="row-even"><td><p>Contact:</p></td>
<td><p>even.rouault &#64; spatialys.com</p></td>
</tr>
<tr class="row-odd"><td><p>Started:</p></td>
<td><p>2022-May-24</p></td>
</tr>
<tr class="row-even"><td><p>Updated:</p></td>
<td><p>2022-June-14</p></td>
</tr>
<tr class="row-odd"><td><p>Status:</p></td>
<td><p>Adopted</p></td>
</tr>
<tr class="row-even"><td><p>Target:</p></td>
<td><p>GDAL 3.6</p></td>
</tr>
</tbody>
</table>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Link to this heading"></a></h2>
<p>This RFC describes the addition of new methods to the <a class="reference internal" href="../../api/ogrlayer_cpp.html#_CPPv48OGRLayer" title="OGRLayer"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">OGRLayer</span></code></a> class to retrieve
batches of features with a column-oriented memory layout, that suits formats that
have that organization or downstream consumers that expect data to be presented
in such a way, in particular the <a class="reference external" href="https://arrow.apache.org/docs/">Apache Arrow</a>,
<a class="reference external" href="https://pandas.pydata.org/">Pandas</a> / <a class="reference external" href="https://geopandas.org/">GeoPandas</a>
ecosystem, R spatial packages, and many modern (data analytics focused)
databases / engines which are column oriented (eg Snowflake, Google BigQuery, ..)</p>
</section>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Link to this heading"></a></h2>
<p>Currently, to retrieve feature information, users must iterate over each feature
of a layer with GetNextFeature(), which returns a C++ object, on which query
attributes and geometries are retrieved with various &quot;get&quot; methods. When invoked
from binding languages, a overhead typically occurs each time the other language
calls native code. So to retrieve all information on a layer made of N_features
and N_fields, you need of the order of N_features * N_fields calls.
That overhead is significant. See below <a class="reference internal" href="#rfc-86-benchmarks"><span class="std std-ref">Benchmarks</span></a>.</p>
<p>Another inconvenience of the C API is that processings that involve many rows
of a same field (e.g computing statistics on a field) may require data to be
contiguously placed in RAM, for the most efficient processing (use of vectorized
CPU instruction). The current OGR API does not allow that directly, and require
the users to shuffle itself data into appropriate data structures.
Similarly the above mentioned frameworks (Arrow, Pandas/GeoPandas) require
such memory layouts, and currently require reorganizing data when reading from OGR.
The <a class="reference external" href="https://github.com/geopandas/pyogrio">pyogrio</a> project is for example
an attempt at addressing that need.</p>
<p>Furthermore, the <a class="reference internal" href="../../drivers/vector/arrow.html#vector-arrow"><span class="std std-ref">(Geo)Arrow IPC File Format / Stream</span></a> and <a class="reference internal" href="../../drivers/vector/parquet.html#vector-parquet"><span class="std std-ref">(Geo)Parquet</span></a> drivers,
whose file organization is columnar, and batch oriented, have been added in GDAL 3.5.0.
Consequently a columnar-oriented API will enable the best performance
for those formats.</p>
</section>
<section id="details">
<h2>Details<a class="headerlink" href="#details" title="Link to this heading"></a></h2>
<p>The new proposed API implements the
<a class="reference external" href="https://arrow.apache.org/docs/format/CStreamInterface.html">Apache Arrow C Stream interface</a>.
Reading that document, as well of the first paragraphs of the
<a class="reference external" href="https://arrow.apache.org/docs/format/CDataInterface.html">Apache Arrow C data interface</a>.
(details on the various data types can be skipped) is strongly encouraged for a
better understanding of the rest of this RFC.</p>
<p>The Arrow C Stream interface is currently marked as experimental, but it has not
evolved since its introduction in Nov 2020 and is already used in ABI sensitive
places like the interface between the Arrow R bindings and DuckDB.</p>
<p>This interface consists of a set of C structures, ArrowArrayStream, that provides
two main callbacks to get:</p>
<ul class="simple">
<li><p>a ArrowSchema with the get_schema() callback. A ArrowSchema describes a set of
field descriptions (name, type, metadata). All OGR data types have a corresponding
Arrow data type.</p></li>
<li><p>a sequence of ArrowArray with the get_next() callback. A ArrowArray captures
a set of values for a specific column/field in a subset of features.
This is the equivalent of a
<a class="reference external" href="https://arrow.apache.org/docs/python/pandas.html#series">Series</a> in a Pandas DataFrame.
This is a potentially hiearchical structure that can aggregate
sub arrays, and in OGR usage, the main array will be a StructArray which is
the collection of OGR attribute and geometry fields.
The layout of buffers and children arrays per data type is detailed in the
<a class="reference external" href="https://arrow.apache.org/docs/format/Columnar.html">Arrow Columnar Format</a>.</p></li>
</ul>
<p>If a layer consists of 4 features with 2 fields (one of integer type, one of
floating-point type), the representation as a ArrowArray is <em>conceptually</em> the
following one:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">array</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">buffers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">};</span>
<span class="n">array</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">buffers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3</span><span class="p">,</span><span class="w"> </span><span class="mf">3.4</span><span class="p">,</span><span class="w"> </span><span class="mf">4.5</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>The content of a whole layer can be seen as a sequence of record batches, each
record batches being an ArrowArray of a subset of features. Instead of iterating
over individual features, one iterates over a batch of several features at
once.</p>
<p>The ArrowArrayStream, ArrowSchema, ArrowArray structures are defined in a ogr_recordbatch.h
public header file, directly derived from <a class="reference external" href="https://github.com/apache/arrow/blob/main/cpp/src/arrow/c/abi.h">https://github.com/apache/arrow/blob/main/cpp/src/arrow/c/abi.h</a>
to get API/ABI compatibility with Apache Arrow C++. This header file must be
explicitly included when the related array batch API is used.</p>
<p>The following virtual method is added to the OGRLayer class:</p>
<blockquote>
<div><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">OGRLayer::GetArrowStream</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">ArrowArrayStream</span><span class="o">*</span><span class="w"> </span><span class="n">out_stream</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">CSLConstList</span><span class="w"> </span><span class="n">papszOptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>This method is also available in the C API as OGR_L_GetArrowStream().</p>
<p>out_stream is a pointer to a ArrowArrayStream structure, that can be in a uninitialized
state (the method will ignore any initial content).</p>
<p>On successful return, and when the stream interfaces is no longer needed, it must must
be freed with out_stream-&gt;release(out_stream).</p>
<p>There are extra precautions to take into account in a OGR context. Unless
otherwise specified by a particular driver implementation, the ArrowArrayStream
structure, and the ArrowSchema or ArrowArray objects its callbacks have returned,
should no longer be used (except for potentially being released) after the
OGRLayer from which it was initialized has been destroyed (typically at dataset
closing). Furthermore, unless otherwise specified by a particular driver
implementation, only one ArrowArrayStream can be active at a time on
a given layer (that is the last active one must be explicitly released before
a next one is asked). Changing filter state, ignored columns, modifying the schema
or using ResetReading()/GetNextFeature() while using a ArrowArrayStream is
strongly discouraged and may lead to unexpected results. As a rule of thumb,
no OGRLayer methods that affect the state of a layer should be called on a
layer, while an ArrowArrayStream on it is active.</p>
<p>A potential usage can be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ArrowArrayStream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">poLayer</span><span class="o">-&gt;</span><span class="n">GetArrowStream</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;GetArrowStream() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ArrowSchema</span><span class="w"> </span><span class="n">schema</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">get_schema</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">schema</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Do something useful</span>
<span class="w">    </span><span class="n">schema</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schema</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ArrowArray</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Look for an error (get_next() returning a non-zero code), or</span>
<span class="w">    </span><span class="c1">// end of iteration (array.release == nullptr)</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">array</span><span class="p">.</span><span class="n">release</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Do something useful</span>
<span class="w">    </span><span class="n">array</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">stream</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>The papszOptions that may be provided is a NULL terminated list of key=value
strings, that may be driver specific.</p>
<p>OGRLayer has a base implementation of GetArrowStream() that is such:</p>
<ul>
<li><p>The get_schema() callback returns a schema whose top-level object returned is
of type Struct, and whose children consist in the FID column, all OGR attribute
fields and geometry fields to Arrow fields.
The FID column may be omitted by providing the INCLUDE_FID=NO option.</p>
<p>When get_schema() returns 0, and the schema is no longer needed, it must
be released with the following procedure, to take into account that it might
have been released by other code, as documented in the Arrow C data
interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">out_schema</span><span class="o">-&gt;</span><span class="n">release</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">out_schema</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">out_schema</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>The get_next() callback retrieve the next record batch over the layer.</p>
<p>out_array is a pointer to a ArrowArray structure, that can be in a uninitialized
state (the method will ignore any initial content).</p>
<p>The default implementation uses GetNextFeature() internally to retrieve batches
of up to 65,536 features (configurable with the MAX_FEATURES_IN_BATCH=num option).
The starting address of buffers allocated by the
default implementation is aligned on 64-byte boundaries.</p>
<p>The default implementation outputs geometries as WKB in a binary field,
whose corresponding entry in the schema is marked with the metadata item
<code class="docutils literal notranslate"><span class="pre">ARROW:extension:name</span></code> set to <code class="docutils literal notranslate"><span class="pre">ogc.wkb</span></code>. Specialized implementations may output
by default other formats (particularly the Arrow driver that can return geometries
encoded according to the GeoArrow specification (using a list of coordinates).
The GEOMETRY_ENCODING=WKB option can be passed to force the use of WKB (through
the default implementation)</p>
<p>The method may take into account ignored fields set with SetIgnoredFields() (the
default implementation does), and should take into account filters set with
SetSpatialFilter() and SetAttributeFilter(). Note however that specialized implementations
may fallback to the default (slower) implementation when filters are set.</p>
<p>Mixing calls to GetNextFeature() and get_next() is not recommended, as
the behavior will be unspecified (but it should not crash).</p>
<p>When get_next() returns 0, and the array is no longer needed, it must
be released with the following procedure, to take into account that it might
have been released by other code, as documented in the Arrow C data
interface:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">out_array</span><span class="o">-&gt;</span><span class="n">release</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="n">out_array</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">out_array</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Drivers that have a specialized implementation should advertise the
new OLCFastGetArrowStream layer capability.</p>
</section>
<section id="other-remarks">
<h2>Other remarks<a class="headerlink" href="#other-remarks" title="Link to this heading"></a></h2>
<p>Using directly (as a producer or a consumer) a ArrowArray is admittedly not
trivial, and requires good intimacy with the Arrow C data interface and columnar
array specifications, to know, in which buffer of an array, data is to be read,
which data type void* buffers should be cast to, how to use buffers that contain
null/not_null information, how to use offset buffers for data types of type List, etc.</p>
<p>For the consuming side, the new API will be best used with the (Py)Arrow, Pandas,
GeoPandas, Numpy libraries which offer easier and safer access to record batches.
The study of the gdal_array._RecordBatchAsNumpy() method added to the SWIG Python
bindings can give a good hint of how to use an ArrowArray object, in conjunction
with the associated ArrowSchema. DuckDB is also another example of using the ArrowArray
interface: <a class="reference external" href="https://github.com/duckdb/duckdb/blob/master/src/common/types/data_chunk.cpp">https://github.com/duckdb/duckdb/blob/master/src/common/types/data_chunk.cpp</a></p>
<p>It is not expected that most drivers will have a dedicated implementation of
GetArrowStream() or its callbacks. Implementing it requires a non-trivial effort, and
significant gains are to be expected only for those for which I/O is very fast,
and thus in-memory shuffling of data takes a substantial time relatively to the
total time (I/O + shuffling).</p>
<p>Potential future work, not in the scope of this RFC, could be the addition of a
column-oriented method to write new features, a WriteRecordBatch() method.</p>
</section>
<section id="impacted-drivers">
<h2>Impacted drivers<a class="headerlink" href="#impacted-drivers" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Arrow and Parquet: get_schema() and get_next() have a
specialized implementation in those drivers that directly map to methods of
the arrow-cpp library that bridges at near zero cost (no data copying) the
internal C++ implementation with the C data interface.</p></li>
<li><p>FlatGeoBuf and GeoPackage: a specialized implementation of get_next() has been done,
which saves going through the OGRFeature abstraction. See below benchmarks for
measurement of the efficiency.</p></li>
</ul>
</section>
<section id="bindings">
<h2>Bindings<a class="headerlink" href="#bindings" title="Link to this heading"></a></h2>
<p>Per this RFC, only the Python bindings are extended to map the new functionality.</p>
<p>The ogr.Layer class receives the following new methods:</p>
<ul class="simple">
<li><p>GetArrowStreamAsPyArrow(): wrapper over OGRLayer::GetArrowStream() that
has a <code class="docutils literal notranslate"><span class="pre">schema</span></code> property with the C ArrowSchema into a corresponding
PyArrow Schema object and which implements a Python iterator exposing the
C ArrowArray returned by the get_next() callback as a corresponding
PyArrow Array object. This is a almost zero-cost call.</p></li>
<li><p>GetArrowStreamAsNumPy(): wrapper over OGRLayer::GetArrowStream()
which implements a Python iterator exposing the C ArrowArray returned by the
get_next() callback as a Python dictionary whose keys are field names and
values a Numpy array representing the values of the ArrowArray. The mapping of
types is done for all Arrow data types returned by the base implementation of
OGRLayer::GetArrowStream(), but may not cover &quot;exotic&quot; data types that can
be returned by specialized implementations such as the one in the Arrow/Parquet
driver. For numeric data types, the Numpy array is a zero-copy adaptation of the
C buffer. For other data types, a copy is involved, with potentially arrays of
Python objects.</p></li>
</ul>
</section>
<section id="benchmarks">
<span id="rfc-86-benchmarks"></span><h2>Benchmarks<a class="headerlink" href="#benchmarks" title="Link to this heading"></a></h2>
<p>The test programs referenced in <a class="reference internal" href="#rfc-86-annexes"><span class="std std-ref">Annexes</span></a> have been run on a
dataset with 3.3 millions features, with 13 fields each (2 fields of type Integer,
8 of type String, 3 of type DateTime) and polygon geometries.</p>
<p><a class="reference internal" href="#rfc-86-bench-ogr-py"><span class="std std-ref">bench_ogr.py</span></a>, <a class="reference internal" href="#rfc-86-bench-fiona"><span class="std std-ref">bench_fiona.py</span></a> and <a class="reference internal" href="#rfc-86-bench-ogr-cpp"><span class="std std-ref">bench_ogr.cpp</span></a>
have similar functionality: iterating over features with GetNextFeature().</p>
<p><a class="reference internal" href="#rfc-86-bench-pyogrio-raw"><span class="std std-ref">bench_pyogrio_raw.py</span></a> does a little more by building Arrow arrays.</p>
<p><a class="reference internal" href="#rfc-86-bench-pyogrio"><span class="std std-ref">bench_pyogrio.py</span></a>, <a class="reference internal" href="#rfc-86-bench-geopandas"><span class="std std-ref">bench_geopandas.py</span></a> and <a class="reference internal" href="#rfc-86-bench-ogr-to-geopandas"><span class="std std-ref">bench_ogr_to_geopandas.py</span></a>
have all similar functionality: building a GeoPandas GeoDataFrame</p>
<p><a class="reference internal" href="#rfc-86-bench-ogr-batch-cpp"><span class="std std-ref">bench_ogr_batch.cpp</span></a> can be used to measure the raw performance of the
proposed GetArrowStream() API.</p>
<ol class="arabic simple">
<li><p>nz-building-outlines.fgb (FlatGeoBuf, 1.8 GB)</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Bench program</p></th>
<th class="head"><p>Timing (s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bench_ogr.cpp</p></td>
<td><p>6.3</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr.py</p></td>
<td><p>71</p></td>
</tr>
<tr class="row-even"><td><p>bench_fiona.py</p></td>
<td><p>68</p></td>
</tr>
<tr class="row-odd"><td><p>bench_pyogrio_raw.py</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-even"><td><p>bench_pyogrio.py</p></td>
<td><p>108</p></td>
</tr>
<tr class="row-odd"><td><p>bench_geopandas.py</p></td>
<td><p>232</p></td>
</tr>
<tr class="row-even"><td><p>bench_ogr_batch.cpp (driver impl.)</p></td>
<td><p>4.5</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr_batch.cpp (base impl.)</p></td>
<td><p>14</p></td>
</tr>
<tr class="row-even"><td><p>bench_ogr_to_geopandas.py (driver impl.)</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr_to_geopandas.py (base impl.)</p></td>
<td><p>20</p></td>
</tr>
</tbody>
</table>
<p>&quot;driver impl.&quot; means that the specialized implementation of GetArrowStream()
is used.
&quot;base impl.&quot; means that the generic implementation of GetArrowStream(),
using GetNextFeature() underneath, is used.</p>
<ol class="arabic simple" start="2">
<li><p>nz-building-outlines.parquet (GeoParquet, 436 MB)</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Bench program</p></th>
<th class="head"><p>Timing (s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bench_ogr.cpp</p></td>
<td><p>6.4</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr.py</p></td>
<td><p>72</p></td>
</tr>
<tr class="row-even"><td><p>bench_fiona.py</p></td>
<td><p>70</p></td>
</tr>
<tr class="row-odd"><td><p>bench_pyogrio_raw.py</p></td>
<td><p>46</p></td>
</tr>
<tr class="row-even"><td><p>bench_pyogrio.py</p></td>
<td><p>115</p></td>
</tr>
<tr class="row-odd"><td><p>bench_geopandas.py</p></td>
<td><p>228</p></td>
</tr>
<tr class="row-even"><td><p>bench_ogr_batch.cpp (driver impl.)</p></td>
<td><p>1.6</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr_batch.cpp (base impl.)</p></td>
<td><p>13.8</p></td>
</tr>
<tr class="row-even"><td><p>bench_ogr_to_geopandas.py (driver impl.)</p></td>
<td><p>6.8</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr_to_geopandas.py (base impl.)</p></td>
<td><p>20</p></td>
</tr>
</tbody>
</table>
<p>Note: Fiona slightly modified to accept Parquet driver as a recognized one.</p>
<ol class="arabic simple" start="3">
<li><p>nz-building-outlines.gpkg (GeoPackage, 1.7 GB)</p></li>
</ol>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Bench program</p></th>
<th class="head"><p>Timing (s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bench_ogr.cpp</p></td>
<td><p>7.6</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr.py</p></td>
<td><p>71</p></td>
</tr>
<tr class="row-even"><td><p>bench_fiona.py</p></td>
<td><p>63</p></td>
</tr>
<tr class="row-odd"><td><p>bench_pyogrio_raw.py</p></td>
<td><p>41</p></td>
</tr>
<tr class="row-even"><td><p>bench_pyogrio.py</p></td>
<td><p>103</p></td>
</tr>
<tr class="row-odd"><td><p>bench_geopandas.py</p></td>
<td><p>227</p></td>
</tr>
<tr class="row-even"><td><p>bench_ogr_batch.cpp (driver impl.)</p></td>
<td><p>4.8</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr_batch.cpp (base impl.)</p></td>
<td><p>15.5</p></td>
</tr>
<tr class="row-even"><td><p>bench_ogr_to_geopandas.py (driver impl.)</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>bench_ogr_to_geopandas.py (base impl.)</p></td>
<td><p>21</p></td>
</tr>
</tbody>
</table>
<p>This demonstrates that:</p>
<ul class="simple">
<li><p>the new API can yield significant performance gains to
ingest a OGR layer as a GeoPandas GeoDataFrame, of the order of a 4x - 10x
speed-up compared to pyogrio, even without a specialized implementation of
GetArrowStream(), and with formats that have a natural row organization
(FlatGeoBuf, GeoPackage).</p></li>
<li><p>the Parquet driver is where this shines most due to the file organization being
columnar, and its native access layer being ArrowArray compatible.</p></li>
<li><p>for drivers that don't have a specialized implementation of GetArrowStream()
and whose layout is row oriented, the GetNextFeature() approach is
(a bit) faster than GetArrowStream().</p></li>
</ul>
</section>
<section id="backward-compatibility">
<h2>Backward compatibility<a class="headerlink" href="#backward-compatibility" title="Link to this heading"></a></h2>
<p>Only API additions, fully backward compatible.</p>
<p>The C++ ABI changes due to the addition of virtual methods.</p>
</section>
<section id="new-dependencies">
<h2>New dependencies<a class="headerlink" href="#new-dependencies" title="Link to this heading"></a></h2>
<ul>
<li><p>For libgdal: none</p>
<p>The Apache Arrow C data interface just defines 2 C structures. GDAL itself
does not need to link against the Apache Arrow C++ libraries (it might link
against them, if the Arrow and/or Parquet drivers are enabled, but that's orthogonal
to the topic discussed in this RFC).</p>
</li>
<li><p>For Python bindings: none at compile time. At runtime, pyarrow is imported
by GetArrowStreamAsPyArrow().
The GetArrowStreamAsNumPy() method is implemented internally by the
gdal_array module, and thus is only available if Numpy is available at compile time
and runtime.</p></li>
</ul>
</section>
<section id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Link to this heading"></a></h2>
<p>New methods are documented, and a new documentation page will be added in the
documentation.</p>
</section>
<section id="testing">
<h2>Testing<a class="headerlink" href="#testing" title="Link to this heading"></a></h2>
<p>New methods are tested.</p>
</section>
<section id="related-prs">
<h2>Related PRs:<a class="headerlink" href="#related-prs" title="Link to this heading"></a></h2>
<p><a class="reference external" href="https://github.com/OSGeo/gdal/compare/master...rouault:arrow_batch_new?expand=1">https://github.com/OSGeo/gdal/compare/master...rouault:arrow_batch_new?expand=1</a></p>
</section>
<section id="annexes">
<span id="rfc-86-annexes"></span><h2>Annexes<a class="headerlink" href="#annexes" title="Link to this heading"></a></h2>
<section id="bench-ogr-cpp">
<span id="rfc-86-bench-ogr-cpp"></span><h3>bench_ogr.cpp<a class="headerlink" href="#bench-ogr-cpp" title="Link to this heading"></a></h3>
<p>Use of traditional GetNextFeature() and related API from C</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gdal_priv.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ogr_api.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ogrsf_frmts.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">GDALAllRegister</span><span class="p">();</span>
<span class="w">    </span><span class="n">GDALDataset</span><span class="o">*</span><span class="w"> </span><span class="n">poDS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GDALDataset</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">OGRLayer</span><span class="o">*</span><span class="w"> </span><span class="n">poLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poDS</span><span class="o">-&gt;</span><span class="n">GetLayer</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">OGRLayerH</span><span class="w"> </span><span class="n">hLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGRLayer</span><span class="o">::</span><span class="n">ToHandle</span><span class="p">(</span><span class="n">poLayer</span><span class="p">);</span>
<span class="w">    </span><span class="n">OGRFeatureDefnH</span><span class="w"> </span><span class="n">hFDefn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGR_L_GetLayerDefn</span><span class="p">(</span><span class="n">hLayer</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nFields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGR_FD_GetFieldCount</span><span class="p">(</span><span class="n">hFDefn</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">OGRFieldType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">aeTypes</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nFields</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">aeTypes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">OGR_Fld_GetType</span><span class="p">(</span><span class="n">OGR_FD_GetFieldDefn</span><span class="p">(</span><span class="n">hFDefn</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)));</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nYear</span><span class="p">,</span><span class="w"> </span><span class="n">nMonth</span><span class="p">,</span><span class="w"> </span><span class="n">nDay</span><span class="p">,</span><span class="w"> </span><span class="n">nHour</span><span class="p">,</span><span class="w"> </span><span class="n">nMin</span><span class="p">,</span><span class="w"> </span><span class="n">nSecond</span><span class="p">,</span><span class="w"> </span><span class="n">nTZ</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">OGRFeatureH</span><span class="w"> </span><span class="n">hFeat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGR_L_GetNextFeature</span><span class="p">(</span><span class="n">hLayer</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">hFeat</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="n">OGR_F_GetFID</span><span class="p">(</span><span class="n">hFeat</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nFields</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">aeTypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">OFTInteger</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="n">OGR_F_GetFieldAsInteger</span><span class="p">(</span><span class="n">hFeat</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">aeTypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">OFTInteger64</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="n">OGR_F_GetFieldAsInteger64</span><span class="p">(</span><span class="n">hFeat</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">aeTypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">OFTReal</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="n">OGR_F_GetFieldAsDouble</span><span class="p">(</span><span class="n">hFeat</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">aeTypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">OFTString</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="n">OGR_F_GetFieldAsString</span><span class="p">(</span><span class="n">hFeat</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">aeTypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">OFTDateTime</span><span class="w"> </span><span class="p">)</span>
<span class="w">                </span><span class="n">OGR_F_GetFieldAsDateTime</span><span class="p">(</span><span class="n">hFeat</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nYear</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nMonth</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nDay</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nHour</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nMin</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nSecond</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nTZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">OGRGeometryH</span><span class="w"> </span><span class="n">hGeom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGR_F_GetGeometryRef</span><span class="p">(</span><span class="n">hFeat</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">hGeom</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGR_G_WkbSize</span><span class="p">(</span><span class="n">hGeom</span><span class="p">);</span>
<span class="w">            </span><span class="n">GByte</span><span class="o">*</span><span class="w"> </span><span class="n">pabyWKB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">GByte</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
<span class="w">            </span><span class="n">OGR_G_ExportToIsoWkb</span><span class="p">(</span><span class="w"> </span><span class="n">hGeom</span><span class="p">,</span><span class="w"> </span><span class="n">wkbNDR</span><span class="p">,</span><span class="w"> </span><span class="n">pabyWKB</span><span class="p">);</span>
<span class="w">            </span><span class="n">CPLFree</span><span class="p">(</span><span class="n">pabyWKB</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">OGR_F_Destroy</span><span class="p">(</span><span class="n">hFeat</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">poDS</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="bench-ogr-py">
<span id="rfc-86-bench-ogr-py"></span><h3>bench_ogr.py<a class="headerlink" href="#bench-ogr-py" title="Link to this heading"></a></h3>
<p>Use of traditional GetNextFeature() and related API from Python (port of bench_ogr.cpp)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">ogr</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">ogr</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">lyr</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GetLayer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">lyr_defn</span> <span class="o">=</span> <span class="n">lyr</span><span class="o">.</span><span class="n">GetLayerDefn</span><span class="p">()</span>
<span class="n">fld_count</span> <span class="o">=</span> <span class="n">lyr_defn</span><span class="o">.</span><span class="n">GetFieldCount</span><span class="p">()</span>
<span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">lyr_defn</span><span class="o">.</span><span class="n">GetFieldDefn</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">GetType</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fld_count</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">lyr</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">GetFID</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fld_count</span><span class="p">):</span>
        <span class="n">fld_type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fld_type</span> <span class="o">==</span> <span class="n">ogr</span><span class="o">.</span><span class="n">OFTInteger</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">GetFieldAsInteger</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fld_type</span> <span class="o">==</span> <span class="n">ogr</span><span class="o">.</span><span class="n">OFTReal</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">GetFieldAsDouble</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fld_type</span> <span class="o">==</span> <span class="n">ogr</span><span class="o">.</span><span class="n">OFTString</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">GetFieldAsString</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">GetField</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">geom</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">GetGeometryRef</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">geom</span><span class="p">:</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">ExportToWkb</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="bench-fiona-py">
<span id="rfc-86-bench-fiona"></span><h3>bench_fiona.py<a class="headerlink" href="#bench-fiona-py" title="Link to this heading"></a></h3>
<p>Use of the Fiona Python library which uses the OGR C GetNextFeature() underneath to
expose them as GeoJSON features holded by a Python dictionary.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">fiona</span>

<span class="k">with</span> <span class="n">fiona</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">features</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>Changing the above loop to <code class="docutils literal notranslate"><span class="pre">list(features)</span></code> to accumulate features has
a significant negative impact on memory usage on big datasets, and on
memory usage.</p>
</div>
</section>
<section id="bench-pyogrio-raw-py">
<span id="rfc-86-bench-pyogrio-raw"></span><h3>bench_pyogrio_raw.py<a class="headerlink" href="#bench-pyogrio-raw-py" title="Link to this heading"></a></h3>
<p>Use of the pyogrio Python library which uses the OGR C GetNextFeature() underneath to
expose a layer as a set of Arrow arrays.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pyogrio.raw</span> <span class="kn">import</span> <span class="n">read</span>

<span class="n">read</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="bench-pyogrio-py">
<span id="rfc-86-bench-pyogrio"></span><h3>bench_pyogrio.py<a class="headerlink" href="#bench-pyogrio-py" title="Link to this heading"></a></h3>
<p>Use of the pyogrio Python library which uses the OGR C GetNextFeature() underneath to
expose a layer as GeoPandas GeoDataFrame (which involves parsing WKB as GEOS objects)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pyogrio</span> <span class="kn">import</span> <span class="n">read_dataframe</span>

<span class="n">read_dataframe</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="bench-geopandas-py">
<span id="rfc-86-bench-geopandas"></span><h3>bench_geopandas.py<a class="headerlink" href="#bench-geopandas-py" title="Link to this heading"></a></h3>
<p>Use of the GeoPandas Python library which uses Fiona underneath to
expose a layer as GeoPandas GeoDataFrame.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">geopandas</span>

<span class="n">gdf</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="bench-ogr-batch-cpp">
<span id="rfc-86-bench-ogr-batch-cpp"></span><h3>bench_ogr_batch.cpp<a class="headerlink" href="#bench-ogr-batch-cpp" title="Link to this heading"></a></h3>
<p>Use of the proposed GetNextRecordBatch() API from C++</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;gdal_priv.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ogr_api.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ogrsf_frmts.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ogr_recordbatch.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">GDALAllRegister</span><span class="p">();</span>
<span class="w">    </span><span class="n">GDALDataset</span><span class="o">*</span><span class="w"> </span><span class="n">poDS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GDALDataset</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">OGRLayer</span><span class="o">*</span><span class="w"> </span><span class="n">poLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">poDS</span><span class="o">-&gt;</span><span class="n">GetLayer</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">OGRLayerH</span><span class="w"> </span><span class="n">hLayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OGRLayer</span><span class="o">::</span><span class="n">ToHandle</span><span class="p">(</span><span class="n">poLayer</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ArrowArrayStream</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">OGR_L_GetArrowStream</span><span class="p">(</span><span class="n">hLayer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CPLError</span><span class="p">(</span><span class="n">CE_Failure</span><span class="p">,</span><span class="w"> </span><span class="n">CPLE_AppDefined</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;OGR_L_GetArrowStream() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">ArrowArray</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span>
<span class="w">            </span><span class="n">array</span><span class="p">.</span><span class="n">release</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">array</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">stream</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">poDS</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="bench-ogr-to-geopandas-py">
<span id="rfc-86-bench-ogr-to-geopandas"></span><h3>bench_ogr_to_geopandas.py<a class="headerlink" href="#bench-ogr-to-geopandas-py" title="Link to this heading"></a></h3>
<p>Use of the proposed GetNextRecordBatchAsPyArrow API from Python, to build a
GeoPandas GeoDataFrame from the concatenation of the returned arrays.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">ogr</span>
<span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>

<span class="k">def</span> <span class="nf">layer_as_geopandas</span><span class="p">(</span><span class="n">lyr</span><span class="p">):</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">lyr</span><span class="o">.</span><span class="n">GetArrowStreamAsPyArrow</span><span class="p">()</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">schema</span>

    <span class="n">geom_field_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
        <span class="n">field_md</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">field_md</span> <span class="ow">and</span> <span class="n">field_md</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ARROW:extension:name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;ogc.wkb&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">lyr</span><span class="o">.</span><span class="n">GetGeometryColumn</span><span class="p">():</span>
            <span class="n">geom_field_name</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span>
            <span class="k">break</span>

    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">field</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">]</span>
    <span class="n">schema_without_geom</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">schema</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">geom_field_name</span><span class="p">,</span> <span class="n">fields</span><span class="p">)))</span>
    <span class="n">batches_without_geom</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">non_geom_field_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">geom_field_name</span><span class="p">,</span> <span class="n">fields</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">geom_field_name</span><span class="p">:</span>
        <span class="n">schema_geom</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">schema</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">geom_field_name</span><span class="p">,</span> <span class="n">fields</span><span class="p">)))</span>
        <span class="n">batches_with_geom</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">record_batch</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">arrays_without_geom</span> <span class="o">=</span> <span class="p">[</span><span class="n">record_batch</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">non_geom_field_names</span><span class="p">]</span>
        <span class="n">batch_without_geom</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays_without_geom</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema_without_geom</span><span class="p">)</span>
        <span class="n">batches_without_geom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_without_geom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom_field_name</span><span class="p">:</span>
            <span class="n">batch_with_geom</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">([</span><span class="n">record_batch</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">geom_field_name</span><span class="p">)],</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema_geom</span><span class="p">)</span>
            <span class="n">batches_with_geom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch_with_geom</span><span class="p">)</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">(</span><span class="n">batches_without_geom</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">geom_field_name</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">geopandas.array</span> <span class="kn">import</span> <span class="n">from_wkb</span>
        <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gp</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">from_wkb</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">(</span><span class="n">batches_with_geom</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gdf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">ogr</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">lyr</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">GetLayer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">layer_as_geopandas</span><span class="p">(</span><span class="n">lyr</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>
<section id="voting-history">
<h2>Voting history<a class="headerlink" href="#voting-history" title="Link to this heading"></a></h2>
<p>+1 from PSC members MateuszL, JukkaR, HowardB and EvenR</p>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="rfc87_signed_int8.html" class="btn btn-neutral float-right" title="RFC 87: Signed int8 data type for raster" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="rfc85_policy_code_additions.html" class="btn btn-neutral float-left" title="RFC 85: Policy regarding substantial code additions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2024 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
  </div>
</footer>
        </div>
      </div>
    </section>
  </div>
  
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>