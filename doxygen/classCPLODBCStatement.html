<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: CPLODBCStatement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classCPLODBCStatement-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CPLODBCStatement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstraction for statement, and resultset.  
 <a href="classCPLODBCStatement.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cpl__odbc_8h_source.html">cpl_odbc.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac2a0d678930d0fb55940c5efd70dd0f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ac2a0d678930d0fb55940c5efd70dd0f8">Flag</a> { <a class="el" href="classCPLODBCStatement.html#ac2a0d678930d0fb55940c5efd70dd0f8a569a83154e1c0ec34eea5d3b98769ed1">RetrieveNumericColumnsAsDouble</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:ac2a0d678930d0fb55940c5efd70dd0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags which control ODBC statement behavior.  <a href="classCPLODBCStatement.html#ac2a0d678930d0fb55940c5efd70dd0f8">More...</a><br /></td></tr>
<tr class="separator:ac2a0d678930d0fb55940c5efd70dd0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab065615e737891ed2eec75d99a0bbc83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ab065615e737891ed2eec75d99a0bbc83">CPLODBCStatement</a> (<a class="el" href="classCPLODBCSession.html">CPLODBCSession</a> *, int flags=0)</td></tr>
<tr class="memdesc:ab065615e737891ed2eec75d99a0bbc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCPLODBCStatement.html#ab065615e737891ed2eec75d99a0bbc83">More...</a><br /></td></tr>
<tr class="separator:ab065615e737891ed2eec75d99a0bbc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7db3e0d3a9417416efd2e8d2953f6e"><td class="memItemLeft" align="right" valign="top"><a id="adf7db3e0d3a9417416efd2e8d2953f6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#adf7db3e0d3a9417416efd2e8d2953f6e">~CPLODBCStatement</a> ()</td></tr>
<tr class="memdesc:adf7db3e0d3a9417416efd2e8d2953f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adf7db3e0d3a9417416efd2e8d2953f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89219d0c93a15333b3d3d68ef732dc7a"><td class="memItemLeft" align="right" valign="top"><a id="a89219d0c93a15333b3d3d68ef732dc7a"></a>
HSTMT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a89219d0c93a15333b3d3d68ef732dc7a">GetStatement</a> ()</td></tr>
<tr class="memdesc:a89219d0c93a15333b3d3d68ef732dc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return statement handle. <br /></td></tr>
<tr class="separator:a89219d0c93a15333b3d3d68ef732dc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbcb4786401d9b73347d9b258ed576e"><td class="memItemLeft" align="right" valign="top"><a id="a5cbcb4786401d9b73347d9b258ed576e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a5cbcb4786401d9b73347d9b258ed576e">Flags</a> () const</td></tr>
<tr class="memdesc:a5cbcb4786401d9b73347d9b258ed576e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns statement flags. <br /></td></tr>
<tr class="separator:a5cbcb4786401d9b73347d9b258ed576e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7e1f605839b4bb73d676ea162682e7"><td class="memItemLeft" align="right" valign="top"><a id="a3a7e1f605839b4bb73d676ea162682e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a3a7e1f605839b4bb73d676ea162682e7">Clear</a> ()</td></tr>
<tr class="memdesc:a3a7e1f605839b4bb73d676ea162682e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear internal command text and result set definitions. <br /></td></tr>
<tr class="separator:a3a7e1f605839b4bb73d676ea162682e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40599446871e5bec44bd19e62252c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ae40599446871e5bec44bd19e62252c02">AppendEscaped</a> (const char *)</td></tr>
<tr class="memdesc:ae40599446871e5bec44bd19e62252c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append text to internal command.  <a href="classCPLODBCStatement.html#ae40599446871e5bec44bd19e62252c02">More...</a><br /></td></tr>
<tr class="separator:ae40599446871e5bec44bd19e62252c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0f535fc43e327990d97f055bd3d472"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a3b0f535fc43e327990d97f055bd3d472">Append</a> (const char *)</td></tr>
<tr class="memdesc:a3b0f535fc43e327990d97f055bd3d472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append text to internal command.  <a href="classCPLODBCStatement.html#a3b0f535fc43e327990d97f055bd3d472">More...</a><br /></td></tr>
<tr class="separator:a3b0f535fc43e327990d97f055bd3d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48aee327ef175b327a4f3dba8543bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ad48aee327ef175b327a4f3dba8543bce">Append</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:ad48aee327ef175b327a4f3dba8543bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append text to internal command.  <a href="classCPLODBCStatement.html#ad48aee327ef175b327a4f3dba8543bce">More...</a><br /></td></tr>
<tr class="separator:ad48aee327ef175b327a4f3dba8543bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c651da1fa4ce9291ab5f3c079ba423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ab8c651da1fa4ce9291ab5f3c079ba423">Append</a> (int)</td></tr>
<tr class="memdesc:ab8c651da1fa4ce9291ab5f3c079ba423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to internal command.  <a href="classCPLODBCStatement.html#ab8c651da1fa4ce9291ab5f3c079ba423">More...</a><br /></td></tr>
<tr class="separator:ab8c651da1fa4ce9291ab5f3c079ba423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170ea4a7df8f79432efce2cb27117ef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a170ea4a7df8f79432efce2cb27117ef2">Append</a> (double)</td></tr>
<tr class="memdesc:a170ea4a7df8f79432efce2cb27117ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to internal command.  <a href="classCPLODBCStatement.html#a170ea4a7df8f79432efce2cb27117ef2">More...</a><br /></td></tr>
<tr class="separator:a170ea4a7df8f79432efce2cb27117ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3c9d8bdd495487e981429199e99f51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#abd3c9d8bdd495487e981429199e99f51">Appendf</a> (const char *,...)</td></tr>
<tr class="memdesc:abd3c9d8bdd495487e981429199e99f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to internal command.  <a href="classCPLODBCStatement.html#abd3c9d8bdd495487e981429199e99f51">More...</a><br /></td></tr>
<tr class="separator:abd3c9d8bdd495487e981429199e99f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07625f5463eea76c32b0de5e53a4f0f5"><td class="memItemLeft" align="right" valign="top"><a id="a07625f5463eea76c32b0de5e53a4f0f5"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a07625f5463eea76c32b0de5e53a4f0f5">GetCommand</a> ()</td></tr>
<tr class="memdesc:a07625f5463eea76c32b0de5e53a4f0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return statement string. <br /></td></tr>
<tr class="separator:a07625f5463eea76c32b0de5e53a4f0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cc04eb4945587cb3ddddc2838636be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a57cc04eb4945587cb3ddddc2838636be">ExecuteSQL</a> (const char *=nullptr)</td></tr>
<tr class="memdesc:a57cc04eb4945587cb3ddddc2838636be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an SQL statement.  <a href="classCPLODBCStatement.html#a57cc04eb4945587cb3ddddc2838636be">More...</a><br /></td></tr>
<tr class="separator:a57cc04eb4945587cb3ddddc2838636be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebf900aec9ed9a635e0b24f838ec00c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a2ebf900aec9ed9a635e0b24f838ec00c">Fetch</a> (int nOrientation=SQL_FETCH_NEXT, int nOffset=0)</td></tr>
<tr class="memdesc:a2ebf900aec9ed9a635e0b24f838ec00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a new record.  <a href="classCPLODBCStatement.html#a2ebf900aec9ed9a635e0b24f838ec00c">More...</a><br /></td></tr>
<tr class="separator:a2ebf900aec9ed9a635e0b24f838ec00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af976569c5dc6a5e1d52aeff001fd82c8"><td class="memItemLeft" align="right" valign="top"><a id="af976569c5dc6a5e1d52aeff001fd82c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#af976569c5dc6a5e1d52aeff001fd82c8">ClearColumnData</a> ()</td></tr>
<tr class="memdesc:af976569c5dc6a5e1d52aeff001fd82c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ClearColumnData. <br /></td></tr>
<tr class="separator:af976569c5dc6a5e1d52aeff001fd82c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdb2a6ed42b2193ec5c668d978c7140"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a4fdb2a6ed42b2193ec5c668d978c7140">GetColCount</a> ()</td></tr>
<tr class="memdesc:a4fdb2a6ed42b2193ec5c668d978c7140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the resultset column count.  <a href="classCPLODBCStatement.html#a4fdb2a6ed42b2193ec5c668d978c7140">More...</a><br /></td></tr>
<tr class="separator:a4fdb2a6ed42b2193ec5c668d978c7140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9cf8e5a20abfe6d49f937c8e16bab3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#aeb9cf8e5a20abfe6d49f937c8e16bab3">GetColName</a> (int)</td></tr>
<tr class="memdesc:aeb9cf8e5a20abfe6d49f937c8e16bab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a column name.  <a href="classCPLODBCStatement.html#aeb9cf8e5a20abfe6d49f937c8e16bab3">More...</a><br /></td></tr>
<tr class="separator:aeb9cf8e5a20abfe6d49f937c8e16bab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefccc2295341b2ef09e0ad9be5ec9e2"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#acefccc2295341b2ef09e0ad9be5ec9e2">GetColType</a> (int)</td></tr>
<tr class="memdesc:acefccc2295341b2ef09e0ad9be5ec9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a column data type.  <a href="classCPLODBCStatement.html#acefccc2295341b2ef09e0ad9be5ec9e2">More...</a><br /></td></tr>
<tr class="separator:acefccc2295341b2ef09e0ad9be5ec9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa727a5ebeb29ce108b01a847de18a8de"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#aa727a5ebeb29ce108b01a847de18a8de">GetColTypeName</a> (int)</td></tr>
<tr class="memdesc:aa727a5ebeb29ce108b01a847de18a8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a column data type name.  <a href="classCPLODBCStatement.html#aa727a5ebeb29ce108b01a847de18a8de">More...</a><br /></td></tr>
<tr class="separator:aa727a5ebeb29ce108b01a847de18a8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc9186c6b107cfbedb5677e97c86830"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a3fc9186c6b107cfbedb5677e97c86830">GetColSize</a> (int)</td></tr>
<tr class="memdesc:a3fc9186c6b107cfbedb5677e97c86830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the column width.  <a href="classCPLODBCStatement.html#a3fc9186c6b107cfbedb5677e97c86830">More...</a><br /></td></tr>
<tr class="separator:a3fc9186c6b107cfbedb5677e97c86830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6c8c2f790c81ce9ad1f067ee26ddfa"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a2d6c8c2f790c81ce9ad1f067ee26ddfa">GetColPrecision</a> (int)</td></tr>
<tr class="memdesc:a2d6c8c2f790c81ce9ad1f067ee26ddfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the column precision.  <a href="classCPLODBCStatement.html#a2d6c8c2f790c81ce9ad1f067ee26ddfa">More...</a><br /></td></tr>
<tr class="separator:a2d6c8c2f790c81ce9ad1f067ee26ddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31342f00e8dbbaea08ce7bcab12cad79"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a31342f00e8dbbaea08ce7bcab12cad79">GetColNullable</a> (int)</td></tr>
<tr class="memdesc:a31342f00e8dbbaea08ce7bcab12cad79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the column nullability.  <a href="classCPLODBCStatement.html#a31342f00e8dbbaea08ce7bcab12cad79">More...</a><br /></td></tr>
<tr class="separator:a31342f00e8dbbaea08ce7bcab12cad79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17714cf4ad617dde4579cf2138d62898"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a17714cf4ad617dde4579cf2138d62898">GetColColumnDef</a> (int)</td></tr>
<tr class="memdesc:a17714cf4ad617dde4579cf2138d62898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a column default value.  <a href="classCPLODBCStatement.html#a17714cf4ad617dde4579cf2138d62898">More...</a><br /></td></tr>
<tr class="separator:a17714cf4ad617dde4579cf2138d62898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfb69d708373710419c56a11c786299"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a5dfb69d708373710419c56a11c786299">GetColId</a> (const char *) const</td></tr>
<tr class="memdesc:a5dfb69d708373710419c56a11c786299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch column index.  <a href="classCPLODBCStatement.html#a5dfb69d708373710419c56a11c786299">More...</a><br /></td></tr>
<tr class="separator:a5dfb69d708373710419c56a11c786299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbb51bfcce309232e1bd852e336660c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#aacbb51bfcce309232e1bd852e336660c">GetColData</a> (int, const char *=nullptr)</td></tr>
<tr class="memdesc:aacbb51bfcce309232e1bd852e336660c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch column data.  <a href="classCPLODBCStatement.html#aacbb51bfcce309232e1bd852e336660c">More...</a><br /></td></tr>
<tr class="separator:aacbb51bfcce309232e1bd852e336660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8213591b8e3032834bb3c2a4f3d37d6c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a8213591b8e3032834bb3c2a4f3d37d6c">GetColData</a> (const char *, const char *=nullptr)</td></tr>
<tr class="memdesc:a8213591b8e3032834bb3c2a4f3d37d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch column data.  <a href="classCPLODBCStatement.html#a8213591b8e3032834bb3c2a4f3d37d6c">More...</a><br /></td></tr>
<tr class="separator:a8213591b8e3032834bb3c2a4f3d37d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e87977f8ce1fc67d3fcd72d143fdf9d"><td class="memItemLeft" align="right" valign="top"><a id="a7e87977f8ce1fc67d3fcd72d143fdf9d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a7e87977f8ce1fc67d3fcd72d143fdf9d">GetColDataLength</a> (int)</td></tr>
<tr class="memdesc:a7e87977f8ce1fc67d3fcd72d143fdf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetColDataLength. <br /></td></tr>
<tr class="separator:a7e87977f8ce1fc67d3fcd72d143fdf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56e992a91ff63cef674521927258025"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#aa56e992a91ff63cef674521927258025">GetColDataAsDouble</a> (int) const</td></tr>
<tr class="memdesc:aa56e992a91ff63cef674521927258025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch column data as a double value.  <a href="classCPLODBCStatement.html#aa56e992a91ff63cef674521927258025">More...</a><br /></td></tr>
<tr class="separator:aa56e992a91ff63cef674521927258025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd11a8757869f99661c2f811531dcd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a9cbd11a8757869f99661c2f811531dcd">GetColDataAsDouble</a> (const char *) const</td></tr>
<tr class="memdesc:a9cbd11a8757869f99661c2f811531dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch column data as a double value.  <a href="classCPLODBCStatement.html#a9cbd11a8757869f99661c2f811531dcd">More...</a><br /></td></tr>
<tr class="separator:a9cbd11a8757869f99661c2f811531dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3156d254419e618b6386972b58ca7b22"><td class="memItemLeft" align="right" valign="top"><a id="a3156d254419e618b6386972b58ca7b22"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a3156d254419e618b6386972b58ca7b22">GetRowCountAffected</a> ()</td></tr>
<tr class="memdesc:a3156d254419e618b6386972b58ca7b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetRowCountAffected. <br /></td></tr>
<tr class="separator:a3156d254419e618b6386972b58ca7b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b22ff22a945fe9f6e680c7e4577cf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a44b22ff22a945fe9f6e680c7e4577cf1">GetColumns</a> (const char *pszTable, const char *pszCatalog=nullptr, const char *pszSchema=nullptr)</td></tr>
<tr class="memdesc:a44b22ff22a945fe9f6e680c7e4577cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch column definitions for a table.  <a href="classCPLODBCStatement.html#a44b22ff22a945fe9f6e680c7e4577cf1">More...</a><br /></td></tr>
<tr class="separator:a44b22ff22a945fe9f6e680c7e4577cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80984f023b12d6749c8a0b453a68e3b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a80984f023b12d6749c8a0b453a68e3b8">GetPrimaryKeys</a> (const char *pszTable, const char *pszCatalog=nullptr, const char *pszSchema=nullptr)</td></tr>
<tr class="memdesc:a80984f023b12d6749c8a0b453a68e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch primary keys for a table.  <a href="classCPLODBCStatement.html#a80984f023b12d6749c8a0b453a68e3b8">More...</a><br /></td></tr>
<tr class="separator:a80984f023b12d6749c8a0b453a68e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0e2a9effc0c32bd916398786402bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#a2a0e2a9effc0c32bd916398786402bf3">GetTables</a> (const char *pszCatalog=nullptr, const char *pszSchema=nullptr)</td></tr>
<tr class="memdesc:a2a0e2a9effc0c32bd916398786402bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch tables in database.  <a href="classCPLODBCStatement.html#a2a0e2a9effc0c32bd916398786402bf3">More...</a><br /></td></tr>
<tr class="separator:a2a0e2a9effc0c32bd916398786402bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac8fabff87844776f9198786fbf8cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#aaac8fabff87844776f9198786fbf8cab">DumpResult</a> (FILE *fp, int bShowSchema=FALSE)</td></tr>
<tr class="memdesc:aaac8fabff87844776f9198786fbf8cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump resultset to file.  <a href="classCPLODBCStatement.html#aaac8fabff87844776f9198786fbf8cab">More...</a><br /></td></tr>
<tr class="separator:aaac8fabff87844776f9198786fbf8cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f63ad925897e76926340dc5cd1be23"><td class="memItemLeft" align="right" valign="top"><a id="ac2f63ad925897e76926340dc5cd1be23"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ac2f63ad925897e76926340dc5cd1be23">CollectResultsInfo</a> ()</td></tr>
<tr class="memdesc:ac2f63ad925897e76926340dc5cd1be23"><td class="mdescLeft">&#160;</td><td class="mdescRight">CollectResultsInfo. <br /></td></tr>
<tr class="separator:ac2f63ad925897e76926340dc5cd1be23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae9f475371e9ff2f91e6514668803900b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classCPLString.html">CPLString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#ae9f475371e9ff2f91e6514668803900b">GetTypeName</a> (int)</td></tr>
<tr class="memdesc:ae9f475371e9ff2f91e6514668803900b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name for SQL column type.  <a href="classCPLODBCStatement.html#ae9f475371e9ff2f91e6514668803900b">More...</a><br /></td></tr>
<tr class="separator:ae9f475371e9ff2f91e6514668803900b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe650707128654709da20449ee440f2a"><td class="memItemLeft" align="right" valign="top">static SQLSMALLINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPLODBCStatement.html#afe650707128654709da20449ee440f2a">GetTypeMapping</a> (SQLSMALLINT)</td></tr>
<tr class="memdesc:afe650707128654709da20449ee440f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get appropriate C data type for SQL column type.  <a href="classCPLODBCStatement.html#afe650707128654709da20449ee440f2a">More...</a><br /></td></tr>
<tr class="separator:afe650707128654709da20449ee440f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction for statement, and resultset. </p>
<p>Includes methods for executing an SQL statement, and for accessing the resultset from that statement. Also provides for executing other ODBC requests that produce results sets such as SQLColumns() and SQLTables() requests. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac2a0d678930d0fb55940c5efd70dd0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a0d678930d0fb55940c5efd70dd0f8">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCPLODBCStatement.html#ac2a0d678930d0fb55940c5efd70dd0f8">CPLODBCStatement::Flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags which control ODBC statement behavior. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac2a0d678930d0fb55940c5efd70dd0f8a569a83154e1c0ec34eea5d3b98769ed1"></a>RetrieveNumericColumnsAsDouble&#160;</td><td class="fielddoc"><p>Numeric column values should be retrieved as doubles, using either the SQL_C_DOUBLE or SQL_C_FLOAT types. </p>
<p>By default numeric column values are retrieved as characters. Retrieving as character is the safest behavior, but can risk loss of precision.</p>
<p>If set, GetColDataAsDouble should be used for numeric columns instead of GetColData.</p>
<p>Warning: this flag can expose issues in particular ODBC drivers on different platforms. Use with caution. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab065615e737891ed2eec75d99a0bbc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065615e737891ed2eec75d99a0bbc83">&#9670;&nbsp;</a></span>CPLODBCStatement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CPLODBCStatement::CPLODBCStatement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCPLODBCSession.html">CPLODBCSession</a> *&#160;</td>
          <td class="paramname"><em>poSession</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The optional flags argument can be used to specify flags which control the behavior of the statement. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b0f535fc43e327990d97f055bd3d472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0f535fc43e327990d97f055bd3d472">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLODBCStatement::Append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append text to internal command. </p>
<p>The passed text is appended to the internal SQL command text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszText</td><td>text to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad48aee327ef175b327a4f3dba8543bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48aee327ef175b327a4f3dba8543bce">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLODBCStatement::Append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append text to internal command. </p>
<p>The passed text is appended to the internal SQL command text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>text to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a170ea4a7df8f79432efce2cb27117ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170ea4a7df8f79432efce2cb27117ef2">&#9670;&nbsp;</a></span>Append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLODBCStatement::Append </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append to internal command. </p>
<p>The passed value is formatted and appended to the internal SQL command text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfValue</td><td>value to append to the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8c651da1fa4ce9291ab5f3c079ba423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c651da1fa4ce9291ab5f3c079ba423">&#9670;&nbsp;</a></span>Append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLODBCStatement::Append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append to internal command. </p>
<p>The passed value is formatted and appended to the internal SQL command text.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nValue</td><td>value to append to the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae40599446871e5bec44bd19e62252c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40599446871e5bec44bd19e62252c02">&#9670;&nbsp;</a></span>AppendEscaped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLODBCStatement::AppendEscaped </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append text to internal command. </p>
<p>The passed text is appended to the internal SQL command text after escaping any special characters so it can be used as a character string in an SQL statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszText</td><td>text to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd3c9d8bdd495487e981429199e99f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3c9d8bdd495487e981429199e99f51">&#9670;&nbsp;</a></span>Appendf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::Appendf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append to internal command. </p>
<p>The passed format is used to format other arguments and the result is appended to the internal command text. Long results may not be formatted properly, and should be appended with the direct <a class="el" href="classCPLODBCStatement.html#a3b0f535fc43e327990d97f055bd3d472" title="Append text to internal command.">Append()</a> methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFormat</td><td>printf() style format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if formatting fails due to result being too large. </dd></dl>

</div>
</div>
<a id="aaac8fabff87844776f9198786fbf8cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac8fabff87844776f9198786fbf8cab">&#9670;&nbsp;</a></span>DumpResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CPLODBCStatement::DumpResult </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bShowSchema</em> = <code>FALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump resultset to file. </p>
<p>The contents of the current resultset are dumped in a simply formatted form to the provided file. If requested, the schema definition will be written first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>the file to write to. stdout or stderr are acceptable.</td></tr>
    <tr><td class="paramname">bShowSchema</td><td>TRUE to force writing schema information for the rowset before the rowset data itself. Default is FALSE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57cc04eb4945587cb3ddddc2838636be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cc04eb4945587cb3ddddc2838636be">&#9670;&nbsp;</a></span>ExecuteSQL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::ExecuteSQL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStatement</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an SQL statement. </p>
<p>This method will execute the passed (or stored) SQL statement, and initialize information about the resultset if there is one. If a NULL statement is passed, the internal stored statement that has been previously set via <a class="el" href="classCPLODBCStatement.html#a3b0f535fc43e327990d97f055bd3d472" title="Append text to internal command.">Append()</a> or <a class="el" href="classCPLODBCStatement.html#abd3c9d8bdd495487e981429199e99f51" title="Append to internal command.">Appendf()</a> calls will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszStatement</td><td>the SQL statement to execute, or NULL if the internally saved one should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE if there is an error. Error details can be fetched with OGRODBCSession::GetLastError(). </dd></dl>

</div>
</div>
<a id="a2ebf900aec9ed9a635e0b24f838ec00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebf900aec9ed9a635e0b24f838ec00c">&#9670;&nbsp;</a></span>Fetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::Fetch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOrientation</em> = <code>SQL_FETCH_NEXT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a new record. </p>
<p>Requests the next row in the current resultset using the SQLFetchScroll() call. Note that many ODBC drivers only support the default forward fetching one record at a time. Only SQL_FETCH_NEXT (the default) should be considered reliable on all drivers.</p>
<p>Currently it isn't clear how to determine whether an error or a normal out of data condition has occurred if <a class="el" href="classCPLODBCStatement.html#a2ebf900aec9ed9a635e0b24f838ec00c" title="Fetch a new record.">Fetch()</a> fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nOrientation</td><td>One of SQL_FETCH_NEXT, SQL_FETCH_LAST, SQL_FETCH_PRIOR, SQL_FETCH_ABSOLUTE, or SQL_FETCH_RELATIVE (default is SQL_FETCH_NEXT).</td></tr>
    <tr><td class="paramname">nOffset</td><td>the offset (number of records), ignored for some orientations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a new row is successfully fetched, or FALSE if not. </dd></dl>

</div>
</div>
<a id="a17714cf4ad617dde4579cf2138d62898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17714cf4ad617dde4579cf2138d62898">&#9670;&nbsp;</a></span>GetColColumnDef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLODBCStatement::GetColColumnDef </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a column default value. </p>
<p>Returns the default value of a column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the default value is not dpecified or the internal copy of the default value. </dd></dl>

</div>
</div>
<a id="a4fdb2a6ed42b2193ec5c668d978c7140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdb2a6ed42b2193ec5c668d978c7140">&#9670;&nbsp;</a></span>GetColCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::GetColCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the resultset column count. </p>
<dl class="section return"><dt>Returns</dt><dd>the column count, or zero if there is no resultset. </dd></dl>

</div>
</div>
<a id="a8213591b8e3032834bb3c2a4f3d37d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8213591b8e3032834bb3c2a4f3d37d6c">&#9670;&nbsp;</a></span>GetColData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLODBCStatement::GetColData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszColName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch column data. </p>
<p>Fetches the data contents of the requested column for the currently loaded row. The result is returned as a string regardless of the column type. NULL is returned if an illegal column is given, or if the actual column is "NULL".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszColName</td><td>the name of the column requested.</td></tr>
    <tr><td class="paramname">pszDefault</td><td>the value to return if the column does not exist, or is NULL. Defaults to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to internal column data or NULL on failure. </dd></dl>

</div>
</div>
<a id="aacbb51bfcce309232e1bd852e336660c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbb51bfcce309232e1bd852e336660c">&#9670;&nbsp;</a></span>GetColData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLODBCStatement::GetColData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch column data. </p>
<p>Fetches the data contents of the requested column for the currently loaded row. The result is returned as a string regardless of the column type. NULL is returned if an illegal column is given, or if the actual column is "NULL".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column to fetch.</td></tr>
    <tr><td class="paramname">pszDefault</td><td>the value to return if the column does not exist, or is NULL. Defaults to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to internal column data or NULL on failure. </dd></dl>

</div>
</div>
<a id="a9cbd11a8757869f99661c2f811531dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd11a8757869f99661c2f811531dcd">&#9670;&nbsp;</a></span>GetColDataAsDouble() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLODBCStatement::GetColDataAsDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszColName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch column data as a double value. </p>
<p>Fetches the data contents of the requested column for the currently loaded row as a double value.</p>
<p>Returns NaN if a non-numeric column is requested or the actual column value is "NULL".</p>
<dl class="section warning"><dt>Warning</dt><dd>this method can only be used if the Flag::RetrieveNumericColumnsAsDouble flag was set for the <a class="el" href="classCPLODBCStatement.html" title="Abstraction for statement, and resultset.">CPLODBCStatement</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszColName</td><td>the name of the column requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>numeric column value or NaN on failure. </dd></dl>

</div>
</div>
<a id="aa56e992a91ff63cef674521927258025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56e992a91ff63cef674521927258025">&#9670;&nbsp;</a></span>GetColDataAsDouble() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CPLODBCStatement::GetColDataAsDouble </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch column data as a double value. </p>
<p>Fetches the data contents of the requested column for the currently loaded row as a double value.</p>
<p>Returns NaN if a non-numeric column is requested or the actual column value is "NULL".</p>
<dl class="section warning"><dt>Warning</dt><dd>this method can only be used if the Flag::RetrieveNumericColumnsAsDouble flag was set for the <a class="el" href="classCPLODBCStatement.html" title="Abstraction for statement, and resultset.">CPLODBCStatement</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column to fetch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>numeric column value or NaN on failure. </dd></dl>

</div>
</div>
<a id="a5dfb69d708373710419c56a11c786299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfb69d708373710419c56a11c786299">&#9670;&nbsp;</a></span>GetColId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::GetColId </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszColName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch column index. </p>
<p>Gets the column index corresponding with the passed name. The name comparisons are case insensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszColName</td><td>the name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the column index, or -1 if not found. </dd></dl>

</div>
</div>
<a id="aeb9cf8e5a20abfe6d49f937c8e16bab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9cf8e5a20abfe6d49f937c8e16bab3">&#9670;&nbsp;</a></span>GetColName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLODBCStatement::GetColName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a column name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure (out of bounds column), or a pointer to an internal copy of the column name. </dd></dl>

</div>
</div>
<a id="a31342f00e8dbbaea08ce7bcab12cad79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31342f00e8dbbaea08ce7bcab12cad79">&#9670;&nbsp;</a></span>GetColNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CPLODBCStatement::GetColNullable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the column nullability. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the column may contains or FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a2d6c8c2f790c81ce9ad1f067ee26ddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6c8c2f790c81ce9ad1f067ee26ddfa">&#9670;&nbsp;</a></span>GetColPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CPLODBCStatement::GetColPrecision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the column precision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column precision, may be zero or the same as column size for columns to which it does not apply. </dd></dl>

</div>
</div>
<a id="a3fc9186c6b107cfbedb5677e97c86830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc9186c6b107cfbedb5677e97c86830">&#9670;&nbsp;</a></span>GetColSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CPLODBCStatement::GetColSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the column width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>column width, zero for unknown width columns. </dd></dl>

</div>
</div>
<a id="acefccc2295341b2ef09e0ad9be5ec9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefccc2295341b2ef09e0ad9be5ec9e2">&#9670;&nbsp;</a></span>GetColType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CPLODBCStatement::GetColType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a column data type. </p>
<p>The return type code is a an ODBC SQL_ code, one of SQL_UNKNOWN_TYPE, SQL_CHAR, SQL_NUMERIC, SQL_DECIMAL, SQL_INTEGER, SQL_SMALLINT, SQL_FLOAT, SQL_REAL, SQL_DOUBLE, SQL_DATETIME, SQL_VARCHAR, SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMPT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type code or -1 if the column is illegal. </dd></dl>

</div>
</div>
<a id="aa727a5ebeb29ce108b01a847de18a8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa727a5ebeb29ce108b01a847de18a8de">&#9670;&nbsp;</a></span>GetColTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * CPLODBCStatement::GetColTypeName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a column data type name. </p>
<p>Returns data source-dependent data type name; for example, "CHAR", "VARCHAR", "MONEY", "LONG VARBINAR", or "CHAR ( ) FOR BIT DATA".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iCol</td><td>the zero based column index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure (out of bounds column), or a pointer to an internal copy of the column dat type name. </dd></dl>

</div>
</div>
<a id="a44b22ff22a945fe9f6e680c7e4577cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b22ff22a945fe9f6e680c7e4577cf1">&#9670;&nbsp;</a></span>GetColumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::GetColumns </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCatalog</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSchema</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch column definitions for a table. </p>
<p>The SQLColumn() method is used to fetch the definitions for the columns of a table (or other queryable object such as a view). The column definitions are digested and used to populate the <a class="el" href="classCPLODBCStatement.html" title="Abstraction for statement, and resultset.">CPLODBCStatement</a> column definitions essentially as if a "SELECT * FROM tablename" had been done; however, no resultset will be available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTable</td><td>the name of the table to query information on. This should not be empty.</td></tr>
    <tr><td class="paramname">pszCatalog</td><td>the catalog to find the table in, use NULL (the default) if no catalog is available.</td></tr>
    <tr><td class="paramname">pszSchema</td><td>the schema to find the table in, use NULL (the default) if no schema is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure. </dd></dl>

</div>
</div>
<a id="a80984f023b12d6749c8a0b453a68e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80984f023b12d6749c8a0b453a68e3b8">&#9670;&nbsp;</a></span>GetPrimaryKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::GetPrimaryKeys </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCatalog</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSchema</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch primary keys for a table. </p>
<p>The SQLPrimaryKeys() function is used to fetch a list of fields forming the primary key. The result is returned as a result set matching the SQLPrimaryKeys() function result set. The 4th column in the result set is the column name of the key, and if the result set contains only one record then that single field will be the complete primary key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszTable</td><td>the name of the table to query information on. This should not be empty.</td></tr>
    <tr><td class="paramname">pszCatalog</td><td>the catalog to find the table in, use NULL (the default) if no catalog is available.</td></tr>
    <tr><td class="paramname">pszSchema</td><td>the schema to find the table in, use NULL (the default) if no schema is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure. </dd></dl>

</div>
</div>
<a id="a2a0e2a9effc0c32bd916398786402bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0e2a9effc0c32bd916398786402bf3">&#9670;&nbsp;</a></span>GetTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CPLODBCStatement::GetTables </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCatalog</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSchema</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch tables in database. </p>
<p>The SQLTables() function is used to fetch a list tables in the database. The result is returned as a result set matching the SQLTables() function result set. The 3rd column in the result set is the table name. Only tables of type "TABLE" are returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCatalog</td><td>the catalog to find the table in, use NULL (the default) if no catalog is available.</td></tr>
    <tr><td class="paramname">pszSchema</td><td>the schema to find the table in, use NULL (the default) if no schema is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure. </dd></dl>

</div>
</div>
<a id="afe650707128654709da20449ee440f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe650707128654709da20449ee440f2a">&#9670;&nbsp;</a></span>GetTypeMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SQLSMALLINT CPLODBCStatement::GetTypeMapping </td>
          <td>(</td>
          <td class="paramtype">SQLSMALLINT&#160;</td>
          <td class="paramname"><em>nTypeCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get appropriate C data type for SQL column type. </p>
<p>Returns a C data type code, corresponding to the indicated SQL data type code (as returned from <a class="el" href="classCPLODBCStatement.html#acefccc2295341b2ef09e0ad9be5ec9e2" title="Fetch a column data type.">CPLODBCStatement::GetColType()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTypeCode</td><td>the SQL_ code, such as SQL_CHAR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data type code. The valid code is always returned. If SQL code is not recognised, SQL_C_BINARY will be returned. </dd></dl>

</div>
</div>
<a id="ae9f475371e9ff2f91e6514668803900b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f475371e9ff2f91e6514668803900b">&#9670;&nbsp;</a></span>GetTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCPLString.html">CPLString</a> CPLODBCStatement::GetTypeName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTypeCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name for SQL column type. </p>
<p>Returns a string name for the indicated type code (as returned from <a class="el" href="classCPLODBCStatement.html#acefccc2295341b2ef09e0ad9be5ec9e2" title="Fetch a column data type.">CPLODBCStatement::GetColType()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nTypeCode</td><td>the SQL_ code, such as SQL_CHAR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>internal string, "UNKNOWN" if code not recognised. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="cpl__odbc_8h_source.html">cpl_odbc.h</a></li>
<li>cpl_odbc.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
