<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: GDALMDArray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classGDALMDArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GDALMDArray Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class modeling a multi-dimensional array.  
 <a href="classGDALMDArray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gdal__priv_8h_source.html">gdal_priv.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for GDALMDArray:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classGDALMDArray.png" usemap="#GDALMDArray_map" alt=""/>
  <map id="GDALMDArray_map" name="GDALMDArray_map">
<area href="classGDALAbstractMDArray.html" title="Abstract class, implemented by GDALAttribute and GDALMDArray." alt="GDALAbstractMDArray" shape="rect" coords="0,0,146,24"/>
<area href="classGDALIHasAttribute.html" title="Interface used to get a single GDALAttribute or a set of GDALAttribute." alt="GDALIHasAttribute" shape="rect" coords="156,0,302,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a96c310c2baf7f653c090e38186393e65"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a96c310c2baf7f653c090e38186393e65">FuncProcessPerChunkType</a>) (<a class="el" href="classGDALAbstractMDArray.html">GDALAbstractMDArray</a> *array, const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *chunkArrayStartIdx, const size_t *chunkCount, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> iCurChunk, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> nChunkCount, void *pUserData)</td></tr>
<tr class="memdesc:a96c310c2baf7f653c090e38186393e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of pfnFunc argument of <a class="el" href="classGDALAbstractMDArray.html#a91005189ff493f595ddd4ba446cc216a" title="Call a user-provided function to operate on an array chunk by chunk.">ProcessPerChunk()</a>.  <a href="classGDALAbstractMDArray.html#a96c310c2baf7f653c090e38186393e65">More...</a><br /></td></tr>
<tr class="separator:a96c310c2baf7f653c090e38186393e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b97752cc115cb44d6339cdfad97b222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a3b97752cc115cb44d6339cdfad97b222">GetTotalCopyCost</a> () const</td></tr>
<tr class="memdesc:a3b97752cc115cb44d6339cdfad97b222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a total "cost" to copy the array.  <a href="classGDALMDArray.html#a3b97752cc115cb44d6339cdfad97b222">More...</a><br /></td></tr>
<tr class="separator:a3b97752cc115cb44d6339cdfad97b222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c7e7f8a659f3090b9366e75e256fdb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a37c7e7f8a659f3090b9366e75e256fdb">CopyFrom</a> (<a class="el" href="classGDALDataset.html">GDALDataset</a> *poSrcDS, const <a class="el" href="classGDALMDArray.html">GDALMDArray</a> *poSrcArray, bool bStrict, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &amp;nCurCost, const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> nTotalCost, GDALProgressFunc pfnProgress, void *pProgressData)</td></tr>
<tr class="memdesc:a37c7e7f8a659f3090b9366e75e256fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the content of an array into a new (generally empty) array.  <a href="classGDALMDArray.html#a37c7e7f8a659f3090b9366e75e256fdb">More...</a><br /></td></tr>
<tr class="separator:a37c7e7f8a659f3090b9366e75e256fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43462b586a92d4b4aac0e776030f93a9"><td class="memItemLeft" align="right" valign="top"><a id="a43462b586a92d4b4aac0e776030f93a9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a43462b586a92d4b4aac0e776030f93a9">IsWritable</a> () const =0</td></tr>
<tr class="memdesc:a43462b586a92d4b4aac0e776030f93a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether an array is writable. <br /></td></tr>
<tr class="separator:a43462b586a92d4b4aac0e776030f93a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb76059dc2cab066e99ffffded36546"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a5eb76059dc2cab066e99ffffded36546">GetFilename</a> () const =0</td></tr>
<tr class="memdesc:a5eb76059dc2cab066e99ffffded36546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the filename that contains that array.  <a href="classGDALMDArray.html#a5eb76059dc2cab066e99ffffded36546">More...</a><br /></td></tr>
<tr class="separator:a5eb76059dc2cab066e99ffffded36546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeef7e6e43553b8d35b39a7f031b79f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#abeeef7e6e43553b8d35b39a7f031b79f">GetStructuralInfo</a> () const</td></tr>
<tr class="memdesc:abeeef7e6e43553b8d35b39a7f031b79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return structural information on the array.  <a href="classGDALMDArray.html#abeeef7e6e43553b8d35b39a7f031b79f">More...</a><br /></td></tr>
<tr class="separator:abeeef7e6e43553b8d35b39a7f031b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e01f44fa53c78da06924994252fb62"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#af8e01f44fa53c78da06924994252fb62">GetUnit</a> () const</td></tr>
<tr class="memdesc:af8e01f44fa53c78da06924994252fb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the array unit.  <a href="classGDALMDArray.html#af8e01f44fa53c78da06924994252fb62">More...</a><br /></td></tr>
<tr class="separator:af8e01f44fa53c78da06924994252fb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a98fe64fd967cfe83c0d912d06bd745"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a0a98fe64fd967cfe83c0d912d06bd745">SetUnit</a> (const std::string &amp;osUnit)</td></tr>
<tr class="memdesc:a0a98fe64fd967cfe83c0d912d06bd745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the variable unit.  <a href="classGDALMDArray.html#a0a98fe64fd967cfe83c0d912d06bd745">More...</a><br /></td></tr>
<tr class="separator:a0a98fe64fd967cfe83c0d912d06bd745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff0099cee1c017f139024e801020bc9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#aaff0099cee1c017f139024e801020bc9">SetSpatialRef</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRS)</td></tr>
<tr class="memdesc:aaff0099cee1c017f139024e801020bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a spatial reference system object to the array.  <a href="classGDALMDArray.html#aaff0099cee1c017f139024e801020bc9">More...</a><br /></td></tr>
<tr class="separator:aaff0099cee1c017f139024e801020bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5cbdeba243c3590826ffd89f33172e"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a6f5cbdeba243c3590826ffd89f33172e">GetSpatialRef</a> () const</td></tr>
<tr class="memdesc:a6f5cbdeba243c3590826ffd89f33172e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the spatial reference system object associated with the array.  <a href="classGDALMDArray.html#a6f5cbdeba243c3590826ffd89f33172e">More...</a><br /></td></tr>
<tr class="separator:a6f5cbdeba243c3590826ffd89f33172e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6399f8a7f49bb0dafab283aa14f03029"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a6399f8a7f49bb0dafab283aa14f03029">GetRawNoDataValue</a> () const</td></tr>
<tr class="memdesc:a6399f8a7f49bb0dafab283aa14f03029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nodata value as a "raw" value.  <a href="classGDALMDArray.html#a6399f8a7f49bb0dafab283aa14f03029">More...</a><br /></td></tr>
<tr class="separator:a6399f8a7f49bb0dafab283aa14f03029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92b9b2782cd90c9f65dff0e1205be08"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ad92b9b2782cd90c9f65dff0e1205be08">GetNoDataValueAsDouble</a> (bool *pbHasNoData=nullptr) const</td></tr>
<tr class="memdesc:ad92b9b2782cd90c9f65dff0e1205be08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nodata value as a double.  <a href="classGDALMDArray.html#ad92b9b2782cd90c9f65dff0e1205be08">More...</a><br /></td></tr>
<tr class="separator:ad92b9b2782cd90c9f65dff0e1205be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa974f6a036af80469476f0db03b6d458"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#aa974f6a036af80469476f0db03b6d458">GetNoDataValueAsInt64</a> (bool *pbHasNoData=nullptr) const</td></tr>
<tr class="memdesc:aa974f6a036af80469476f0db03b6d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nodata value as a Int64.  <a href="classGDALMDArray.html#aa974f6a036af80469476f0db03b6d458">More...</a><br /></td></tr>
<tr class="separator:aa974f6a036af80469476f0db03b6d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af377a290359195de1bf9309b5752c748"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#af377a290359195de1bf9309b5752c748">GetNoDataValueAsUInt64</a> (bool *pbHasNoData=nullptr) const</td></tr>
<tr class="memdesc:af377a290359195de1bf9309b5752c748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nodata value as a UInt64.  <a href="classGDALMDArray.html#af377a290359195de1bf9309b5752c748">More...</a><br /></td></tr>
<tr class="separator:af377a290359195de1bf9309b5752c748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b1b33d01c41f75c88a0173979728d5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a55b1b33d01c41f75c88a0173979728d5">SetRawNoDataValue</a> (const void *pRawNoData)</td></tr>
<tr class="memdesc:a55b1b33d01c41f75c88a0173979728d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodata value as a "raw" value.  <a href="classGDALMDArray.html#a55b1b33d01c41f75c88a0173979728d5">More...</a><br /></td></tr>
<tr class="separator:a55b1b33d01c41f75c88a0173979728d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf673408d25ce00272e7b5a19707741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a2cf673408d25ce00272e7b5a19707741">SetNoDataValue</a> (double dfNoData)</td></tr>
<tr class="memdesc:a2cf673408d25ce00272e7b5a19707741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodata value as a double.  <a href="classGDALMDArray.html#a2cf673408d25ce00272e7b5a19707741">More...</a><br /></td></tr>
<tr class="separator:a2cf673408d25ce00272e7b5a19707741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8184a8e749daafdbbc3a582e9d9137d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ae8184a8e749daafdbbc3a582e9d9137d">SetNoDataValue</a> (int64_t nNoData)</td></tr>
<tr class="memdesc:ae8184a8e749daafdbbc3a582e9d9137d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodata value as a Int64.  <a href="classGDALMDArray.html#ae8184a8e749daafdbbc3a582e9d9137d">More...</a><br /></td></tr>
<tr class="separator:ae8184a8e749daafdbbc3a582e9d9137d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf0c54c46ebe944b3728b8c6f0033e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#adaf0c54c46ebe944b3728b8c6f0033e3">SetNoDataValue</a> (uint64_t nNoData)</td></tr>
<tr class="memdesc:adaf0c54c46ebe944b3728b8c6f0033e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodata value as a Int64.  <a href="classGDALMDArray.html#adaf0c54c46ebe944b3728b8c6f0033e3">More...</a><br /></td></tr>
<tr class="separator:adaf0c54c46ebe944b3728b8c6f0033e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4df538fcf9d62a5782b7c1a93aa142"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a8f4df538fcf9d62a5782b7c1a93aa142">Resize</a> (const std::vector&lt; <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &gt; &amp;anNewDimSizes, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a8f4df538fcf9d62a5782b7c1a93aa142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize an array to new dimensions.  <a href="classGDALMDArray.html#a8f4df538fcf9d62a5782b7c1a93aa142">More...</a><br /></td></tr>
<tr class="separator:a8f4df538fcf9d62a5782b7c1a93aa142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e687a08461bbe1320f3a81b0089675"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675">GetOffset</a> (bool *pbHasOffset=nullptr, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> *peStorageType=nullptr) const</td></tr>
<tr class="memdesc:a59e687a08461bbe1320f3a81b0089675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset value to apply to raw values.  <a href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675">More...</a><br /></td></tr>
<tr class="separator:a59e687a08461bbe1320f3a81b0089675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6898f31b8eae2294f4735469fc8b45"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45">GetScale</a> (bool *pbHasScale=nullptr, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> *peStorageType=nullptr) const</td></tr>
<tr class="memdesc:a6a6898f31b8eae2294f4735469fc8b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scale value to apply to raw values.  <a href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45">More...</a><br /></td></tr>
<tr class="separator:a6a6898f31b8eae2294f4735469fc8b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee99810d3b702c1b2827a6097ded2c49"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#aee99810d3b702c1b2827a6097ded2c49">SetOffset</a> (double dfOffset, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> eStorageType=<a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4aee80d7a2ef95f128685e66f6e1024cbe">GDT_Unknown</a>)</td></tr>
<tr class="memdesc:aee99810d3b702c1b2827a6097ded2c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the offset value to apply to raw values.  <a href="classGDALMDArray.html#aee99810d3b702c1b2827a6097ded2c49">More...</a><br /></td></tr>
<tr class="separator:aee99810d3b702c1b2827a6097ded2c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f70c7bc5d68bcf14b829fc3ba0d27c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a49f70c7bc5d68bcf14b829fc3ba0d27c">SetScale</a> (double dfScale, <a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> eStorageType=<a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4aee80d7a2ef95f128685e66f6e1024cbe">GDT_Unknown</a>)</td></tr>
<tr class="memdesc:a49f70c7bc5d68bcf14b829fc3ba0d27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scale value to apply to raw values.  <a href="classGDALMDArray.html#a49f70c7bc5d68bcf14b829fc3ba0d27c">More...</a><br /></td></tr>
<tr class="separator:a49f70c7bc5d68bcf14b829fc3ba0d27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b7d70b8dbc404e6a6cb0c257d47bdd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a14b7d70b8dbc404e6a6cb0c257d47bdd">GetView</a> (const std::string &amp;viewExpr) const</td></tr>
<tr class="memdesc:a14b7d70b8dbc404e6a6cb0c257d47bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of the array using slicing or field access.  <a href="classGDALMDArray.html#a14b7d70b8dbc404e6a6cb0c257d47bdd">More...</a><br /></td></tr>
<tr class="separator:a14b7d70b8dbc404e6a6cb0c257d47bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c88d3103cee12a1f9557bd1d3fe1ab7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a6c88d3103cee12a1f9557bd1d3fe1ab7">operator[]</a> (const std::string &amp;fieldName) const</td></tr>
<tr class="memdesc:a6c88d3103cee12a1f9557bd1d3fe1ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of the array using field access.  <a href="classGDALMDArray.html#a6c88d3103cee12a1f9557bd1d3fe1ab7">More...</a><br /></td></tr>
<tr class="separator:a6c88d3103cee12a1f9557bd1d3fe1ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ecce53200a2e6dfd54fdecbd4187b3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a77ecce53200a2e6dfd54fdecbd4187b3">at</a> (<a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> idx, GUInt64VarArg... tail) const</td></tr>
<tr class="memdesc:a77ecce53200a2e6dfd54fdecbd4187b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of the array using integer indexing.  <a href="classGDALMDArray.html#a77ecce53200a2e6dfd54fdecbd4187b3">More...</a><br /></td></tr>
<tr class="separator:a77ecce53200a2e6dfd54fdecbd4187b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2e2f9a792329c7e0fe1b35bf756882"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#acb2e2f9a792329c7e0fe1b35bf756882">Transpose</a> (const std::vector&lt; int &gt; &amp;anMapNewAxisToOldAxis) const</td></tr>
<tr class="memdesc:acb2e2f9a792329c7e0fe1b35bf756882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of the array whose axis have been reordered.  <a href="classGDALMDArray.html#acb2e2f9a792329c7e0fe1b35bf756882">More...</a><br /></td></tr>
<tr class="separator:acb2e2f9a792329c7e0fe1b35bf756882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2efbbbfa7596b0dd7d96f5c5f3abaf6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ab2efbbbfa7596b0dd7d96f5c5f3abaf6">GetUnscaled</a> (double dfOverriddenScale=std::numeric_limits&lt; double &gt;::quiet_NaN(), double dfOverriddenOffset=std::numeric_limits&lt; double &gt;::quiet_NaN(), double dfOverriddenDstNodata=std::numeric_limits&lt; double &gt;::quiet_NaN()) const</td></tr>
<tr class="memdesc:ab2efbbbfa7596b0dd7d96f5c5f3abaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that is the unscaled version of the current one.  <a href="classGDALMDArray.html#ab2efbbbfa7596b0dd7d96f5c5f3abaf6">More...</a><br /></td></tr>
<tr class="separator:ab2efbbbfa7596b0dd7d96f5c5f3abaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f5ba8fb8dab129d6813fb8cda59365"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#aa4f5ba8fb8dab129d6813fb8cda59365">GetMask</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) const</td></tr>
<tr class="memdesc:aa4f5ba8fb8dab129d6813fb8cda59365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that is a mask for the current array.  <a href="classGDALMDArray.html#aa4f5ba8fb8dab129d6813fb8cda59365">More...</a><br /></td></tr>
<tr class="separator:aa4f5ba8fb8dab129d6813fb8cda59365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960b1192e25e59b343db87628af71e42"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a960b1192e25e59b343db87628af71e42">GetResampled</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALDimension.html">GDALDimension</a> &gt;&gt; &amp;apoNewDims, <a class="el" href="gdal_8h.html#a640ada511cbddeefac67c548e009d5ac">GDALRIOResampleAlg</a> resampleAlg, const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poTargetSRS, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) const</td></tr>
<tr class="memdesc:a960b1192e25e59b343db87628af71e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array that is a resampled / reprojected view of the current array.  <a href="classGDALMDArray.html#a960b1192e25e59b343db87628af71e42">More...</a><br /></td></tr>
<tr class="separator:a960b1192e25e59b343db87628af71e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967cc1cfafedebdc2cc50e20110038ba"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a967cc1cfafedebdc2cc50e20110038ba">GetGridded</a> (const std::string &amp;osGridOptions, const std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; &amp;poXArray=nullptr, const std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; &amp;poYArray=nullptr, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a967cc1cfafedebdc2cc50e20110038ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a gridded array from scattered point data, that is from an array whose last dimension is the indexing variable of X and Y arrays.  <a href="classGDALMDArray.html#a967cc1cfafedebdc2cc50e20110038ba">More...</a><br /></td></tr>
<tr class="separator:a967cc1cfafedebdc2cc50e20110038ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94676b7e486be06964f740f9f88a7df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGDALDataset.html">GDALDataset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#aa94676b7e486be06964f740f9f88a7df">AsClassicDataset</a> (size_t iXDim, size_t iYDim, const std::shared_ptr&lt; <a class="el" href="classGDALGroup.html">GDALGroup</a> &gt; &amp;poRootGroup=nullptr, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:aa94676b7e486be06964f740f9f88a7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view of this array as a "classic" <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> (ie 2D)  <a href="classGDALMDArray.html#aa94676b7e486be06964f740f9f88a7df">More...</a><br /></td></tr>
<tr class="separator:aa94676b7e486be06964f740f9f88a7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad965a69ff2fa6433f2740f0386918"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#af7ad965a69ff2fa6433f2740f0386918">GetStatistics</a> (bool bApproxOK, bool bForce, double *pdfMin, double *pdfMax, double *pdfMean, double *padfStdDev, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *pnValidCount, GDALProgressFunc pfnProgress, void *pProgressData)</td></tr>
<tr class="memdesc:af7ad965a69ff2fa6433f2740f0386918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch statistics.  <a href="classGDALMDArray.html#af7ad965a69ff2fa6433f2740f0386918">More...</a><br /></td></tr>
<tr class="separator:af7ad965a69ff2fa6433f2740f0386918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3565413aa3a9b203f3c827a854e0f486"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a3565413aa3a9b203f3c827a854e0f486">ComputeStatistics</a> (bool bApproxOK, double *pdfMin, double *pdfMax, double *pdfMean, double *pdfStdDev, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *pnValidCount, GDALProgressFunc, void *pProgressData, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a3565413aa3a9b203f3c827a854e0f486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute statistics.  <a href="classGDALMDArray.html#a3565413aa3a9b203f3c827a854e0f486">More...</a><br /></td></tr>
<tr class="separator:a3565413aa3a9b203f3c827a854e0f486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a310b8f4e03ff1de11bd4421cabafe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a94a310b8f4e03ff1de11bd4421cabafe">ClearStatistics</a> ()</td></tr>
<tr class="memdesc:a94a310b8f4e03ff1de11bd4421cabafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear statistics.  <a href="classGDALMDArray.html#a94a310b8f4e03ff1de11bd4421cabafe">More...</a><br /></td></tr>
<tr class="separator:a94a310b8f4e03ff1de11bd4421cabafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb684035870bc9a46fa0ea1aaabb336"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#a3fb684035870bc9a46fa0ea1aaabb336">GetCoordinateVariables</a> () const</td></tr>
<tr class="memdesc:a3fb684035870bc9a46fa0ea1aaabb336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return coordinate variables.  <a href="classGDALMDArray.html#a3fb684035870bc9a46fa0ea1aaabb336">More...</a><br /></td></tr>
<tr class="separator:a3fb684035870bc9a46fa0ea1aaabb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10845647de6e978d858938d64ea1c9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#aa10845647de6e978d858938d64ea1c9c">AdviseRead</a> (const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *arrayStartIdx, const size_t *count, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:aa10845647de6e978d858938d64ea1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advise driver of upcoming read requests.  <a href="classGDALMDArray.html#aa10845647de6e978d858938d64ea1c9c">More...</a><br /></td></tr>
<tr class="separator:aa10845647de6e978d858938d64ea1c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868846e9f958c2bcda89276d92e5f15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ad868846e9f958c2bcda89276d92e5f15">IsRegularlySpaced</a> (double &amp;dfStart, double &amp;dfIncrement) const</td></tr>
<tr class="memdesc:ad868846e9f958c2bcda89276d92e5f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether an array is a 1D regularly spaced array.  <a href="classGDALMDArray.html#ad868846e9f958c2bcda89276d92e5f15">More...</a><br /></td></tr>
<tr class="separator:ad868846e9f958c2bcda89276d92e5f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03cb916515cd7b1e04d9131e7c4f959"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ad03cb916515cd7b1e04d9131e7c4f959">GuessGeoTransform</a> (size_t nDimX, size_t nDimY, bool bPixelIsPoint, double adfGeoTransform[6]) const</td></tr>
<tr class="memdesc:ad03cb916515cd7b1e04d9131e7c4f959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether 2 specified dimensions form a geotransform.  <a href="classGDALMDArray.html#ad03cb916515cd7b1e04d9131e7c4f959">More...</a><br /></td></tr>
<tr class="separator:ad03cb916515cd7b1e04d9131e7c4f959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5411558ab4c265b55cfe27fae2cd168"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#af5411558ab4c265b55cfe27fae2cd168">Cache</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:af5411558ab4c265b55cfe27fae2cd168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache the content of the array into an auxiliary filename.  <a href="classGDALMDArray.html#af5411558ab4c265b55cfe27fae2cd168">More...</a><br /></td></tr>
<tr class="separator:af5411558ab4c265b55cfe27fae2cd168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f5fb5d0088b9e8c8eec261798ae729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ad8f5fb5d0088b9e8c8eec261798ae729">Read</a> (const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *arrayStartIdx, const size_t *count, const <a class="el" href="cpl__port_8h.html#a6e5dffdc7f562a64c72c486fe3706847">GInt64</a> *arrayStep, const <a class="el" href="cpl__port_8h.html#a266f5ca4950b3381e59593912f0f3f9c">GPtrDiff_t</a> *bufferStride, const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;bufferDataType, void *pDstBuffer, const void *pDstBufferAllocStart=nullptr, size_t nDstBufferAllocSize=0) const override</td></tr>
<tr class="memdesc:ad8f5fb5d0088b9e8c8eec261798ae729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read part or totality of a multidimensional array or attribute.  <a href="classGDALMDArray.html#ad8f5fb5d0088b9e8c8eec261798ae729">More...</a><br /></td></tr>
<tr class="separator:ad8f5fb5d0088b9e8c8eec261798ae729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5643496dc322d0368e75e652235f103"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classGDALGroup.html">GDALGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMDArray.html#ad5643496dc322d0368e75e652235f103">GetRootGroup</a> () const</td></tr>
<tr class="memdesc:ad5643496dc322d0368e75e652235f103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root group to which this arrays belongs too.  <a href="classGDALMDArray.html#ad5643496dc322d0368e75e652235f103">More...</a><br /></td></tr>
<tr class="separator:ad5643496dc322d0368e75e652235f103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58984ee0ddf3b263dcc6338475d1fbe"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#ab58984ee0ddf3b263dcc6338475d1fbe">GetName</a> () const</td></tr>
<tr class="memdesc:ab58984ee0ddf3b263dcc6338475d1fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of an array or attribute.  <a href="classGDALAbstractMDArray.html#ab58984ee0ddf3b263dcc6338475d1fbe">More...</a><br /></td></tr>
<tr class="separator:ab58984ee0ddf3b263dcc6338475d1fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e06c021e92922f0536ec7cb43ade30"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#ab4e06c021e92922f0536ec7cb43ade30">GetFullName</a> () const</td></tr>
<tr class="memdesc:ab4e06c021e92922f0536ec7cb43ade30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of an array or attribute.  <a href="classGDALAbstractMDArray.html#ab4e06c021e92922f0536ec7cb43ade30">More...</a><br /></td></tr>
<tr class="separator:ab4e06c021e92922f0536ec7cb43ade30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa853ea2f4b29db0ef955ef2da415b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a02aa853ea2f4b29db0ef955ef2da415b">GetTotalElementsCount</a> () const</td></tr>
<tr class="memdesc:a02aa853ea2f4b29db0ef955ef2da415b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of values in the array.  <a href="classGDALAbstractMDArray.html#a02aa853ea2f4b29db0ef955ef2da415b">More...</a><br /></td></tr>
<tr class="separator:a02aa853ea2f4b29db0ef955ef2da415b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad187a612ebbf1369954af77ad57f7ade"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade">GetDimensionCount</a> () const</td></tr>
<tr class="memdesc:ad187a612ebbf1369954af77ad57f7ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of dimensions.  <a href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade">More...</a><br /></td></tr>
<tr class="separator:ad187a612ebbf1369954af77ad57f7ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b92edc85e26e1354e1ba52a67df9c4"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALDimension.html">GDALDimension</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a64b92edc85e26e1354e1ba52a67df9c4">GetDimensions</a> () const =0</td></tr>
<tr class="memdesc:a64b92edc85e26e1354e1ba52a67df9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimensions of an attribute/array.  <a href="classGDALAbstractMDArray.html#a64b92edc85e26e1354e1ba52a67df9c4">More...</a><br /></td></tr>
<tr class="separator:a64b92edc85e26e1354e1ba52a67df9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fe433024efc083ddf2e7d1c25a6428"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428">GetDataType</a> () const =0</td></tr>
<tr class="memdesc:a79fe433024efc083ddf2e7d1c25a6428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data type of an attribute/array.  <a href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428">More...</a><br /></td></tr>
<tr class="separator:a79fe433024efc083ddf2e7d1c25a6428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58329a5ad0abf756fe2d3a10d49e0cc2"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a58329a5ad0abf756fe2d3a10d49e0cc2">GetBlockSize</a> () const</td></tr>
<tr class="memdesc:a58329a5ad0abf756fe2d3a10d49e0cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the "natural" block size of the array along all dimensions.  <a href="classGDALAbstractMDArray.html#a58329a5ad0abf756fe2d3a10d49e0cc2">More...</a><br /></td></tr>
<tr class="separator:a58329a5ad0abf756fe2d3a10d49e0cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654efba82b40af5063a275292fcfb854"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a654efba82b40af5063a275292fcfb854">GetProcessingChunkSize</a> (size_t nMaxChunkMemory) const</td></tr>
<tr class="memdesc:a654efba82b40af5063a275292fcfb854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an optimal chunk size for read/write operations, given the natural block size and memory constraints specified.  <a href="classGDALAbstractMDArray.html#a654efba82b40af5063a275292fcfb854">More...</a><br /></td></tr>
<tr class="separator:a654efba82b40af5063a275292fcfb854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91005189ff493f595ddd4ba446cc216a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a91005189ff493f595ddd4ba446cc216a">ProcessPerChunk</a> (const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *arrayStartIdx, const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *count, const size_t *chunkSize, <a class="el" href="classGDALAbstractMDArray.html#a96c310c2baf7f653c090e38186393e65">FuncProcessPerChunkType</a> pfnFunc, void *pUserData)</td></tr>
<tr class="memdesc:a91005189ff493f595ddd4ba446cc216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a user-provided function to operate on an array chunk by chunk.  <a href="classGDALAbstractMDArray.html#a91005189ff493f595ddd4ba446cc216a">More...</a><br /></td></tr>
<tr class="separator:a91005189ff493f595ddd4ba446cc216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebbed7c69603f7b3ce4e8b2adf416f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#afebbed7c69603f7b3ce4e8b2adf416f9">Write</a> (const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *arrayStartIdx, const size_t *count, const <a class="el" href="cpl__port_8h.html#a6e5dffdc7f562a64c72c486fe3706847">GInt64</a> *arrayStep, const <a class="el" href="cpl__port_8h.html#a266f5ca4950b3381e59593912f0f3f9c">GPtrDiff_t</a> *bufferStride, const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;bufferDataType, const void *pSrcBuffer, const void *pSrcBufferAllocStart=nullptr, size_t nSrcBufferAllocSize=0)</td></tr>
<tr class="memdesc:afebbed7c69603f7b3ce4e8b2adf416f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write part or totality of a multidimensional array or attribute.  <a href="classGDALAbstractMDArray.html#afebbed7c69603f7b3ce4e8b2adf416f9">More...</a><br /></td></tr>
<tr class="separator:afebbed7c69603f7b3ce4e8b2adf416f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371e0a4f2268c8c95e5490663671f709"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALAbstractMDArray.html#a371e0a4f2268c8c95e5490663671f709">Rename</a> (const std::string &amp;osNewName)</td></tr>
<tr class="memdesc:a371e0a4f2268c8c95e5490663671f709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the attribute/array.  <a href="classGDALAbstractMDArray.html#a371e0a4f2268c8c95e5490663671f709">More...</a><br /></td></tr>
<tr class="separator:a371e0a4f2268c8c95e5490663671f709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5570cabe2639d83a7eacc0b3a4bd50"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALIHasAttribute.html#a1f5570cabe2639d83a7eacc0b3a4bd50">GetAttribute</a> (const std::string &amp;osName) const</td></tr>
<tr class="memdesc:a1f5570cabe2639d83a7eacc0b3a4bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute by its name.  <a href="classGDALIHasAttribute.html#a1f5570cabe2639d83a7eacc0b3a4bd50">More...</a><br /></td></tr>
<tr class="separator:a1f5570cabe2639d83a7eacc0b3a4bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc692f8402e064eb39a3cc2603d66fb"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALIHasAttribute.html#a9cc692f8402e064eb39a3cc2603d66fb">GetAttributes</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a9cc692f8402e064eb39a3cc2603d66fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of attributes contained in a <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> or <a class="el" href="classGDALGroup.html" title="Class modeling a named container of GDALAttribute, GDALMDArray, OGRLayer or other GDALGroup.">GDALGroup</a>.  <a href="classGDALIHasAttribute.html#a9cc692f8402e064eb39a3cc2603d66fb">More...</a><br /></td></tr>
<tr class="separator:a9cc692f8402e064eb39a3cc2603d66fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c8ec8e1a54322818357e3f8a4a52df"><td class="memItemLeft" align="right" valign="top">virtual std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALIHasAttribute.html#a17c8ec8e1a54322818357e3f8a4a52df">CreateAttribute</a> (const std::string &amp;osName, const std::vector&lt; <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &gt; &amp;anDimensions, const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;oDataType, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr)</td></tr>
<tr class="memdesc:a17c8ec8e1a54322818357e3f8a4a52df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an attribute within a <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> or <a class="el" href="classGDALGroup.html" title="Class modeling a named container of GDALAttribute, GDALMDArray, OGRLayer or other GDALGroup.">GDALGroup</a>.  <a href="classGDALIHasAttribute.html#a17c8ec8e1a54322818357e3f8a4a52df">More...</a><br /></td></tr>
<tr class="separator:a17c8ec8e1a54322818357e3f8a4a52df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfa2aed3311416eb075e1d3c07dc574"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALIHasAttribute.html#abcfa2aed3311416eb075e1d3c07dc574">DeleteAttribute</a> (const std::string &amp;osName, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr)</td></tr>
<tr class="memdesc:abcfa2aed3311416eb075e1d3c07dc574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an attribute from a <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> or <a class="el" href="classGDALGroup.html" title="Class modeling a named container of GDALAttribute, GDALMDArray, OGRLayer or other GDALGroup.">GDALGroup</a>.  <a href="classGDALIHasAttribute.html#abcfa2aed3311416eb075e1d3c07dc574">More...</a><br /></td></tr>
<tr class="separator:abcfa2aed3311416eb075e1d3c07dc574"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af66ddce61feec7ef79eebf14c7451b8c"><td class="memItemLeft" align="right" valign="top"><a id="af66ddce61feec7ef79eebf14c7451b8c"></a>
std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALIHasAttribute.html#af66ddce61feec7ef79eebf14c7451b8c">GetAttributeFromAttributes</a> (const std::string &amp;osName) const</td></tr>
<tr class="memdesc:af66ddce61feec7ef79eebf14c7451b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible fallback implementation for <a class="el" href="classGDALIHasAttribute.html#a1f5570cabe2639d83a7eacc0b3a4bd50" title="Return an attribute by its name.">GetAttribute()</a> using <a class="el" href="classGDALIHasAttribute.html#a9cc692f8402e064eb39a3cc2603d66fb" title="Return the list of attributes contained in a GDALMDArray or GDALGroup.">GetAttributes()</a>. <br /></td></tr>
<tr class="separator:af66ddce61feec7ef79eebf14c7451b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:add065ee4c1ce6938cf28a33517cb6dab"><td class="memItemLeft" align="right" valign="top"><a id="add065ee4c1ce6938cf28a33517cb6dab"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GDALMDArrayResampled</b></td></tr>
<tr class="separator:add065ee4c1ce6938cf28a33517cb6dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class modeling a multi-dimensional array. </p>
<p>It has a name, values organized as an array and a list of <a class="el" href="classGDALAttribute.html" title="Class modeling an attribute that has a name, a value and a type, and is typically used to describe a ...">GDALAttribute</a>.</p>
<p>This is based on the <a href="https://portal.opengeospatial.org/files/81716#_hdf5_dataset">HDF5 dataset concept</a></p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a96c310c2baf7f653c090e38186393e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c310c2baf7f653c090e38186393e65">&#9670;&nbsp;</a></span>FuncProcessPerChunkType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* GDALAbstractMDArray::FuncProcessPerChunkType) (<a class="el" href="classGDALAbstractMDArray.html">GDALAbstractMDArray</a> *array, const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *chunkArrayStartIdx, const size_t *chunkCount, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> iCurChunk, <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> nChunkCount, void *pUserData)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of pfnFunc argument of <a class="el" href="classGDALAbstractMDArray.html#a91005189ff493f595ddd4ba446cc216a" title="Call a user-provided function to operate on an array chunk by chunk.">ProcessPerChunk()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array on which ProcessPerChunk was called. </td></tr>
    <tr><td class="paramname">chunkArrayStartIdx</td><td>Values representing the starting index to use in each dimension (in [0, aoDims[i].GetSize()-1] range) for the current chunk. Will be nullptr for a zero-dimensional array. </td></tr>
    <tr><td class="paramname">chunkCount</td><td>Values representing the number of values to use in each dimension for the current chunk. Will be nullptr for a zero-dimensional array. </td></tr>
    <tr><td class="paramname">iCurChunk</td><td>Number of current chunk being processed. In [1, nChunkCount] range. </td></tr>
    <tr><td class="paramname">nChunkCount</td><td>Total number of chunks to process. </td></tr>
    <tr><td class="paramname">pUserData</td><td>User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return true in case of success. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa10845647de6e978d858938d64ea1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10845647de6e978d858938d64ea1c9c">&#9670;&nbsp;</a></span>AdviseRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::AdviseRead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>arrayStartIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advise driver of upcoming read requests. </p>
<p>Some GDAL drivers operate more efficiently if they know in advance what set of upcoming read requests will be made. The <a class="el" href="classGDALMDArray.html#aa10845647de6e978d858938d64ea1c9c" title="Advise driver of upcoming read requests.">AdviseRead()</a> method allows an application to notify the driver of the region of interest.</p>
<p>Many drivers just ignore the <a class="el" href="classGDALMDArray.html#aa10845647de6e978d858938d64ea1c9c" title="Advise driver of upcoming read requests.">AdviseRead()</a> call, but it can dramatically accelerate access via some drivers. One such case is when reading through a DAP dataset with the netCDF driver (a in-memory cache array is then created with the region of interest defined by <a class="el" href="classGDALMDArray.html#aa10845647de6e978d858938d64ea1c9c" title="Advise driver of upcoming read requests.">AdviseRead()</a>)</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#ad748492861b2a108ab87e47888ec1399" title="Advise driver of upcoming read requests.">GDALMDArrayAdviseRead()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayStartIdx</td><td>Values representing the starting index to read in each dimension (in [0, aoDims[i].GetSize()-1] range). Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Can be nullptr as a synonymous for [0 for i in range(<a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> ]</td></tr>
    <tr><td class="paramname">count</td><td>Values representing the number of values to extract in each dimension. Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Can be nullptr as a synonymous for [ aoDims[i].GetSize() - arrayStartIdx[i] for i in range(<a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> ]</td></tr>
    <tr><td class="paramname">papszOptions</td><td>Driver specific options, or nullptr. Consult driver documentation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success (ignoring the advice is a success)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="aa94676b7e486be06964f740f9f88a7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94676b7e486be06964f740f9f88a7df">&#9670;&nbsp;</a></span>AsClassicDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDALDataset.html">GDALDataset</a> * GDALMDArray::AsClassicDataset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iXDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iYDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classGDALGroup.html">GDALGroup</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poRootGroup</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a view of this array as a "classic" <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> (ie 2D) </p>
<p>In the case of &gt; 2D arrays, additional dimensions will be represented as raster bands.</p>
<p>The "reverse" method is <a class="el" href="classGDALRasterBand.html#ac7a295ea7fcf39223133ae7da075fafe" title="Return a view of this raster band as a 2D multidimensional GDALMDArray.">GDALRasterBand::AsMDArray()</a>.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#aa924e231ebd5dcc3807f366172bbfc37" title="Return a view of this array as a &quot;classic&quot; GDALDataset (ie 2D)">GDALMDArrayAsClassicDataset()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iXDim</td><td>Index of the dimension that will be used as the X/width axis. </td></tr>
    <tr><td class="paramname">iYDim</td><td>Index of the dimension that will be used as the Y/height axis. Ignored if the dimension count is 1. </td></tr>
    <tr><td class="paramname">poRootGroup</td><td>(Added in GDAL 3.8) Root group. Used with the BAND_METADATA option. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>(Added in GDAL 3.8) Null-terminated list of options, or nullptr. Current supported options are: <ul>
<li>
<p class="startli">BAND_METADATA: JSON serialized array defining which arrays of the poRootGroup, indexed by non-X and Y dimensions, should be mapped as band metadata items. Each array item should be an object with the following members:</p><ul>
<li>"array": full name of a band parameter array. Such array must be a one dimensional array, and its dimension must be one of the dimensions of the array on which the method is called (excluding the X and Y dimensons).</li>
<li>"item_name": band metadata item name</li>
<li>"item_value": (optional) String, where "%[x][.y]f", "%[x][.y]g" or "%s" printf-like formatting can be used to format the corresponding value of the parameter array. The percentage character should be repeated: "%%" "${attribute_name}" can also be used to include the value of an attribute for the array. If "item_value" is not provided, a default formatting of the value will be applied.</li>
</ul>
<p class="endli">Example: [ { "array": "/sensor_band_parameters/wavelengths", "item_name": "WAVELENGTH", "item_value": "%.1f ${units}" }, { "array": "/sensor_band_parameters/fwhm", "item_name": "FWHM" }, { "array": "/sensor_band_parameters/fwhm", "item_name": "FWHM_UNIT", "item_value": "${units}" } ]  </p>
</li>
<li>
LOAD_EXTRA_DIM_METADATA_DELAY: Maximum delay in seconds allowed to set the DIM_{dimname}_VALUE band metadata items from the indexing variable of the dimensions. Default value is 5. 'unlimited' can be used to mean unlimited delay. Can also be defined globally with the GDAL_LOAD_EXTRA_DIM_METADATA_DELAY configuration option. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> that must be freed with <a class="el" href="gdal_8h.html#a7c728fbbef87fe4929e6dd418f4035fa" title="Close GDAL dataset.">GDALClose()</a>, or nullptr </dd></dl>

</div>
</div>
<a id="a77ecce53200a2e6dfd54fdecbd4187b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ecce53200a2e6dfd54fdecbd4187b3">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classGDALMDArray.html">GDALMDArray</a>&gt; GDALMDArray::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GUInt64VarArg...&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a view of the array using integer indexing. </p>
<p>Equivalent of GetView("[indices_0,indices_1,.....,indices_last]")</p>
<p>Example: </p><div class="fragment"><div class="line">ar-&gt;at(0,3,2)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af5411558ab4c265b55cfe27fae2cd168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5411558ab4c265b55cfe27fae2cd168">&#9670;&nbsp;</a></span>Cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::Cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache the content of the array into an auxiliary filename. </p>
<p>The main purpose of this method is to be able to cache views that are expensive to compute, such as transposed arrays.</p>
<p>The array will be stored in a file whose name is the one of <a class="el" href="classGDALMDArray.html#a5eb76059dc2cab066e99ffffded36546" title="Return the filename that contains that array.">GetFilename()</a>, with an extra .gmac extension (stands for GDAL Multidimensional Array Cache). The cache is a netCDF dataset.</p>
<p>If the .gmac file cannot be written next to the dataset, the GDAL_PAM_PROXY_DIR will be used, if set, to write the cache file into that directory.</p>
<p>The <a class="el" href="classGDALMDArray.html#ad8f5fb5d0088b9e8c8eec261798ae729" title="Read part or totality of a multidimensional array or attribute.">GDALMDArray::Read()</a> method will automatically use the cache when it exists. There is no timestamp checks between the source array and the cached array. If the source arrays changes, the cache must be manually deleted.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a3fd874c5600f5b695269ad3ce4e76ca6" title="Cache the content of the array into an auxiliary filename.">GDALMDArrayCache()</a></p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: optionally implemented.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>List of options, null terminated, or NULL. Currently the only option supported is BLOCKSIZE=bs0,bs1,...,bsN to specify the block size of the cached array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="a94a310b8f4e03ff1de11bd4421cabafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a310b8f4e03ff1de11bd4421cabafe">&#9670;&nbsp;</a></span>ClearStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GDALMDArray::ClearStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear statistics. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4 </dd></dl>

</div>
</div>
<a id="a3565413aa3a9b203f3c827a854e0f486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3565413aa3a9b203f3c827a854e0f486">&#9670;&nbsp;</a></span>ComputeStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::ComputeStatistics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bApproxOK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfStdDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>pnValidCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute statistics. </p>
<p>Returns the minimum, maximum, mean and standard deviation of all pixel values in this array.</p>
<p>Pixels taken into account in statistics are those whose mask value (as determined by <a class="el" href="classGDALMDArray.html#aa4f5ba8fb8dab129d6813fb8cda59365" title="Return an array that is a mask for the current array.">GetMask()</a>) is non-zero.</p>
<p>Once computed, the statistics will generally be "set" back on the owing dataset.</p>
<p>Cached statistics can be cleared with <a class="el" href="classGDALDataset.html#a6a805dee10572e805aa42c26bc43e97c" title="Clear statistics.">GDALDataset::ClearStatistics()</a>.</p>
<p>This method is the same as the C functions <a class="el" href="gdal_8h.html#aee63cf0bc0a0f74f11d608a599381d3b" title="Compute statistics.">GDALMDArrayComputeStatistics()</a>. and <a class="el" href="gdal_8h.html#a61b6cbc46b0698ed9fc6aa104aba8354" title="Compute statistics.">GDALMDArrayComputeStatisticsEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bApproxOK</td><td>Currently ignored. In the future, should be set to true if statistics on the whole array are wished, or to false if a subset of it may be used.</td></tr>
    <tr><td class="paramname">pdfMin</td><td>Location into which to load image minimum (may be NULL).</td></tr>
    <tr><td class="paramname">pdfMax</td><td>Location into which to load image maximum (may be NULL).-</td></tr>
    <tr><td class="paramname">pdfMean</td><td>Location into which to load image mean (may be NULL).</td></tr>
    <tr><td class="paramname">pdfStdDev</td><td>Location into which to load image standard deviation (may be NULL).</td></tr>
    <tr><td class="paramname">pnValidCount</td><td>Number of samples whose value is different from the nodata value. (may be NULL)</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a function to call to report progress, or NULL.</td></tr>
    <tr><td class="paramname">pProgressData</td><td>application data to pass to the progress function.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options, of NULL. Added in 3.8. Options are driver specific. For now the netCDF and Zarr drivers recognize UPDATE_METADATA=YES, whose effect is to add or update the actual_range attribute with the computed min/max, only if done on the full array, in non approximate mode, and the dataset is opened in update mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="a37c7e7f8a659f3090b9366e75e256fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c7e7f8a659f3090b9366e75e256fdb">&#9670;&nbsp;</a></span>CopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::CopyFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGDALDataset.html">GDALDataset</a> *&#160;</td>
          <td class="paramname"><em>poSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDALMDArray.html">GDALMDArray</a> *&#160;</td>
          <td class="paramname"><em>poSrcArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStrict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &amp;&#160;</td>
          <td class="paramname"><em>nCurCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a>&#160;</td>
          <td class="paramname"><em>nTotalCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the content of an array into a new (generally empty) array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSrcDS</td><td>Source dataset. Might be nullptr (but for correct behavior of some output drivers this is not recommended) </td></tr>
    <tr><td class="paramname">poSrcArray</td><td>Source array. Should NOT be nullptr. </td></tr>
    <tr><td class="paramname">bStrict</td><td>Whether to enable stict mode. In strict mode, any error will stop the copy. In relaxed mode, the copy will be attempted to be pursued. </td></tr>
    <tr><td class="paramname">nCurCost</td><td>Should be provided as a variable initially set to 0. </td></tr>
    <tr><td class="paramname">nTotalCost</td><td>Total cost from <a class="el" href="classGDALMDArray.html#a3b97752cc115cb44d6339cdfad97b222" title="Return a total &quot;cost&quot; to copy the array.">GetTotalCopyCost()</a>. </td></tr>
    <tr><td class="paramname">pfnProgress</td><td>Progress callback, or nullptr. </td></tr>
    <tr><td class="paramname">pProgressData</td><td>Progress user data, or nulptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success (or partial success if bStrict == false). </dd></dl>

</div>
</div>
<a id="a17c8ec8e1a54322818357e3f8a4a52df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c8ec8e1a54322818357e3f8a4a52df">&#9670;&nbsp;</a></span>CreateAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt; GDALIHasAttribute::CreateAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>anDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;&#160;</td>
          <td class="paramname"><em>oDataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an attribute within a <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> or <a class="el" href="classGDALGroup.html" title="Class modeling a named container of GDALAttribute, GDALMDArray, OGRLayer or other GDALGroup.">GDALGroup</a>. </p>
<p>The attribute might not be "physically" created until a value is written into it.</p>
<p>Optionally implemented.</p>
<p>Drivers known to implement it: MEM, netCDF</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a9376a0d012da9ab2a9af580463cecd92" title="Create a attribute within a group.">GDALGroupCreateAttribute()</a> or <a class="el" href="gdal_8h.html#a3108d846ede94ed3c1aa5e5939e97fff" title="Create a attribute within an array.">GDALMDArrayCreateAttribute()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osName</td><td>Attribute name. </td></tr>
    <tr><td class="paramname">anDimensions</td><td>List of dimension sizes, ordered from the slowest varying dimension first to the fastest varying dimension last. Empty for a scalar attribute (common case) </td></tr>
    <tr><td class="paramname">oDataType</td><td>Attribute data type. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Driver specific options determining how the attribute. should be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new attribute, or nullptr if case of error </dd></dl>

</div>
</div>
<a id="abcfa2aed3311416eb075e1d3c07dc574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfa2aed3311416eb075e1d3c07dc574">&#9670;&nbsp;</a></span>DeleteAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALIHasAttribute::DeleteAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an attribute from a <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> or <a class="el" href="classGDALGroup.html" title="Class modeling a named container of GDALAttribute, GDALMDArray, OGRLayer or other GDALGroup.">GDALGroup</a>. </p>
<p>Optionally implemented.</p>
<p>After this call, if a previously obtained instance of the deleted object is still alive, no method other than for freeing it should be invoked.</p>
<p>Drivers known to implement it: MEM, netCDF</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a300e5800259be49e9ee5192c1a05a44f" title="Delete an attribute from a group.">GDALGroupDeleteAttribute()</a> or <a class="el" href="gdal_8h.html#acdfe3c0ca791ba4fc3667e656148e2c3" title="Delete an attribute from an array.">GDALMDArrayDeleteAttribute()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osName</td><td>Attribute name. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Driver specific options determining how the attribute. should be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a1f5570cabe2639d83a7eacc0b3a4bd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5570cabe2639d83a7eacc0b3a4bd50">&#9670;&nbsp;</a></span>GetAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt; GDALIHasAttribute::GetAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an attribute by its name. </p>
<p>If the attribute does not exist, nullptr should be silently returned.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method will fallback to <a class="el" href="classGDALIHasAttribute.html#af66ddce61feec7ef79eebf14c7451b8c" title="Possible fallback implementation for GetAttribute() using GetAttributes().">GetAttributeFromAttributes()</a> is not explicitly implemented</dd></dl>
<p>Drivers known to implement it for groups and arrays: MEM, netCDF.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a12b3c088fec35e02bd508e237c11ad96" title="Return an attribute by its name.">GDALGroupGetAttribute()</a> or <a class="el" href="gdal_8h.html#a6eb2e2b207480d05b5d17f7359eba9d2" title="Return an attribute by its name.">GDALMDArrayGetAttribute()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osName</td><td>Attribute name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the attribute, or nullptr if it does not exist or an error occurred. </dd></dl>

</div>
</div>
<a id="a9cc692f8402e064eb39a3cc2603d66fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc692f8402e064eb39a3cc2603d66fb">&#9670;&nbsp;</a></span>GetAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALAttribute.html">GDALAttribute</a> &gt; &gt; GDALIHasAttribute::GetAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the list of attributes contained in a <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> or <a class="el" href="classGDALGroup.html" title="Class modeling a named container of GDALAttribute, GDALMDArray, OGRLayer or other GDALGroup.">GDALGroup</a>. </p>
<p>If the attribute does not exist, nullptr should be silently returned.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: optionally implemented. If implemented, <a class="el" href="classGDALIHasAttribute.html#a1f5570cabe2639d83a7eacc0b3a4bd50" title="Return an attribute by its name.">GetAttribute()</a> should also be implemented.</dd></dl>
<p>Drivers known to implement it for groups and arrays: MEM, netCDF.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#ace3cadfe1eaaa37dc2fd2e337180b1c9" title="Return the list of attributes contained in this group.">GDALGroupGetAttributes()</a> or <a class="el" href="gdal_8h.html#ad3cc1e2a9740f845611519b5f406ac74" title="Return the list of attributes contained in this array.">GDALMDArrayGetAttributes()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>Driver specific options determining how attributes should be retrieved. Pass nullptr for default behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the attributes. </dd></dl>

</div>
</div>
<a id="a58329a5ad0abf756fe2d3a10d49e0cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58329a5ad0abf756fe2d3a10d49e0cc2">&#9670;&nbsp;</a></span>GetBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &gt; GDALAbstractMDArray::GetBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the "natural" block size of the array along all dimensions. </p>
<p>Some drivers might organize the array in tiles/blocks and reading/writing aligned on those tile/block boundaries will be more efficient.</p>
<p>The returned number of elements in the vector is the same as <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a>. A value of 0 should be interpreted as no hint regarding the natural block size along the considered dimension. "Flat" arrays will typically return a vector of values set to 0.</p>
<p>The default implementation will return a vector of values set to 0.</p>
<p>This method is used by <a class="el" href="classGDALAbstractMDArray.html#a654efba82b40af5063a275292fcfb854" title="Return an optimal chunk size for read/write operations, given the natural block size and memory const...">GetProcessingChunkSize()</a>.</p>
<p>Pedantic note: the returned type is GUInt64, so in the highly unlikeley theoretical case of a 32-bit platform, this might exceed its size_t allocation capabilities.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#afe83b08f6d6bc0953417c51aac60360c" title="Return the &quot;natural&quot; block size of the array along all dimensions.">GDALMDArrayGetBlockSize()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the block size, in number of elements along each dimension. </dd></dl>

</div>
</div>
<a id="a3fb684035870bc9a46fa0ea1aaabb336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb684035870bc9a46fa0ea1aaabb336">&#9670;&nbsp;</a></span>GetCoordinateVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; &gt; GDALMDArray::GetCoordinateVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return coordinate variables. </p>
<p>Coordinate variables are an alternate way of indexing an array that can be sometimes used. For example, an array collected through remote sensing might be indexed by (scanline, pixel). But there can be a longitude and latitude arrays alongside that are also both indexed by (scanline, pixel), and are referenced from operational arrays for reprojection purposes.</p>
<p>For netCDF, this will return the arrays referenced by the "coordinates" attribute.</p>
<p>This method is the same as the C function <a class="el" href="gdal_8h.html#aa9a46a8febb63bf1b026927d29967a12" title="Return coordinate variables.">GDALMDArrayGetCoordinateVariables()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of arrays</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4 </dd></dl>

</div>
</div>
<a id="a79fe433024efc083ddf2e7d1c25a6428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fe433024efc083ddf2e7d1c25a6428">&#9670;&nbsp;</a></span>GetDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GDALAbstractMDArray::GetDataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the data type of an attribute/array. </p>
<p>This is the same as the C functions <a class="el" href="gdal_8h.html#ace043b04228941ae70da4b978e3a3b2e" title="Return the data type.">GDALMDArrayGetDataType()</a> and <a class="el" href="gdal_8h.html#a70624bf782f2363df75262afa1442afc" title="Return the data type.">GDALAttributeGetDataType()</a> </p>

</div>
</div>
<a id="ad187a612ebbf1369954af77ad57f7ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad187a612ebbf1369954af77ad57f7ade">&#9670;&nbsp;</a></span>GetDimensionCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t GDALAbstractMDArray::GetDimensionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of dimensions. </p>
<p>Default implementation is <a class="el" href="classGDALAbstractMDArray.html#a64b92edc85e26e1354e1ba52a67df9c4" title="Return the dimensions of an attribute/array.">GetDimensions()</a>.size(), and may be overridden by drivers if they have a faster / less expensive implementations.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a1e1b8bf49c0a00a739530654c6609f1e" title="Return the number of dimensions.">GDALMDArrayGetDimensionCount()</a> or <a class="el" href="gdal_8h.html#a1c6277072b330d88f898b7a1d45796ef" title="Return the number of dimensions.">GDALAttributeGetDimensionCount()</a>. </p>

</div>
</div>
<a id="a64b92edc85e26e1354e1ba52a67df9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b92edc85e26e1354e1ba52a67df9c4">&#9670;&nbsp;</a></span>GetDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GDALAbstractMDArray::GetDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the dimensions of an attribute/array. </p>
<p>This is the same as the C functions <a class="el" href="gdal_8h.html#a8e3033127ec47c491e7da7b347bd58a6" title="Return the dimensions of the array.">GDALMDArrayGetDimensions()</a> and similar to <a class="el" href="gdal_8h.html#aafb6351d571d61e584485a72783c9de7" title="Return the dimension sizes of the attribute.">GDALAttributeGetDimensionsSize()</a>. </p>

</div>
</div>
<a id="a5eb76059dc2cab066e99ffffded36546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb76059dc2cab066e99ffffded36546">&#9670;&nbsp;</a></span>GetFilename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; GDALMDArray::GetFilename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the filename that contains that array. </p>
<p>This is used in particular for caching.</p>
<p>Might be empty if the array is not linked to a file.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4 </dd></dl>

</div>
</div>
<a id="ab4e06c021e92922f0536ec7cb43ade30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e06c021e92922f0536ec7cb43ade30">&#9670;&nbsp;</a></span>GetFullName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; GDALAbstractMDArray::GetFullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of an array or attribute. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a02dd1e187c4d3a62d91cd8e8fcaab2bf" title="Return array full name.">GDALMDArrayGetFullName()</a> or <a class="el" href="gdal_8h.html#ad69c2c77f8851f1d233d4365dd7306e7" title="Return the full name of the attribute.">GDALAttributeGetFullName()</a>. </p>

</div>
</div>
<a id="a967cc1cfafedebdc2cc50e20110038ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967cc1cfafedebdc2cc50e20110038ba">&#9670;&nbsp;</a></span>GetGridded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::GetGridded </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osGridOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poXArrayIn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poYArrayIn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a gridded array from scattered point data, that is from an array whose last dimension is the indexing variable of X and Y arrays. </p>
<p>The gridding is done in 2D, using <a class="el" href="gdal__alg_8h.html#a1fdef40bcdbc98eff2328b0d093d3a22" title="Create regular grid from the scattered data.">GDALGridCreate()</a>, on-the-fly at <a class="el" href="classGDALMDArray.html#ad8f5fb5d0088b9e8c8eec261798ae729" title="Read part or totality of a multidimensional array or attribute.">Read()</a> time, taking into account the spatial extent of the request to limit the gridding. The results got on the whole extent or a subset of it might not be strictly identical depending on the gridding algorithm and its radius. Setting a radius in osGridOptions is recommended to improve performance. For arrays which have more dimensions than the dimension of the indexing variable of the X and Y arrays, <a class="el" href="classGDALMDArray.html#ad8f5fb5d0088b9e8c8eec261798ae729" title="Read part or totality of a multidimensional array or attribute.">Read()</a> must be called on slices of the extra dimensions (ie count[i] must be set to 1, except for the X and Y dimensions of the array returned by this method).</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#ab887bcd25f9be5dea7325198a6869c5a" title="Return a gridded array from scattered point data, that is from an array whose last dimension is the i...">GDALMDArrayGetGridded()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osGridOptions</td><td>Gridding algorithm and options. e.g. "invdist:nodata=nan:radius1=1:radius2=1:max_points=5". See documentation of the <a href="/programs/gdal_grid.html">gdal_grid</a> utility for all options. </td></tr>
    <tr><td class="paramname">poXArrayIn</td><td>Single-dimension array containing X values, and whose dimension is the last one of this array. If set to nullptr, the "coordinates" attribute must exist on this array, and the X variable will be the (N-1)th one mentioned in it, unless there is a "x" or "lon" variable in "coordinates". </td></tr>
    <tr><td class="paramname">poYArrayIn</td><td>Single-dimension array containing Y values, and whose dimension is the last one of this array. If set to nullptr, the "coordinates" attribute must exist on this array, and the Y variable will be the (N-2)th one mentioned in it, unless there is a "y" or "lat" variable in "coordinates". </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or nullptr. Supported options are: <ul>
<li>
RESOLUTION=val: Spatial resolution of the returned array. If not set, will be guessed from the typical spacing of (X,Y) points. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gridded array, or nullptr in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="aa4f5ba8fb8dab129d6813fb8cda59365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f5ba8fb8dab129d6813fb8cda59365">&#9670;&nbsp;</a></span>GetMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::GetMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array that is a mask for the current array. </p>
<p>This array will be of type Byte, with values set to 0 to indicate invalid pixels of the current array, and values set to 1 to indicate valid pixels.</p>
<p>The generic implementation honours the NoDataValue, as well as various netCDF CF attributes: missing_value, _FillValue, valid_min, valid_max and valid_range.</p>
<p>Starting with GDAL 3.8, option UNMASK_FLAGS=flag_meaning_1[,flag_meaning_2,...] can be used to specify strings of the "flag_meanings" attribute (cf <a href="https://cfconventions.org/cf-conventions/cf-conventions.html#flags">https://cfconventions.org/cf-conventions/cf-conventions.html#flags</a>) for which pixels matching any of those flags will be set at 1 in the mask array, and pixels matching none of those flags will be set at 0. For example, let's consider the following netCDF variable defined with: </p><pre class="fragment">l2p_flags:valid_min = 0s ;
l2p_flags:valid_max = 256s ;
l2p_flags:flag_meanings = "microwave land ice lake river reserved_for_future_use unused_currently unused_currently unused_currently" ;
l2p_flags:flag_masks = 1s, 2s, 4s, 8s, 16s, 32s, 64s, 128s, 256s ;
</pre><p>GetMask(["UNMASK_FLAGS=microwave,land"]) will return an array such that:</p><ul>
<li>for pixel values <em>outside</em> valid_range [0,256], the mask value will be 0.</li>
<li>for a pixel value with bit 0 or bit 1 at 1 within [0,256], the mask value will be 1.</li>
<li>for a pixel value with bit 0 and bit 1 at 0 within [0,256], the mask value will be 0.</li>
</ul>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a9fd27c509a05c2dc663309ee20f8fff3" title="Return an array that is a mask for the current array.">GDALMDArrayGetMask()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new array, that holds a reference to the original one, and thus is a view of it (not a copy), or nullptr in case of error. </dd></dl>

</div>
</div>
<a id="ab58984ee0ddf3b263dcc6338475d1fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58984ee0ddf3b263dcc6338475d1fbe">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; GDALAbstractMDArray::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of an array or attribute. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a677e0b675130a38a5cdb86538b9304d1" title="Return array name.">GDALMDArrayGetName()</a> or <a class="el" href="gdal_8h.html#a9ff1d17fe9e5d418bf4ab44181769e86" title="Return the name of the attribute.">GDALAttributeGetName()</a>. </p>

</div>
</div>
<a id="ad92b9b2782cd90c9f65dff0e1205be08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92b9b2782cd90c9f65dff0e1205be08">&#9670;&nbsp;</a></span>GetNoDataValueAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GDALMDArray::GetNoDataValueAsDouble </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbHasNoData</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nodata value as a double. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#afaf387481e7aa947c5ab08df98c70bd1" title="Return the nodata value as a double.">GDALMDArrayGetNoDataValueAsDouble()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbHasNoData</td><td>Pointer to a output boolean that will be set to true if a nodata value exists and can be converted to double. Might be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nodata value as a double. A 0.0 value might also indicate the absence of a nodata value or an error in the conversion (*pbHasNoData will be set to false then). </dd></dl>

</div>
</div>
<a id="aa974f6a036af80469476f0db03b6d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa974f6a036af80469476f0db03b6d458">&#9670;&nbsp;</a></span>GetNoDataValueAsInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t GDALMDArray::GetNoDataValueAsInt64 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbHasNoData</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nodata value as a Int64. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbHasNoData</td><td>Pointer to a output boolean that will be set to true if a nodata value exists and can be converted to Int64. Might be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a2b3b8538f77f0b34822dc890273c4c7d" title="Return the nodata value as a Int64.">GDALMDArrayGetNoDataValueAsInt64()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the nodata value as a Int64</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="af377a290359195de1bf9309b5752c748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af377a290359195de1bf9309b5752c748">&#9670;&nbsp;</a></span>GetNoDataValueAsUInt64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t GDALMDArray::GetNoDataValueAsUInt64 </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbHasNoData</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the nodata value as a UInt64. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#aa25645d267b7c39176b4e350edf0b14d" title="Return the nodata value as a UInt64.">GDALMDArrayGetNoDataValueAsUInt64()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbHasNoData</td><td>Pointer to a output boolean that will be set to true if a nodata value exists and can be converted to UInt64. Might be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nodata value as a UInt64</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="a59e687a08461bbe1320f3a81b0089675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e687a08461bbe1320f3a81b0089675">&#9670;&nbsp;</a></span>GetOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GDALMDArray::GetOffset </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbHasOffset</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> *&#160;</td>
          <td class="paramname"><em>peStorageType</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset value to apply to raw values. </p>
<p>unscaled_value = raw_value * <a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45" title="Get the scale value to apply to raw values.">GetScale()</a> + <a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675" title="Get the offset value to apply to raw values.">GetOffset()</a></p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a9f126027c38fcd647966995d952db9e7" title="Get the scale value to apply to raw values.">GDALMDArrayGetOffset()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method shall be implemented if gettings offset is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbHasOffset</td><td>Pointer to a output boolean that will be set to true if a offset value exists. Might be nullptr. </td></tr>
    <tr><td class="paramname">peStorageType</td><td>Pointer to a output GDALDataType that will be set to the storage type of the offset value, when known/relevant. Otherwise will be set to GDT_Unknown. Might be nullptr. Since GDAL 3.3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the offset value. A 0.0 value might also indicate the absence of a offset value. </dd></dl>

</div>
</div>
<a id="a654efba82b40af5063a275292fcfb854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654efba82b40af5063a275292fcfb854">&#9670;&nbsp;</a></span>GetProcessingChunkSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; GDALAbstractMDArray::GetProcessingChunkSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nMaxChunkMemory</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an optimal chunk size for read/write operations, given the natural block size and memory constraints specified. </p>
<p>This method will use <a class="el" href="classGDALAbstractMDArray.html#a58329a5ad0abf756fe2d3a10d49e0cc2" title="Return the &quot;natural&quot; block size of the array along all dimensions.">GetBlockSize()</a> to define a chunk whose dimensions are multiple of those returned by <a class="el" href="classGDALAbstractMDArray.html#a58329a5ad0abf756fe2d3a10d49e0cc2" title="Return the &quot;natural&quot; block size of the array along all dimensions.">GetBlockSize()</a> (unless the block define by <a class="el" href="classGDALAbstractMDArray.html#a58329a5ad0abf756fe2d3a10d49e0cc2" title="Return the &quot;natural&quot; block size of the array along all dimensions.">GetBlockSize()</a> is larger than nMaxChunkMemory, in which case it will be returned by this method).</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a8c8cfe12764e5977a5ef62ff927fdd90" title="Return an optimal chunk size for read/write operations, given the natural block size and memory const...">GDALMDArrayGetProcessingChunkSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nMaxChunkMemory</td><td>Maximum amount of memory, in bytes, to use for the chunk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chunk size, in number of elements along each dimension. </dd></dl>

</div>
</div>
<a id="a6399f8a7f49bb0dafab283aa14f03029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6399f8a7f49bb0dafab283aa14f03029">&#9670;&nbsp;</a></span>GetRawNoDataValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * GDALMDArray::GetRawNoDataValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the nodata value as a "raw" value. </p>
<p>The value returned might be nullptr in case of no nodata value. When a nodata value is registered, a non-nullptr will be returned whose size in bytes is <a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428" title="Return the data type of an attribute/array.">GetDataType()</a>.GetSize().</p>
<p>The returned value should not be modified or freed. It is valid until the array is destroyed, or the next call to <a class="el" href="classGDALMDArray.html#a6399f8a7f49bb0dafab283aa14f03029" title="Return the nodata value as a &quot;raw&quot; value.">GetRawNoDataValue()</a> or <a class="el" href="classGDALMDArray.html#a55b1b33d01c41f75c88a0173979728d5" title="Set the nodata value as a &quot;raw&quot; value.">SetRawNoDataValue()</a>, or any similar methods.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method shall be implemented if nodata is supported.</dd></dl>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a23b9976a4a58db4905ffa15616ba8064" title="Return the nodata value as a &quot;raw&quot; value.">GDALMDArrayGetRawNoDataValue()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>nullptr or a pointer to <a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428" title="Return the data type of an attribute/array.">GetDataType()</a>.GetSize() bytes. </dd></dl>

</div>
</div>
<a id="a960b1192e25e59b343db87628af71e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960b1192e25e59b343db87628af71e42">&#9670;&nbsp;</a></span>GetResampled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::GetResampled </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classGDALDimension.html">GDALDimension</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>apoNewDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a640ada511cbddeefac67c548e009d5ac">GDALRIOResampleAlg</a>&#160;</td>
          <td class="paramname"><em>resampleAlg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poTargetSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array that is a resampled / reprojected view of the current array. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a1450876e93f5baa386f625c17b81e3b6" title="Return an array that is a resampled / reprojected view of the current array.">GDALMDArrayGetResampled()</a>.</p>
<p>Currently this method can only resample along the last 2 dimensions, unless orthorectifying a NASA EMIT dataset.</p>
<p>For NASA EMIT datasets, if apoNewDims[] and poTargetSRS is NULL, the geometry lookup table (GLT) is used for fast orthorectification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apoNewDims</td><td>New dimensions. Its size should be <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a>. apoNewDims[i] can be NULL to let the method automatically determine it. </td></tr>
    <tr><td class="paramname">resampleAlg</td><td>Resampling algorithm </td></tr>
    <tr><td class="paramname">poTargetSRS</td><td>Target SRS, or nullptr </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new array, that holds a reference to the original one, and thus is a view of it (not a copy), or nullptr in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.4 </dd></dl>

</div>
</div>
<a id="ad5643496dc322d0368e75e652235f103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5643496dc322d0368e75e652235f103">&#9670;&nbsp;</a></span>GetRootGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALGroup.html">GDALGroup</a> &gt; GDALMDArray::GetRootGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the root group to which this arrays belongs too. </p>
<p>Note that arrays may be free standing and some drivers may not implement this method, hence nullptr may be returned.</p>
<p>It is used internally by the <a class="el" href="classGDALMDArray.html#a960b1192e25e59b343db87628af71e42" title="Return an array that is a resampled / reprojected view of the current array.">GetResampled()</a> method to detect if GLT orthorectification is available.</p>
<dl class="section return"><dt>Returns</dt><dd>the root group, or nullptr. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a6a6898f31b8eae2294f4735469fc8b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6898f31b8eae2294f4735469fc8b45">&#9670;&nbsp;</a></span>GetScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GDALMDArray::GetScale </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbHasScale</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a> *&#160;</td>
          <td class="paramname"><em>peStorageType</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scale value to apply to raw values. </p>
<p>unscaled_value = raw_value * <a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45" title="Get the scale value to apply to raw values.">GetScale()</a> + <a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675" title="Get the offset value to apply to raw values.">GetOffset()</a></p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#abcd91754cc0278153eae36084803d8d5" title="Get the scale value to apply to raw values.">GDALMDArrayGetScale()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method shall be implemented if gettings scale is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pbHasScale</td><td>Pointer to a output boolean that will be set to true if a scale value exists. Might be nullptr. </td></tr>
    <tr><td class="paramname">peStorageType</td><td>Pointer to a output GDALDataType that will be set to the storage type of the scale value, when known/relevant. Otherwise will be set to GDT_Unknown. Might be nullptr. Since GDAL 3.3</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scale value. A 1.0 value might also indicate the absence of a scale value. </dd></dl>

</div>
</div>
<a id="a6f5cbdeba243c3590826ffd89f33172e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5cbdeba243c3590826ffd89f33172e">&#9670;&nbsp;</a></span>GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> &gt; GDALMDArray::GetSpatialRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the spatial reference system object associated with the array. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a6e583bfa937bfb9ff723853a14ec375f" title="Return the spatial reference system object associated with the array.">GDALMDArrayGetSpatialRef()</a>. </p>

</div>
</div>
<a id="af7ad965a69ff2fa6433f2740f0386918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad965a69ff2fa6433f2740f0386918">&#9670;&nbsp;</a></span>GetStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALMDArray::GetStatistics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bApproxOK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfStdDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>pnValidCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch statistics. </p>
<p>Returns the minimum, maximum, mean and standard deviation of all pixel values in this array.</p>
<p>If bForce is FALSE results will only be returned if it can be done quickly (i.e. without scanning the data). If bForce is FALSE and results cannot be returned efficiently, the method will return CE_Warning but no warning will have been issued. This is a non-standard use of the CE_Warning return value to indicate "nothing done".</p>
<p>When cached statistics are not available, and bForce is TRUE, <a class="el" href="classGDALMDArray.html#a3565413aa3a9b203f3c827a854e0f486" title="Compute statistics.">ComputeStatistics()</a> is called.</p>
<p>Note that file formats using PAM (Persistent Auxiliary Metadata) services will generally cache statistics in the .aux.xml file allowing fast fetch after the first request.</p>
<p>Cached statistics can be cleared with <a class="el" href="classGDALDataset.html#a6a805dee10572e805aa42c26bc43e97c" title="Clear statistics.">GDALDataset::ClearStatistics()</a>.</p>
<p>This method is the same as the C function <a class="el" href="gdal_8h.html#aab91eb7ec52cef314cea1098361d9b1d" title="Fetch statistics.">GDALMDArrayGetStatistics()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bApproxOK</td><td>Currently ignored. In the future, should be set to true if statistics on the whole array are wished, or to false if a subset of it may be used.</td></tr>
    <tr><td class="paramname">bForce</td><td>If false statistics will only be returned if it can be done without rescanning the image.</td></tr>
    <tr><td class="paramname">pdfMin</td><td>Location into which to load image minimum (may be NULL).</td></tr>
    <tr><td class="paramname">pdfMax</td><td>Location into which to load image maximum (may be NULL).-</td></tr>
    <tr><td class="paramname">pdfMean</td><td>Location into which to load image mean (may be NULL).</td></tr>
    <tr><td class="paramname">pdfStdDev</td><td>Location into which to load image standard deviation (may be NULL).</td></tr>
    <tr><td class="paramname">pnValidCount</td><td>Number of samples whose value is different from the nodata value. (may be NULL)</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a function to call to report progress, or NULL.</td></tr>
    <tr><td class="paramname">pProgressData</td><td>application data to pass to the progress function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success, CE_Warning if no values returned, CE_Failure if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="abeeef7e6e43553b8d35b39a7f031b79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeeef7e6e43553b8d35b39a7f031b79f">&#9670;&nbsp;</a></span>GetStructuralInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> GDALMDArray::GetStructuralInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return structural information on the array. </p>
<p>This may be the compression, etc..</p>
<p>The return value should not be freed and is valid until <a class="el" href="classGDALMDArray.html" title="Class modeling a multi-dimensional array.">GDALMDArray</a> is released or this function called again.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#aae95c25d2786e92e0aa3f22d1c809c0c" title="Return structural information on the array.">GDALMDArrayGetStructuralInfo()</a>. </p>

</div>
</div>
<a id="a3b97752cc115cb44d6339cdfad97b222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b97752cc115cb44d6339cdfad97b222">&#9670;&nbsp;</a></span>GetTotalCopyCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> GDALMDArray::GetTotalCopyCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a total "cost" to copy the array. </p>
<p>Used as a parameter for <a class="el" href="classGDALMDArray.html#a37c7e7f8a659f3090b9366e75e256fdb" title="Copy the content of an array into a new (generally empty) array.">CopyFrom()</a> </p>

</div>
</div>
<a id="a02aa853ea2f4b29db0ef955ef2da415b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa853ea2f4b29db0ef955ef2da415b">&#9670;&nbsp;</a></span>GetTotalElementsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> GDALAbstractMDArray::GetTotalElementsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of values in the array. </p>
<p>This is the same as the C functions <a class="el" href="gdal_8h.html#a15eac3ec24c7b3587f2ba55fecaa9633" title="Return the total number of values in the array.">GDALMDArrayGetTotalElementsCount()</a> and <a class="el" href="gdal_8h.html#a61014df69e0ff5865c554c68ea4c241d" title="Return the total number of values in the attribute.">GDALAttributeGetTotalElementsCount()</a>. </p>

</div>
</div>
<a id="af8e01f44fa53c78da06924994252fb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e01f44fa53c78da06924994252fb62">&#9670;&nbsp;</a></span>GetUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; GDALMDArray::GetUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the array unit. </p>
<p>Values should conform as much as possible with those allowed by the NetCDF CF conventions: <a href="http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/cf-conventions.html#units">http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/cf-conventions.html#units</a> but others might be returned.</p>
<p>Few examples are "meter", "degrees", "second", ... Empty value means unknown.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a0d369a77b8e48958577c38464f0b37ba" title="Return the array unit.">GDALMDArrayGetUnit()</a> </p>

</div>
</div>
<a id="ab2efbbbfa7596b0dd7d96f5c5f3abaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2efbbbfa7596b0dd7d96f5c5f3abaf6">&#9670;&nbsp;</a></span>GetUnscaled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::GetUnscaled </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfOverriddenScale</em> = <code>std::numeric_limits&lt;double&gt;::quiet_NaN()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfOverriddenOffset</em> = <code>std::numeric_limits&lt;double&gt;::quiet_NaN()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfOverriddenDstNodata</em> = <code>std::numeric_limits&lt;double&gt;::quiet_NaN()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an array that is the unscaled version of the current one. </p>
<p>That is each value of the unscaled array will be unscaled_value = raw_value * <a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45" title="Get the scale value to apply to raw values.">GetScale()</a> + <a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675" title="Get the offset value to apply to raw values.">GetOffset()</a></p>
<p>Starting with GDAL 3.3, the <a class="el" href="classGDALAbstractMDArray.html#afebbed7c69603f7b3ce4e8b2adf416f9" title="Write part or totality of a multidimensional array or attribute.">Write()</a> method is implemented and will convert from unscaled values to raw values.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#afa55faee55047d7026382fb2b9d4cd50" title="Return an array that is the unscaled version of the current one.">GDALMDArrayGetUnscaled()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfOverriddenScale</td><td>Custom scale value instead of <a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45" title="Get the scale value to apply to raw values.">GetScale()</a> </td></tr>
    <tr><td class="paramname">dfOverriddenOffset</td><td>Custom offset value instead of <a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675" title="Get the offset value to apply to raw values.">GetOffset()</a> </td></tr>
    <tr><td class="paramname">dfOverriddenDstNodata</td><td>Custom target nodata value instead of NaN </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new array, that holds a reference to the original one, and thus is a view of it (not a copy), or nullptr in case of error. </dd></dl>

</div>
</div>
<a id="a14b7d70b8dbc404e6a6cb0c257d47bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b7d70b8dbc404e6a6cb0c257d47bdd">&#9670;&nbsp;</a></span>GetView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::GetView </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>viewExpr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a view of the array using slicing or field access. </p>
<p>The slice expression uses the same syntax as NumPy basic slicing and indexing. See <a href="https://www.numpy.org/devdocs/reference/arrays.indexing.html#basic-slicing-and-indexing">https://www.numpy.org/devdocs/reference/arrays.indexing.html#basic-slicing-and-indexing</a> Or it can use field access by name. See <a href="https://www.numpy.org/devdocs/reference/arrays.indexing.html#field-access">https://www.numpy.org/devdocs/reference/arrays.indexing.html#field-access</a></p>
<p>Multiple [] bracket elements can be concatenated, with a slice expression or field name inside each.</p>
<p>For basic slicing and indexing, inside each [] bracket element, a list of indexes that apply to successive source dimensions, can be specified, using integer indexing (e.g. 1), range indexing (start:stop:step), ellipsis (...) or newaxis, using a comma separator.</p>
<p>Examples with a 2-dimensional array whose content is [[0,1,2,3],[4,5,6,7]]. </p><ul>
<li>
GetView("[1][2]"): returns a 0-dimensional/scalar array with the value at index 1 in the first dimension, and index 2 in the second dimension from the source array. That is 5 </li>
<li>
GetView("[1]")-&gt;GetView("[2]"): same as above. Above is actually implemented internally doing this intermediate slicing approach. </li>
<li>
GetView("[1,2]"): same as above, but a bit more performant. </li>
<li>
GetView("[1]"): returns a 1-dimensional array, sliced at index 1 in the first dimension. That is [4,5,6,7]. </li>
<li>
GetView("[:,2]"): returns a 1-dimensional array, sliced at index 2 in the second dimension. That is [2,6]. </li>
<li>
GetView("[:,2:3:]"): returns a 2-dimensional array, sliced at index 2 in the second dimension. That is [[2],[6]]. </li>
<li>
GetView("[::,2]"): Same as above. </li>
<li>
GetView("[...,2]"): same as above, in that case, since the ellipsis only expands to one dimension here. </li>
<li>
GetView("[:,::2]"): returns a 2-dimensional array, with even-indexed elements of the second dimension. That is [[0,2],[4,6]]. </li>
<li>
GetView("[:,1::2]"): returns a 2-dimensional array, with odd-indexed elements of the second dimension. That is [[1,3],[5,7]]. </li>
<li>
GetView("[:,1:3:]"): returns a 2-dimensional array, with elements of the second dimension with index in the range [1,3[. That is [[1,2],[5,6]]. </li>
<li>
GetView("[::-1,:]"): returns a 2-dimensional array, with the values in first dimension reversed. That is [[4,5,6,7],[0,1,2,3]]. </li>
<li>
GetView("[newaxis,...]"): returns a 3-dimensional array, with an addditional dimension of size 1 put at the beginning. That is [[[0,1,2,3],[4,5,6,7]]]. </li>
</ul>
<p>One difference with NumPy behavior is that ranges that would result in zero elements are not allowed (dimensions of size 0 not being allowed in the GDAL multidimensional model).</p>
<p>For field access, the syntax to use is ["field_name"] or ['field_name']. Multiple field specification is not supported currently.</p>
<p>Both type of access can be combined, e.g. GetView("[1]['field_name']")</p>
<dl class="section note"><dt>Note</dt><dd>When using the GDAL Python bindings, natural Python syntax can be used. That is ar[0,::,1]["foo"] will be internally translated to ar.GetView("[0,::,1]['foo']") </dd>
<dd>
When using the C++ API and integer indexing only, you may use the at(idx0, idx1, ...) method.</dd></dl>
<p>The returned array holds a reference to the original one, and thus is a view of it (not a copy). If the content of the original array changes, the content of the view array too. When using basic slicing and indexing, the view can be written if the underlying array is writable.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a1834e55cba67c1d56034511ba7c9e145" title="Return a view of the array using slicing or field access.">GDALMDArrayGetView()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewExpr</td><td>Expression expressing basic slicing and indexing, or field access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new array, that holds a reference to the original one, and thus is a view of it (not a copy), or nullptr in case of error. </dd></dl>

</div>
</div>
<a id="ad03cb916515cd7b1e04d9131e7c4f959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03cb916515cd7b1e04d9131e7c4f959">&#9670;&nbsp;</a></span>GuessGeoTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::GuessGeoTransform </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDimX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDimY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPixelIsPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adfGeoTransform</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether 2 specified dimensions form a geotransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">nDimX</td><td>Index of the X axis. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nDimY</td><td>Index of the Y axis. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bPixelIsPoint</td><td>Whether the geotransform should be returned with the pixel-is-point (pixel-center) convention (bPixelIsPoint = true), or with the pixel-is-area (top left corner convention) (bPixelIsPoint = false) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">adfGeoTransform</td><td>Computed geotransform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a geotransform could be computed. </dd></dl>

</div>
</div>
<a id="ad868846e9f958c2bcda89276d92e5f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868846e9f958c2bcda89276d92e5f15">&#9670;&nbsp;</a></span>IsRegularlySpaced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::IsRegularlySpaced </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dfStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dfIncrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether an array is a 1D regularly spaced array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dfStart</td><td>First value in the array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dfIncrement</td><td>Increment/spacing between consecutive values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the array is regularly spaced. </dd></dl>

</div>
</div>
<a id="a6c88d3103cee12a1f9557bd1d3fe1ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c88d3103cee12a1f9557bd1d3fe1ab7">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fieldName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a view of the array using field access. </p>
<p>Equivalent of GetView("['fieldName']")</p>
<dl class="section note"><dt>Note</dt><dd>When operationg on a shared_ptr, use (*array)["fieldName"] syntax. </dd></dl>

</div>
</div>
<a id="a91005189ff493f595ddd4ba446cc216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91005189ff493f595ddd4ba446cc216a">&#9670;&nbsp;</a></span>ProcessPerChunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALAbstractMDArray::ProcessPerChunk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>arrayStartIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>chunkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGDALAbstractMDArray.html#a96c310c2baf7f653c090e38186393e65">FuncProcessPerChunkType</a>&#160;</td>
          <td class="paramname"><em>pfnFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a user-provided function to operate on an array chunk by chunk. </p>
<p>This method is to be used when doing operations on an array, or a subset of it, in a chunk by chunk way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayStartIdx</td><td>Values representing the starting index to use in each dimension (in [0, aoDims[i].GetSize()-1] range). Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">count</td><td>Values representing the number of values to use in each dimension. Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">chunkSize</td><td>Values representing the chunk size in each dimension. Might typically the output of <a class="el" href="classGDALAbstractMDArray.html#a654efba82b40af5063a275292fcfb854" title="Return an optimal chunk size for read/write operations, given the natural block size and memory const...">GetProcessingChunkSize()</a>. Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">pfnFunc</td><td>User-provided function of type FuncProcessPerChunkType. Must NOT be nullptr.</td></tr>
    <tr><td class="paramname">pUserData</td><td>Pointer to pass as the value of the pUserData argument of FuncProcessPerChunkType. Might be nullptr (depends on pfnFunc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="ad8f5fb5d0088b9e8c8eec261798ae729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f5fb5d0088b9e8c8eec261798ae729">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::Read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>arrayStartIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#a6e5dffdc7f562a64c72c486fe3706847">GInt64</a> *&#160;</td>
          <td class="paramname"><em>arrayStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#a266f5ca4950b3381e59593912f0f3f9c">GPtrDiff_t</a> *&#160;</td>
          <td class="paramname"><em>bufferStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferDataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pDstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pDstBufferAllocStart</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDstBufferAllocSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read part or totality of a multidimensional array or attribute. </p>
<p>This will extract the content of a hyper-rectangle from the array into a user supplied buffer.</p>
<p>If bufferDataType is of type string, the values written in pDstBuffer will be char* pointers and the strings should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a894a28265a68e41ea02b7b401c739e92" title="Read part or totality of a multidimensional array.">GDALMDArrayRead()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayStartIdx</td><td>Values representing the starting index to read in each dimension (in [0, aoDims[i].GetSize()-1] range). Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">count</td><td>Values representing the number of values to extract in each dimension. Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">arrayStep</td><td>Spacing between values to extract in each dimension. The spacing is in number of array elements, not bytes. If provided, must contain <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. If set to nullptr, [1, 1, ... 1] will be used as a default to indicate consecutive elements.</td></tr>
    <tr><td class="paramname">bufferStride</td><td>Spacing between values to store in pDstBuffer. The spacing is in number of array elements, not bytes. If provided, must contain <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Negative values are possible (for example to reorder from bottom-to-top to top-to-bottom). If set to nullptr, will be set so that pDstBuffer is written in a compact way, with elements of the last / fastest varying dimension being consecutive.</td></tr>
    <tr><td class="paramname">bufferDataType</td><td>Data type of values in pDstBuffer.</td></tr>
    <tr><td class="paramname">pDstBuffer</td><td>User buffer to store the values read. Should be big enough to store the number of values indicated by count[] and with the spacing of bufferStride[].</td></tr>
    <tr><td class="paramname">pDstBufferAllocStart</td><td>Optional pointer that can be used to validate the validty of pDstBuffer. pDstBufferAllocStart should be the pointer returned by the malloc() or equivalent call used to allocate the buffer. It will generally be equal to pDstBuffer (when bufferStride[] values are all positive), but not necessarily. If specified, nDstBufferAllocSize should be also set to the appropriate value. If no validation is needed, nullptr can be passed.</td></tr>
    <tr><td class="paramname">nDstBufferAllocSize</td><td>Optional buffer size, that can be used to validate the validty of pDstBuffer. This is the size of the buffer starting at pDstBufferAllocStart. If specified, pDstBufferAllocStart should be also set to the appropriate value. If no validation is needed, 0 can be passed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

<p>Reimplemented from <a class="el" href="classGDALAbstractMDArray.html#a99d02071e8653c75835cd0dfdee87c34">GDALAbstractMDArray</a>.</p>

</div>
</div>
<a id="a371e0a4f2268c8c95e5490663671f709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371e0a4f2268c8c95e5490663671f709">&#9670;&nbsp;</a></span>Rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALAbstractMDArray::Rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osNewName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename the attribute/array. </p>
<p>This is not implemented by all drivers.</p>
<p>Drivers known to implement it: MEM, netCDF, Zarr.</p>
<p>This is the same as the C functions <a class="el" href="gdal_8h.html#ab62aca7e4d1e8815fd1304d56f61b6a1" title="Rename the array.">GDALMDArrayRename()</a> or <a class="el" href="gdal_8h.html#a9c3b15f8e57aff992a020447c2f26968" title="Rename the attribute.">GDALAttributeRename()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osNewName</td><td>New name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a8f4df538fcf9d62a5782b7c1a93aa142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4df538fcf9d62a5782b7c1a93aa142">&#9670;&nbsp;</a></span>Resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::Resize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>anNewDimSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize an array to new dimensions. </p>
<p>Not all drivers may allow this operation, and with restrictions (e.g. for netCDF, this is limited to growing of "unlimited" dimensions)</p>
<p>Resizing a dimension used in other arrays will cause those other arrays to be resized.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#aa707a98f6e535c6b0dac773589b1fe3c" title="Resize an array to new dimensions.">GDALMDArrayResize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anNewDimSizes</td><td>Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values containing the new size of each indexing dimension. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options. (Driver specific) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a2cf673408d25ce00272e7b5a19707741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf673408d25ce00272e7b5a19707741">&#9670;&nbsp;</a></span>SetNoDataValue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetNoDataValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfNoData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the nodata value as a double. </p>
<p>If the natural data type of the attribute/array is not double, type conversion will occur to the type returned by <a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428" title="Return the data type of an attribute/array.">GetDataType()</a>.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#acbc644f729cdda0a771787afd96cd4e2" title="Set the nodata value as a double.">GDALMDArraySetNoDataValueAsDouble()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="ae8184a8e749daafdbbc3a582e9d9137d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8184a8e749daafdbbc3a582e9d9137d">&#9670;&nbsp;</a></span>SetNoDataValue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetNoDataValue </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nNoData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the nodata value as a Int64. </p>
<p>If the natural data type of the attribute/array is not Int64, type conversion will occur to the type returned by <a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428" title="Return the data type of an attribute/array.">GetDataType()</a>.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a31c275ec5373544e48befab2ff3e3728" title="Set the nodata value as a Int64.">GDALMDArraySetNoDataValueAsInt64()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="adaf0c54c46ebe944b3728b8c6f0033e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf0c54c46ebe944b3728b8c6f0033e3">&#9670;&nbsp;</a></span>SetNoDataValue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetNoDataValue </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nNoData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the nodata value as a Int64. </p>
<p>If the natural data type of the attribute/array is not Int64, type conversion will occur to the type returned by <a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428" title="Return the data type of an attribute/array.">GetDataType()</a>.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a327f23a5adba564cbb78f0f0ea59fa40" title="Set the nodata value as a UInt64.">GDALMDArraySetNoDataValueAsUInt64()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="aee99810d3b702c1b2827a6097ded2c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee99810d3b702c1b2827a6097ded2c49">&#9670;&nbsp;</a></span>SetOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetOffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&#160;</td>
          <td class="paramname"><em>eStorageType</em> = <code><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4aee80d7a2ef95f128685e66f6e1024cbe">GDT_Unknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the offset value to apply to raw values. </p>
<p>unscaled_value = raw_value * <a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45" title="Get the scale value to apply to raw values.">GetScale()</a> + <a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675" title="Get the offset value to apply to raw values.">GetOffset()</a></p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#af37c50656c28be8412112799c8eb9620" title="Set the scale value to apply to raw values.">GDALMDArraySetOffset()</a> / <a class="el" href="gdal_8h.html#a3f9e5b4ddc2769cbf2b25a2c559a5311" title="Set the scale value to apply to raw values.">GDALMDArraySetOffsetEx()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method shall be implemented if setting offset is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfOffset</td><td>Offset </td></tr>
    <tr><td class="paramname">eStorageType</td><td>Data type to which create the potential attribute that will store the offset. Added in GDAL 3.3 If let to its GDT_Unknown value, the implementation will decide automatically the data type. Note that changing the data type after initial setting might not be supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="a55b1b33d01c41f75c88a0173979728d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b1b33d01c41f75c88a0173979728d5">&#9670;&nbsp;</a></span>SetRawNoDataValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetRawNoDataValue </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pRawNoData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the nodata value as a "raw" value. </p>
<p>The value passed might be nullptr in case of no nodata value. When a nodata value is registered, a non-nullptr whose size in bytes is <a class="el" href="classGDALAbstractMDArray.html#a79fe433024efc083ddf2e7d1c25a6428" title="Return the data type of an attribute/array.">GetDataType()</a>.GetSize() must be passed.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a08af3e9f92bdf941e9fe485067465273" title="Set the nodata value as a &quot;raw&quot; value.">GDALMDArraySetRawNoDataValue()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method shall be implemented if setting nodata is supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="a49f70c7bc5d68bcf14b829fc3ba0d27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f70c7bc5d68bcf14b829fc3ba0d27c">&#9670;&nbsp;</a></span>SetScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetScale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4">GDALDataType</a>&#160;</td>
          <td class="paramname"><em>eStorageType</em> = <code><a class="el" href="gdal_8h.html#a22e22ce0a55036a96f652765793fb7a4aee80d7a2ef95f128685e66f6e1024cbe">GDT_Unknown</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the scale value to apply to raw values. </p>
<p>unscaled_value = raw_value * <a class="el" href="classGDALMDArray.html#a6a6898f31b8eae2294f4735469fc8b45" title="Get the scale value to apply to raw values.">GetScale()</a> + <a class="el" href="classGDALMDArray.html#a59e687a08461bbe1320f3a81b0089675" title="Get the offset value to apply to raw values.">GetOffset()</a></p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a7a3dc343fdd18e5177593a5d66f1f545" title="Set the scale value to apply to raw values.">GDALMDArraySetScale()</a> / <a class="el" href="gdal_8h.html#ab79e443d322d81623738a21a21f9468d" title="Set the scale value to apply to raw values.">GDALMDArraySetScaleEx()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: this method shall be implemented if setting scale is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfScale</td><td>scale </td></tr>
    <tr><td class="paramname">eStorageType</td><td>Data type to which create the potential attribute that will store the scale. Added in GDAL 3.3 If let to its GDT_Unknown value, the implementation will decide automatically the data type. Note that changing the data type after initial setting might not be supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="aaff0099cee1c017f139024e801020bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff0099cee1c017f139024e801020bc9">&#9670;&nbsp;</a></span>SetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetSpatialRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a spatial reference system object to the array. </p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#ae807945e461f5ca8617e92338b9c4e30" title="Assign a spatial reference system object to the array.">GDALMDArraySetSpatialRef()</a>. </p>

</div>
</div>
<a id="a0a98fe64fd967cfe83c0d912d06bd745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a98fe64fd967cfe83c0d912d06bd745">&#9670;&nbsp;</a></span>SetUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALMDArray::SetUnit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>osUnit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the variable unit. </p>
<p>Values should conform as much as possible with those allowed by the NetCDF CF conventions: <a href="http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/cf-conventions.html#units">http://cfconventions.org/Data/cf-conventions/cf-conventions-1.7/cf-conventions.html#units</a> but others might be returned.</p>
<p>Few examples are "meter", "degrees", "second", ... Empty value means unknown.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a480dbbdc18f5138d4837a9d43da85b89" title="Set the variable unit.">GDALMDArraySetUnit()</a></p>
<dl class="section note"><dt>Note</dt><dd>Driver implementation: optionally implemented.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osUnit</td><td>unit name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<a id="acb2e2f9a792329c7e0fe1b35bf756882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2e2f9a792329c7e0fe1b35bf756882">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classGDALMDArray.html">GDALMDArray</a> &gt; GDALMDArray::Transpose </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>anMapNewAxisToOldAxis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a view of the array whose axis have been reordered. </p>
<p>The anMapNewAxisToOldAxis parameter should contain all the values between 0 and <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> - 1, and each only once. -1 can be used as a special index value to ask for the insertion of a new axis of size 1. The new array will have anMapNewAxisToOldAxis.size() axis, and if i is the index of one of its dimension, it corresponds to the axis of index anMapNewAxisToOldAxis[i] from the current array.</p>
<p>This is similar to the numpy.transpose() method</p>
<p>The returned array holds a reference to the original one, and thus is a view of it (not a copy). If the content of the original array changes, the content of the view array too. The view can be written if the underlying array is writable.</p>
<p>Note that I/O performance in such a transposed view might be poor.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a9b9e126aec5306379ba837ccf402ef8c" title="Return a view of the array whose axis have been reordered.">GDALMDArrayTranspose()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a new array, that holds a reference to the original one, and thus is a view of it (not a copy), or nullptr in case of error. </dd></dl>

</div>
</div>
<a id="afebbed7c69603f7b3ce4e8b2adf416f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebbed7c69603f7b3ce4e8b2adf416f9">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GDALAbstractMDArray::Write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ad88aa21b67fc44326628930c9fa537ce">GUInt64</a> *&#160;</td>
          <td class="paramname"><em>arrayStartIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#a6e5dffdc7f562a64c72c486fe3706847">GInt64</a> *&#160;</td>
          <td class="paramname"><em>arrayStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#a266f5ca4950b3381e59593912f0f3f9c">GPtrDiff_t</a> *&#160;</td>
          <td class="paramname"><em>bufferStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDALExtendedDataType.html">GDALExtendedDataType</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferDataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pSrcBufferAllocStart</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSrcBufferAllocSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write part or totality of a multidimensional array or attribute. </p>
<p>This will set the content of a hyper-rectangle into the array from a user supplied buffer.</p>
<p>If bufferDataType is of type string, the values read from pSrcBuffer will be char* pointers.</p>
<p>This is the same as the C function <a class="el" href="gdal_8h.html#a2c706c3bf1ec90863c0f4d98473ae8d6" title="Write part or totality of a multidimensional array.">GDALMDArrayWrite()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayStartIdx</td><td>Values representing the starting index to write in each dimension (in [0, aoDims[i].GetSize()-1] range). Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">count</td><td>Values representing the number of values to write in each dimension. Array of <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Must not be nullptr, unless for a zero-dimensional array.</td></tr>
    <tr><td class="paramname">arrayStep</td><td>Spacing between values to write in each dimension. The spacing is in number of array elements, not bytes. If provided, must contain <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. If set to nullptr, [1, 1, ... 1] will be used as a default to indicate consecutive elements.</td></tr>
    <tr><td class="paramname">bufferStride</td><td>Spacing between values to read from pSrcBuffer. The spacing is in number of array elements, not bytes. If provided, must contain <a class="el" href="classGDALAbstractMDArray.html#ad187a612ebbf1369954af77ad57f7ade" title="Return the number of dimensions.">GetDimensionCount()</a> values. Negative values are possible (for example to reorder from bottom-to-top to top-to-bottom). If set to nullptr, will be set so that pSrcBuffer is written in a compact way, with elements of the last / fastest varying dimension being consecutive.</td></tr>
    <tr><td class="paramname">bufferDataType</td><td>Data type of values in pSrcBuffer.</td></tr>
    <tr><td class="paramname">pSrcBuffer</td><td>User buffer to read the values from. Should be big enough to store the number of values indicated by count[] and with the spacing of bufferStride[].</td></tr>
    <tr><td class="paramname">pSrcBufferAllocStart</td><td>Optional pointer that can be used to validate the validty of pSrcBuffer. pSrcBufferAllocStart should be the pointer returned by the malloc() or equivalent call used to allocate the buffer. It will generally be equal to pSrcBuffer (when bufferStride[] values are all positive), but not necessarily. If specified, nSrcBufferAllocSize should be also set to the appropriate value. If no validation is needed, nullptr can be passed.</td></tr>
    <tr><td class="paramname">nSrcBufferAllocSize</td><td>Optional buffer size, that can be used to validate the validty of pSrcBuffer. This is the size of the buffer starting at pSrcBufferAllocStart. If specified, pDstBufferAllocStart should be also set to the appropriate value. If no validation is needed, 0 can be passed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="gdal__priv_8h_source.html">gdal_priv.h</a></li>
<li>gdalmultidim.cpp</li>
<li>gdalmultidim_gridded.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
