<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: OGRCurve Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOGRCurve-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGRCurve Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract curve base class for <a class="el" href="classOGRLineString.html" title="Concrete representation of a multi-vertex line.">OGRLineString</a>, <a class="el" href="classOGRCircularString.html" title="Concrete representation of a circular string, that is to say a curve made of one or several arc circl...">OGRCircularString</a> and <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves.">OGRCompoundCurve</a>.  
 <a href="classOGRCurve.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRCurve:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRCurve.png" usemap="#OGRCurve_map" alt=""/>
  <map id="OGRCurve_map" name="OGRCurve_map">
<area href="classOGRGeometry.html" title="Abstract base class for all geometry classes." alt="OGRGeometry" shape="rect" coords="72,0,206,24"/>
<area href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves." alt="OGRCompoundCurve" shape="rect" coords="0,112,134,136"/>
<area href="classOGRSimpleCurve.html" title="Abstract curve base class for OGRLineString and OGRCircularString." alt="OGRSimpleCurve" shape="rect" coords="144,112,278,136"/>
<area href="classOGRCircularString.html" title="Concrete representation of a circular string, that is to say a curve made of one or several arc circl..." alt="OGRCircularString" shape="rect" coords="72,168,206,192"/>
<area href="classOGRLineString.html" title="Concrete representation of a multi-vertex line." alt="OGRLineString" shape="rect" coords="216,168,350,192"/>
<area href="classOGRLinearRing.html" title="Concrete representation of a closed ring." alt="OGRLinearRing" shape="rect" coords="216,224,350,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a503ba6a7ef7db7c1db3cf61fc26c5cbd"><td class="memItemLeft" align="right" valign="top"><a id="a503ba6a7ef7db7c1db3cf61fc26c5cbd"></a>
typedef <a class="el" href="classOGRPoint.html">OGRPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a503ba6a7ef7db7c1db3cf61fc26c5cbd">ChildType</a></td></tr>
<tr class="memdesc:a503ba6a7ef7db7c1db3cf61fc26c5cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of child elements. <br /></td></tr>
<tr class="separator:a503ba6a7ef7db7c1db3cf61fc26c5cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaad53c365dbcae56712f4deddd891d5b"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#aaad53c365dbcae56712f4deddd891d5b">begin</a> () const</td></tr>
<tr class="memdesc:aaad53c365dbcae56712f4deddd891d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin of a point iterator.  <a href="classOGRCurve.html#aaad53c365dbcae56712f4deddd891d5b">More...</a><br /></td></tr>
<tr class="separator:aaad53c365dbcae56712f4deddd891d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add33cb4d9ab29e3d4e2473ac085f2332"><td class="memItemLeft" align="right" valign="top"><a id="add33cb4d9ab29e3d4e2473ac085f2332"></a>
ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#add33cb4d9ab29e3d4e2473ac085f2332">end</a> () const</td></tr>
<tr class="memdesc:add33cb4d9ab29e3d4e2473ac085f2332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of a point iterator. <br /></td></tr>
<tr class="separator:add33cb4d9ab29e3d4e2473ac085f2332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af857076da2d2adf2ad943d4df56326b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#af857076da2d2adf2ad943d4df56326b9">clone</a> () const override=0</td></tr>
<tr class="memdesc:af857076da2d2adf2ad943d4df56326b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of this object.  <a href="classOGRCurve.html#af857076da2d2adf2ad943d4df56326b9">More...</a><br /></td></tr>
<tr class="separator:af857076da2d2adf2ad943d4df56326b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d2e65489ca56fc4f09a281b50f3e74"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a09d2e65489ca56fc4f09a281b50f3e74">get_Length</a> () const =0</td></tr>
<tr class="memdesc:a09d2e65489ca56fc4f09a281b50f3e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the curve.  <a href="classOGRCurve.html#a09d2e65489ca56fc4f09a281b50f3e74">More...</a><br /></td></tr>
<tr class="separator:a09d2e65489ca56fc4f09a281b50f3e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28510cf9de71e098b50d241f6ab99cd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a28510cf9de71e098b50d241f6ab99cd1">StartPoint</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *) const =0</td></tr>
<tr class="memdesc:a28510cf9de71e098b50d241f6ab99cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the curve start point.  <a href="classOGRCurve.html#a28510cf9de71e098b50d241f6ab99cd1">More...</a><br /></td></tr>
<tr class="separator:a28510cf9de71e098b50d241f6ab99cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9e8e178c7e70efdecd1c50d95d537e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a2e9e8e178c7e70efdecd1c50d95d537e">EndPoint</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *) const =0</td></tr>
<tr class="memdesc:a2e9e8e178c7e70efdecd1c50d95d537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the curve end point.  <a href="classOGRCurve.html#a2e9e8e178c7e70efdecd1c50d95d537e">More...</a><br /></td></tr>
<tr class="separator:a2e9e8e178c7e70efdecd1c50d95d537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c046d6a445e958cd370437f63db8d8e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a6c046d6a445e958cd370437f63db8d8e">get_IsClosed</a> () const</td></tr>
<tr class="memdesc:a6c046d6a445e958cd370437f63db8d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if curve is closed.  <a href="classOGRCurve.html#a6c046d6a445e958cd370437f63db8d8e">More...</a><br /></td></tr>
<tr class="separator:a6c046d6a445e958cd370437f63db8d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690570c5282483c043c0badbf94ce38b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a690570c5282483c043c0badbf94ce38b">Value</a> (double, <a class="el" href="classOGRPoint.html">OGRPoint</a> *) const =0</td></tr>
<tr class="memdesc:a690570c5282483c043c0badbf94ce38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch point at given distance along curve.  <a href="classOGRCurve.html#a690570c5282483c043c0badbf94ce38b">More...</a><br /></td></tr>
<tr class="separator:a690570c5282483c043c0badbf94ce38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003935f17119f329b1c00008d9fbcac7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a003935f17119f329b1c00008d9fbcac7">CurveToLine</a> (double dfMaxAngleStepSizeDegrees=0, const char *const *papszOptions=nullptr) const =0</td></tr>
<tr class="memdesc:a003935f17119f329b1c00008d9fbcac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a linestring from a curve geometry.  <a href="classOGRCurve.html#a003935f17119f329b1c00008d9fbcac7">More...</a><br /></td></tr>
<tr class="separator:a003935f17119f329b1c00008d9fbcac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1abb0177b55c0ef8320832e5096101"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a0d1abb0177b55c0ef8320832e5096101">getDimension</a> () const override</td></tr>
<tr class="memdesc:a0d1abb0177b55c0ef8320832e5096101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of this object.  <a href="classOGRCurve.html#a0d1abb0177b55c0ef8320832e5096101">More...</a><br /></td></tr>
<tr class="separator:a0d1abb0177b55c0ef8320832e5096101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd7942e610dbbafea8814cc1e330cb4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a2fd7942e610dbbafea8814cc1e330cb4">getNumPoints</a> () const =0</td></tr>
<tr class="memdesc:a2fd7942e610dbbafea8814cc1e330cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of points of a curve geometry.  <a href="classOGRCurve.html#a2fd7942e610dbbafea8814cc1e330cb4">More...</a><br /></td></tr>
<tr class="separator:a2fd7942e610dbbafea8814cc1e330cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0e729a1330a28dd40a66d0396b7d9c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRPointIterator.html">OGRPointIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a6a0e729a1330a28dd40a66d0396b7d9c">getPointIterator</a> () const =0</td></tr>
<tr class="memdesc:a6a0e729a1330a28dd40a66d0396b7d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a point iterator over the curve.  <a href="classOGRCurve.html#a6a0e729a1330a28dd40a66d0396b7d9c">More...</a><br /></td></tr>
<tr class="separator:a6a0e729a1330a28dd40a66d0396b7d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac124a8520c4fbd02fd9b4b0e9ba42c0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#ac124a8520c4fbd02fd9b4b0e9ba42c0a">IsConvex</a> () const</td></tr>
<tr class="memdesc:ac124a8520c4fbd02fd9b4b0e9ba42c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a (closed) curve forms a convex shape.  <a href="classOGRCurve.html#ac124a8520c4fbd02fd9b4b0e9ba42c0a">More...</a><br /></td></tr>
<tr class="separator:ac124a8520c4fbd02fd9b4b0e9ba42c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25187cc705e970be8d7f311c6b02808"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#ac25187cc705e970be8d7f311c6b02808">get_Area</a> () const =0</td></tr>
<tr class="memdesc:ac25187cc705e970be8d7f311c6b02808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the area of the (closed) curve.  <a href="classOGRCurve.html#ac25187cc705e970be8d7f311c6b02808">More...</a><br /></td></tr>
<tr class="separator:ac25187cc705e970be8d7f311c6b02808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7711a5d7cff10b67f75949f7a494c0e2"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a7711a5d7cff10b67f75949f7a494c0e2">get_GeodesicArea</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRSOverride=nullptr) const =0</td></tr>
<tr class="memdesc:a7711a5d7cff10b67f75949f7a494c0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the area of the (closed) curve, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry.  <a href="classOGRCurve.html#a7711a5d7cff10b67f75949f7a494c0e2">More...</a><br /></td></tr>
<tr class="separator:a7711a5d7cff10b67f75949f7a494c0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda3c4627b8de0b9066e0133e6a65cb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#abda3c4627b8de0b9066e0133e6a65cb1">isClockwise</a> () const</td></tr>
<tr class="memdesc:abda3c4627b8de0b9066e0133e6a65cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the ring has clockwise winding (or less than 2 points)  <a href="classOGRCurve.html#abda3c4627b8de0b9066e0133e6a65cb1">More...</a><br /></td></tr>
<tr class="separator:abda3c4627b8de0b9066e0133e6a65cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e3b0fc468d61eb3b7516154fe648e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#ac7e3b0fc468d61eb3b7516154fe648e8">toSimpleCurve</a> ()</td></tr>
<tr class="memdesc:ac7e3b0fc468d61eb3b7516154fe648e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSimpleCurve*.  <a href="classOGRCurve.html#ac7e3b0fc468d61eb3b7516154fe648e8">More...</a><br /></td></tr>
<tr class="separator:ac7e3b0fc468d61eb3b7516154fe648e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b329aac356125fffd2cc50f5788e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a253b329aac356125fffd2cc50f5788e4">toSimpleCurve</a> () const</td></tr>
<tr class="memdesc:a253b329aac356125fffd2cc50f5788e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSimpleCurve*.  <a href="classOGRCurve.html#a253b329aac356125fffd2cc50f5788e4">More...</a><br /></td></tr>
<tr class="separator:a253b329aac356125fffd2cc50f5788e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e450007526af0a112b714f767732f58"><td class="memItemLeft" align="right" valign="top"><a id="a8e450007526af0a112b714f767732f58"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a8e450007526af0a112b714f767732f58">operator==</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other) const</td></tr>
<tr class="memdesc:a8e450007526af0a112b714f767732f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if two geometries are equal. <br /></td></tr>
<tr class="separator:a8e450007526af0a112b714f767732f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4e244846a69276bee362db04e15907"><td class="memItemLeft" align="right" valign="top"><a id="a2f4e244846a69276bee362db04e15907"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2f4e244846a69276bee362db04e15907">operator!=</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> &amp;other) const</td></tr>
<tr class="memdesc:a2f4e244846a69276bee362db04e15907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if two geometries are different. <br /></td></tr>
<tr class="separator:a2f4e244846a69276bee362db04e15907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6fdd4df7c043558b5428d8f1c35b16"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16">getCoordinateDimension</a> () const</td></tr>
<tr class="memdesc:a4a6fdd4df7c043558b5428d8f1c35b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <a href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16">More...</a><br /></td></tr>
<tr class="separator:a4a6fdd4df7c043558b5428d8f1c35b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c4f4d75ec84fa225a9a4dee0a609c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1">CoordinateDimension</a> () const</td></tr>
<tr class="memdesc:a35c4f4d75ec84fa225a9a4dee0a609c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this object.  <a href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1">More...</a><br /></td></tr>
<tr class="separator:a35c4f4d75ec84fa225a9a4dee0a609c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8653ba97e53f3e3b041946ca2acc111"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">IsEmpty</a> () const =0</td></tr>
<tr class="memdesc:ac8653ba97e53f3e3b041946ca2acc111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE (non-zero) if the object has no points.  <a href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111">More...</a><br /></td></tr>
<tr class="separator:ac8653ba97e53f3e3b041946ca2acc111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681c8b8f8136764fd689ffbce24085d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3">IsValid</a> () const</td></tr>
<tr class="memdesc:a681c8b8f8136764fd689ffbce24085d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is valid.  <a href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3">More...</a><br /></td></tr>
<tr class="separator:a681c8b8f8136764fd689ffbce24085d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700a2d4b1c719e1f65fa3009bfc04f78"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a700a2d4b1c719e1f65fa3009bfc04f78">MakeValid</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a700a2d4b1c719e1f65fa3009bfc04f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to make an invalid geometry valid without losing vertices.  <a href="classOGRGeometry.html#a700a2d4b1c719e1f65fa3009bfc04f78">More...</a><br /></td></tr>
<tr class="separator:a700a2d4b1c719e1f65fa3009bfc04f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa518a2cafc2a2394bc3a5196fa7dd017"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa518a2cafc2a2394bc3a5196fa7dd017">Normalize</a> () const</td></tr>
<tr class="memdesc:aa518a2cafc2a2394bc3a5196fa7dd017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to bring geometry into normalized/canonical form.  <a href="classOGRGeometry.html#aa518a2cafc2a2394bc3a5196fa7dd017">More...</a><br /></td></tr>
<tr class="separator:aa518a2cafc2a2394bc3a5196fa7dd017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41ef903c94999a81a98c356b32e624"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afe41ef903c94999a81a98c356b32e624">IsSimple</a> () const</td></tr>
<tr class="memdesc:afe41ef903c94999a81a98c356b32e624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is simple.  <a href="classOGRGeometry.html#afe41ef903c94999a81a98c356b32e624">More...</a><br /></td></tr>
<tr class="separator:afe41ef903c94999a81a98c356b32e624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9867dbbd6b840ca9c9240c7cb9c3b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae9867dbbd6b840ca9c9240c7cb9c3b8c">Is3D</a> () const</td></tr>
<tr class="separator:ae9867dbbd6b840ca9c9240c7cb9c3b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959d5776c17018e362b580b1e61e1caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a959d5776c17018e362b580b1e61e1caa">IsMeasured</a> () const</td></tr>
<tr class="separator:a959d5776c17018e362b580b1e61e1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3c69f5b89fa5eb0bfb03e4880822bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afe3c69f5b89fa5eb0bfb03e4880822bf">IsRing</a> () const</td></tr>
<tr class="memdesc:afe3c69f5b89fa5eb0bfb03e4880822bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is a ring.  <a href="classOGRGeometry.html#afe3c69f5b89fa5eb0bfb03e4880822bf">More...</a><br /></td></tr>
<tr class="separator:afe3c69f5b89fa5eb0bfb03e4880822bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1702b5b8142abe761061a6cd44e50b05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">empty</a> ()=0</td></tr>
<tr class="memdesc:a1702b5b8142abe761061a6cd44e50b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear geometry information.  <a href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05">More...</a><br /></td></tr>
<tr class="separator:a1702b5b8142abe761061a6cd44e50b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d42b06ae6f7bbef6d1a2886da8d398"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">getEnvelope</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psEnvelope) const =0</td></tr>
<tr class="memdesc:aa3d42b06ae6f7bbef6d1a2886da8d398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398">More...</a><br /></td></tr>
<tr class="separator:aa3d42b06ae6f7bbef6d1a2886da8d398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3926892dbde299ffd652ee109b5967c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">getEnvelope</a> (<a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psEnvelope) const =0</td></tr>
<tr class="memdesc:a3926892dbde299ffd652ee109b5967c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="classOGRGeometry.html#a3926892dbde299ffd652ee109b5967c5">More...</a><br /></td></tr>
<tr class="separator:a3926892dbde299ffd652ee109b5967c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1a8164dae2e44e50990756ed6b8b4a"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">WkbSize</a> () const =0</td></tr>
<tr class="memdesc:acd1a8164dae2e44e50990756ed6b8b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of related binary representation.  <a href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a">More...</a><br /></td></tr>
<tr class="separator:acd1a8164dae2e44e50990756ed6b8b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2231c970e4075202cafb4f6a69e07e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae2231c970e4075202cafb4f6a69e07e6">importFromWkb</a> (const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *, size_t=static_cast&lt; size_t &gt;(-1), <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>)</td></tr>
<tr class="memdesc:ae2231c970e4075202cafb4f6a69e07e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="classOGRGeometry.html#ae2231c970e4075202cafb4f6a69e07e6">More...</a><br /></td></tr>
<tr class="separator:ae2231c970e4075202cafb4f6a69e07e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe73abb288066cc511546350829c136"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0fe73abb288066cc511546350829c136">importFromWkb</a> (const unsigned char *, size_t, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>, size_t &amp;nBytesConsumedOut)=0</td></tr>
<tr class="memdesc:a0fe73abb288066cc511546350829c136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="classOGRGeometry.html#a0fe73abb288066cc511546350829c136">More...</a><br /></td></tr>
<tr class="separator:a0fe73abb288066cc511546350829c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4bcfa2fd949bf8c889a1b128a6dbb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abf4bcfa2fd949bf8c889a1b128a6dbb5">exportToWkb</a> (<a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>) const</td></tr>
<tr class="memdesc:abf4bcfa2fd949bf8c889a1b128a6dbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="classOGRGeometry.html#abf4bcfa2fd949bf8c889a1b128a6dbb5">More...</a><br /></td></tr>
<tr class="separator:abf4bcfa2fd949bf8c889a1b128a6dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96db112c727147a65329c1eea1ca57b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a96db112c727147a65329c1eea1ca57b4">exportToWkb</a> (unsigned char *, const <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *=nullptr) const =0</td></tr>
<tr class="memdesc:a96db112c727147a65329c1eea1ca57b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="classOGRGeometry.html#a96db112c727147a65329c1eea1ca57b4">More...</a><br /></td></tr>
<tr class="separator:a96db112c727147a65329c1eea1ca57b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bb0f7cae630c31511766718bcc5b66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66">importFromWkt</a> (const char **ppszInput)=0</td></tr>
<tr class="memdesc:af1bb0f7cae630c31511766718bcc5b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66">More...</a><br /></td></tr>
<tr class="separator:af1bb0f7cae630c31511766718bcc5b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7129d4459a847a8ea6ec8b5efc24c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac7129d4459a847a8ea6ec8b5efc24c71">importFromWkt</a> (char **ppszInput)</td></tr>
<tr class="memdesc:ac7129d4459a847a8ea6ec8b5efc24c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <a href="classOGRGeometry.html#ac7129d4459a847a8ea6ec8b5efc24c71">More...</a><br /></td></tr>
<tr class="separator:ac7129d4459a847a8ea6ec8b5efc24c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17cfebfd9826a22763dff6280ba196e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad17cfebfd9826a22763dff6280ba196e">exportToWkt</a> (char **ppszDstText, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>=<a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a>) const</td></tr>
<tr class="memdesc:ad17cfebfd9826a22763dff6280ba196e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="classOGRGeometry.html#ad17cfebfd9826a22763dff6280ba196e">More...</a><br /></td></tr>
<tr class="separator:ad17cfebfd9826a22763dff6280ba196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5e4417e06fb4726ba80461b30aa289"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afc5e4417e06fb4726ba80461b30aa289">exportToWkt</a> (const <a class="el" href="structOGRWktOptions.html">OGRWktOptions</a> &amp;opts=<a class="el" href="structOGRWktOptions.html">OGRWktOptions</a>(), <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *err=nullptr) const =0</td></tr>
<tr class="memdesc:afc5e4417e06fb4726ba80461b30aa289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a WKT geometry.  <a href="classOGRGeometry.html#afc5e4417e06fb4726ba80461b30aa289">More...</a><br /></td></tr>
<tr class="separator:afc5e4417e06fb4726ba80461b30aa289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6bca18682cb933e3227552d480e1a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">getGeometryType</a> () const =0</td></tr>
<tr class="memdesc:a5c6bca18682cb933e3227552d480e1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type.  <a href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5">More...</a><br /></td></tr>
<tr class="separator:a5c6bca18682cb933e3227552d480e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3989a0ff917a1e46d02170033996329"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac3989a0ff917a1e46d02170033996329">getIsoGeometryType</a> () const</td></tr>
<tr class="memdesc:ac3989a0ff917a1e46d02170033996329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the geometry type that conforms with ISO SQL/MM Part3.  <a href="classOGRGeometry.html#ac3989a0ff917a1e46d02170033996329">More...</a><br /></td></tr>
<tr class="separator:ac3989a0ff917a1e46d02170033996329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba109e1c53ce1452942f85eae66d88b8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">getGeometryName</a> () const =0</td></tr>
<tr class="memdesc:aba109e1c53ce1452942f85eae66d88b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8">More...</a><br /></td></tr>
<tr class="separator:aba109e1c53ce1452942f85eae66d88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8836b9e2d6a79eee8f88c61718e1e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae8836b9e2d6a79eee8f88c61718e1e50">dumpReadable</a> (FILE *, const char *=nullptr, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:ae8836b9e2d6a79eee8f88c61718e1e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="classOGRGeometry.html#ae8836b9e2d6a79eee8f88c61718e1e50">More...</a><br /></td></tr>
<tr class="separator:ae8836b9e2d6a79eee8f88c61718e1e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360570554fcd805f9fe673062ba5a22b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a360570554fcd805f9fe673062ba5a22b">dumpReadable</a> (const char *=nullptr, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a360570554fcd805f9fe673062ba5a22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="classOGRGeometry.html#a360570554fcd805f9fe673062ba5a22b">More...</a><br /></td></tr>
<tr class="separator:a360570554fcd805f9fe673062ba5a22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1a2ced937a5900b2bfeb717bad6c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">flattenTo2D</a> ()=0</td></tr>
<tr class="memdesc:aaae1a2ced937a5900b2bfeb717bad6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry to strictly 2D.  <a href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9">More...</a><br /></td></tr>
<tr class="separator:aaae1a2ced937a5900b2bfeb717bad6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd63002f416db1ea0eb24857b5ef9f2"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2">exportToGML</a> (const char *const *papszOptions=nullptr) const</td></tr>
<tr class="memdesc:abbd63002f416db1ea0eb24857b5ef9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2">More...</a><br /></td></tr>
<tr class="separator:abbd63002f416db1ea0eb24857b5ef9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73487475ea43a2e677fe0556bf738e0"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab73487475ea43a2e677fe0556bf738e0">exportToKML</a> () const</td></tr>
<tr class="memdesc:ab73487475ea43a2e677fe0556bf738e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into KML format.  <a href="classOGRGeometry.html#ab73487475ea43a2e677fe0556bf738e0">More...</a><br /></td></tr>
<tr class="separator:ab73487475ea43a2e677fe0556bf738e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39899a5c670d2475281cbf5adf8fa97"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af39899a5c670d2475281cbf5adf8fa97">exportToJson</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr) const</td></tr>
<tr class="memdesc:af39899a5c670d2475281cbf5adf8fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="classOGRGeometry.html#af39899a5c670d2475281cbf5adf8fa97">More...</a><br /></td></tr>
<tr class="separator:af39899a5c670d2475281cbf5adf8fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26576c266578a8e83e325881243a166"><td class="memItemLeft" align="right" valign="top"><a id="aa26576c266578a8e83e325881243a166"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa26576c266578a8e83e325881243a166">accept</a> (<a class="el" href="classIOGRGeometryVisitor.html">IOGRGeometryVisitor</a> *visitor)=0</td></tr>
<tr class="memdesc:aa26576c266578a8e83e325881243a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor. <br /></td></tr>
<tr class="separator:aa26576c266578a8e83e325881243a166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f659bec82c0184b3bd6592248afda74"><td class="memItemLeft" align="right" valign="top"><a id="a5f659bec82c0184b3bd6592248afda74"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5f659bec82c0184b3bd6592248afda74">accept</a> (<a class="el" href="classIOGRConstGeometryVisitor.html">IOGRConstGeometryVisitor</a> *visitor) const =0</td></tr>
<tr class="memdesc:a5f659bec82c0184b3bd6592248afda74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor. <br /></td></tr>
<tr class="separator:a5f659bec82c0184b3bd6592248afda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adbc7e5862ce784ee4aee0f6c5bf294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0adbc7e5862ce784ee4aee0f6c5bf294">exportToGEOS</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt, bool bRemoveEmptyParts=false) const</td></tr>
<tr class="memdesc:a0adbc7e5862ce784ee4aee0f6c5bf294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a GEOSGeom object corresponding to the geometry.  <a href="classOGRGeometry.html#a0adbc7e5862ce784ee4aee0f6c5bf294">More...</a><br /></td></tr>
<tr class="separator:a0adbc7e5862ce784ee4aee0f6c5bf294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15afb03f64091205af0530d8d1262798"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a15afb03f64091205af0530d8d1262798">hasCurveGeometry</a> (int bLookForNonLinear=FALSE) const</td></tr>
<tr class="memdesc:a15afb03f64091205af0530d8d1262798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this geometry is or has curve geometry.  <a href="classOGRGeometry.html#a15afb03f64091205af0530d8d1262798">More...</a><br /></td></tr>
<tr class="separator:a15afb03f64091205af0530d8d1262798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1068398fd3af02de78bd2b9dbbb837f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1">getCurveGeometry</a> (const char *const *papszOptions=nullptr) const</td></tr>
<tr class="memdesc:a1068398fd3af02de78bd2b9dbbb837f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return curve version of this geometry.  <a href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1">More...</a><br /></td></tr>
<tr class="separator:a1068398fd3af02de78bd2b9dbbb837f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1408cd0015a83b697eb27aebaf5480"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480">getLinearGeometry</a> (double dfMaxAngleStepSizeDegrees=0, const char *const *papszOptions=nullptr) const</td></tr>
<tr class="memdesc:ada1408cd0015a83b697eb27aebaf5480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, possibly approximate, non-curve version of this geometry.  <a href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480">More...</a><br /></td></tr>
<tr class="separator:ada1408cd0015a83b697eb27aebaf5480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f008712013032d876cc60860d317a33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33">roundCoordinates</a> (const <a class="el" href="structOGRGeomCoordinatePrecision.html">OGRGeomCoordinatePrecision</a> &amp;sPrecision)</td></tr>
<tr class="memdesc:a0f008712013032d876cc60860d317a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round coordinates of the geometry to the specified precision.  <a href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33">More...</a><br /></td></tr>
<tr class="separator:a0f008712013032d876cc60860d317a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3667da6ea2f9416c8f1b747391d0171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad3667da6ea2f9416c8f1b747391d0171">roundCoordinatesIEEE754</a> (const <a class="el" href="structOGRGeomCoordinateBinaryPrecision.html">OGRGeomCoordinateBinaryPrecision</a> &amp;options)</td></tr>
<tr class="memdesc:ad3667da6ea2f9416c8f1b747391d0171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round coordinates of a geometry, exploiting characteristics of the IEEE-754 double-precision binary representation.  <a href="classOGRGeometry.html#ad3667da6ea2f9416c8f1b747391d0171">More...</a><br /></td></tr>
<tr class="separator:ad3667da6ea2f9416c8f1b747391d0171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6cf249316b3046e0d4f77ec400e844"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">closeRings</a> ()</td></tr>
<tr class="memdesc:aeb6cf249316b3046e0d4f77ec400e844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force rings to be closed.  <a href="classOGRGeometry.html#aeb6cf249316b3046e0d4f77ec400e844">More...</a><br /></td></tr>
<tr class="separator:aeb6cf249316b3046e0d4f77ec400e844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f84a2b948d511f28c47c47577dea49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">setCoordinateDimension</a> (int nDimension)</td></tr>
<tr class="memdesc:a79f84a2b948d511f28c47c47577dea49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate dimension.  <a href="classOGRGeometry.html#a79f84a2b948d511f28c47c47577dea49">More...</a><br /></td></tr>
<tr class="separator:a79f84a2b948d511f28c47c47577dea49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dc0ab8f5269e24faad26387e344913"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913">set3D</a> (<a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> bIs3D)</td></tr>
<tr class="memdesc:ad4dc0ab8f5269e24faad26387e344913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the Z coordinate dimension.  <a href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913">More...</a><br /></td></tr>
<tr class="separator:ad4dc0ab8f5269e24faad26387e344913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d7eea437838415a14f9dc54523857"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857">setMeasured</a> (<a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> bIsMeasured)</td></tr>
<tr class="memdesc:a5f1d7eea437838415a14f9dc54523857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the M coordinate dimension.  <a href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857">More...</a><br /></td></tr>
<tr class="separator:a5f1d7eea437838415a14f9dc54523857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57de03effd32d0d09cbdc0ed146b508"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af57de03effd32d0d09cbdc0ed146b508">assignSpatialReference</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr class="memdesc:af57de03effd32d0d09cbdc0ed146b508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign spatial reference to this object.  <a href="classOGRGeometry.html#af57de03effd32d0d09cbdc0ed146b508">More...</a><br /></td></tr>
<tr class="separator:af57de03effd32d0d09cbdc0ed146b508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a53c103e37c6d1ead00d2d74586ddd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd">getSpatialReference</a> (void) const</td></tr>
<tr class="memdesc:a66a53c103e37c6d1ead00d2d74586ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial reference system for object.  <a href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd">More...</a><br /></td></tr>
<tr class="separator:a66a53c103e37c6d1ead00d2d74586ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e8bfb3c2129f25cf622660f734e1ba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">transform</a> (<a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *poCT)=0</td></tr>
<tr class="memdesc:aa9e8bfb3c2129f25cf622660f734e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba">More...</a><br /></td></tr>
<tr class="separator:aa9e8bfb3c2129f25cf622660f734e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0ec206bcafdd27eef5ef455d366af3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abc0ec206bcafdd27eef5ef455d366af3">transformTo</a> (const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSR)</td></tr>
<tr class="memdesc:abc0ec206bcafdd27eef5ef455d366af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <a href="classOGRGeometry.html#abc0ec206bcafdd27eef5ef455d366af3">More...</a><br /></td></tr>
<tr class="separator:abc0ec206bcafdd27eef5ef455d366af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91685bd7c0bdd67cd073a8b4da3c06a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">segmentize</a> (double dfMaxLength)</td></tr>
<tr class="memdesc:a91685bd7c0bdd67cd073a8b4da3c06a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5">More...</a><br /></td></tr>
<tr class="separator:a91685bd7c0bdd67cd073a8b4da3c06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b9bf1e607908703d68bcdd5a82440c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c">Intersects</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a12b9bf1e607908703d68bcdd5a82440c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these features intersect?  <a href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c">More...</a><br /></td></tr>
<tr class="separator:a12b9bf1e607908703d68bcdd5a82440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b80c7f464de1d332215f16d35138590"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590">Equals</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const =0</td></tr>
<tr class="memdesc:a1b80c7f464de1d332215f16d35138590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590">More...</a><br /></td></tr>
<tr class="separator:a1b80c7f464de1d332215f16d35138590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f0b34b165b589ffbef7d3ea65c00c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aaa4f0b34b165b589ffbef7d3ea65c00c">Disjoint</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:aaa4f0b34b165b589ffbef7d3ea65c00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for disjointness.  <a href="classOGRGeometry.html#aaa4f0b34b165b589ffbef7d3ea65c00c">More...</a><br /></td></tr>
<tr class="separator:aaa4f0b34b165b589ffbef7d3ea65c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1be78538ab56a7c16cfa65797eeb0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abd1be78538ab56a7c16cfa65797eeb0c">Touches</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:abd1be78538ab56a7c16cfa65797eeb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for touching.  <a href="classOGRGeometry.html#abd1be78538ab56a7c16cfa65797eeb0c">More...</a><br /></td></tr>
<tr class="separator:abd1be78538ab56a7c16cfa65797eeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf30cb59307e8d5889e9fcf71d371afb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adf30cb59307e8d5889e9fcf71d371afb">Crosses</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:adf30cb59307e8d5889e9fcf71d371afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for crossing.  <a href="classOGRGeometry.html#adf30cb59307e8d5889e9fcf71d371afb">More...</a><br /></td></tr>
<tr class="separator:adf30cb59307e8d5889e9fcf71d371afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9803164ead0c4fbea9eafce64184160c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9803164ead0c4fbea9eafce64184160c">Within</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a9803164ead0c4fbea9eafce64184160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="classOGRGeometry.html#a9803164ead0c4fbea9eafce64184160c">More...</a><br /></td></tr>
<tr class="separator:a9803164ead0c4fbea9eafce64184160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae818178178f80c2987c6173ab4da041e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae818178178f80c2987c6173ab4da041e">Contains</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:ae818178178f80c2987c6173ab4da041e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="classOGRGeometry.html#ae818178178f80c2987c6173ab4da041e">More...</a><br /></td></tr>
<tr class="separator:ae818178178f80c2987c6173ab4da041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432b89868f8094004467e8e9b51ad5ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a432b89868f8094004467e8e9b51ad5ca">Overlaps</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a432b89868f8094004467e8e9b51ad5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for overlap.  <a href="classOGRGeometry.html#a432b89868f8094004467e8e9b51ad5ca">More...</a><br /></td></tr>
<tr class="separator:a432b89868f8094004467e8e9b51ad5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8eebc159f59a20d63f40539577dde7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abb8eebc159f59a20d63f40539577dde7">Boundary</a> () const</td></tr>
<tr class="memdesc:abb8eebc159f59a20d63f40539577dde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute boundary.  <a href="classOGRGeometry.html#abb8eebc159f59a20d63f40539577dde7">More...</a><br /></td></tr>
<tr class="separator:abb8eebc159f59a20d63f40539577dde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e832f8dc1001de35e9e888a4bae8b3"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a72e832f8dc1001de35e9e888a4bae8b3">Distance</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a72e832f8dc1001de35e9e888a4bae8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two geometries.  <a href="classOGRGeometry.html#a72e832f8dc1001de35e9e888a4bae8b3">More...</a><br /></td></tr>
<tr class="separator:a72e832f8dc1001de35e9e888a4bae8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83020c007c4f3beabe1e01edba173135"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a83020c007c4f3beabe1e01edba173135">ConvexHull</a> () const</td></tr>
<tr class="memdesc:a83020c007c4f3beabe1e01edba173135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull.  <a href="classOGRGeometry.html#a83020c007c4f3beabe1e01edba173135">More...</a><br /></td></tr>
<tr class="separator:a83020c007c4f3beabe1e01edba173135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eebda9322568a50da1cb8bb2bcf0a9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4eebda9322568a50da1cb8bb2bcf0a9e">ConcaveHull</a> (double dfRatio, bool bAllowHoles) const</td></tr>
<tr class="memdesc:a4eebda9322568a50da1cb8bb2bcf0a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute "concave hull" of a geometry.  <a href="classOGRGeometry.html#a4eebda9322568a50da1cb8bb2bcf0a9e">More...</a><br /></td></tr>
<tr class="separator:a4eebda9322568a50da1cb8bb2bcf0a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8694e757f44388bd6da4cf7be696b7e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a8694e757f44388bd6da4cf7be696b7e7">Buffer</a> (double dfDist, int nQuadSegs=30) const</td></tr>
<tr class="memdesc:a8694e757f44388bd6da4cf7be696b7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <a href="classOGRGeometry.html#a8694e757f44388bd6da4cf7be696b7e7">More...</a><br /></td></tr>
<tr class="separator:a8694e757f44388bd6da4cf7be696b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac226d1821ce677689f1de12bbe6497b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac226d1821ce677689f1de12bbe6497b5">BufferEx</a> (double dfDistance, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) const</td></tr>
<tr class="memdesc:ac226d1821ce677689f1de12bbe6497b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <a href="classOGRGeometry.html#ac226d1821ce677689f1de12bbe6497b5">More...</a><br /></td></tr>
<tr class="separator:ac226d1821ce677689f1de12bbe6497b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc420ca5d995bfef55adb1819a31f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae2fc420ca5d995bfef55adb1819a31f2">Intersection</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:ae2fc420ca5d995bfef55adb1819a31f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute intersection.  <a href="classOGRGeometry.html#ae2fc420ca5d995bfef55adb1819a31f2">More...</a><br /></td></tr>
<tr class="separator:ae2fc420ca5d995bfef55adb1819a31f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4f808adcccaedbecc29fe034d312dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9e4f808adcccaedbecc29fe034d312dc">Union</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a9e4f808adcccaedbecc29fe034d312dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union.  <a href="classOGRGeometry.html#a9e4f808adcccaedbecc29fe034d312dc">More...</a><br /></td></tr>
<tr class="separator:a9e4f808adcccaedbecc29fe034d312dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94533c5ac2331889ac93089c3316971c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a94533c5ac2331889ac93089c3316971c">UnionCascaded</a> () const</td></tr>
<tr class="memdesc:a94533c5ac2331889ac93089c3316971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union using cascading.  <a href="classOGRGeometry.html#a94533c5ac2331889ac93089c3316971c">More...</a><br /></td></tr>
<tr class="separator:a94533c5ac2331889ac93089c3316971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744223cab4361ffcdab949cebf27d5ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a744223cab4361ffcdab949cebf27d5ad">UnaryUnion</a> () const</td></tr>
<tr class="memdesc:a744223cab4361ffcdab949cebf27d5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of all components of a single geometry.  <a href="classOGRGeometry.html#a744223cab4361ffcdab949cebf27d5ad">More...</a><br /></td></tr>
<tr class="separator:a744223cab4361ffcdab949cebf27d5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49d7599f955e3d459c4dd13bbf1f9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a6f49d7599f955e3d459c4dd13bbf1f9e">Difference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:a6f49d7599f955e3d459c4dd13bbf1f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute difference.  <a href="classOGRGeometry.html#a6f49d7599f955e3d459c4dd13bbf1f9e">More...</a><br /></td></tr>
<tr class="separator:a6f49d7599f955e3d459c4dd13bbf1f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a5c298bb0dcc4d44500278238e0ac2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab0a5c298bb0dcc4d44500278238e0ac2">SymDifference</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *) const</td></tr>
<tr class="memdesc:ab0a5c298bb0dcc4d44500278238e0ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symmetric difference.  <a href="classOGRGeometry.html#ab0a5c298bb0dcc4d44500278238e0ac2">More...</a><br /></td></tr>
<tr class="separator:ab0a5c298bb0dcc4d44500278238e0ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91787f669b2a148169667e270e7e40df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a91787f669b2a148169667e270e7e40df">Centroid</a> (<a class="el" href="classOGRPoint.html">OGRPoint</a> *poPoint) const</td></tr>
<tr class="memdesc:a91787f669b2a148169667e270e7e40df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry centroid.  <a href="classOGRGeometry.html#a91787f669b2a148169667e270e7e40df">More...</a><br /></td></tr>
<tr class="separator:a91787f669b2a148169667e270e7e40df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40909bc6bc40b9aecfdae5cb70160eaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a40909bc6bc40b9aecfdae5cb70160eaa">Simplify</a> (double dTolerance) const</td></tr>
<tr class="memdesc:a40909bc6bc40b9aecfdae5cb70160eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry.  <a href="classOGRGeometry.html#a40909bc6bc40b9aecfdae5cb70160eaa">More...</a><br /></td></tr>
<tr class="separator:a40909bc6bc40b9aecfdae5cb70160eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951fc5d0043af5794dd08d738e0a1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3951fc5d0043af5794dd08d738e0a1dc">SimplifyPreserveTopology</a> (double dTolerance) const</td></tr>
<tr class="memdesc:a3951fc5d0043af5794dd08d738e0a1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <a href="classOGRGeometry.html#a3951fc5d0043af5794dd08d738e0a1dc">More...</a><br /></td></tr>
<tr class="separator:a3951fc5d0043af5794dd08d738e0a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b0d68bea79509e675bd773c30eb350"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a45b0d68bea79509e675bd773c30eb350">DelaunayTriangulation</a> (double dfTolerance, int bOnlyEdges) const</td></tr>
<tr class="memdesc:a45b0d68bea79509e675bd773c30eb350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Delaunay triangulation of the vertices of the geometry.  <a href="classOGRGeometry.html#a45b0d68bea79509e675bd773c30eb350">More...</a><br /></td></tr>
<tr class="separator:a45b0d68bea79509e675bd773c30eb350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f35edabf2e5d40a79f07f77d56a2459"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9f35edabf2e5d40a79f07f77d56a2459">Polygonize</a> () const</td></tr>
<tr class="memdesc:a9f35edabf2e5d40a79f07f77d56a2459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <a href="classOGRGeometry.html#a9f35edabf2e5d40a79f07f77d56a2459">More...</a><br /></td></tr>
<tr class="separator:a9f35edabf2e5d40a79f07f77d56a2459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e39301afc475f5fff022af690fcf84"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa2e39301afc475f5fff022af690fcf84">Distance3D</a> (const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poOtherGeom) const</td></tr>
<tr class="memdesc:aa2e39301afc475f5fff022af690fcf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3D distance between two geometries.  <a href="classOGRGeometry.html#aa2e39301afc475f5fff022af690fcf84">More...</a><br /></td></tr>
<tr class="separator:aa2e39301afc475f5fff022af690fcf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db4751a05c870f180fde6f1a6d939c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c">SetPrecision</a> (double dfGridSize, int nFlags) const</td></tr>
<tr class="memdesc:a36db4751a05c870f180fde6f1a6d939c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the geometry's precision, rounding all its coordinates to the precision grid, and making sure the geometry is still valid.  <a href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c">More...</a><br /></td></tr>
<tr class="separator:a36db4751a05c870f180fde6f1a6d939c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c0b7bbebcc6e0dede9d225cd02d7cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa7c0b7bbebcc6e0dede9d225cd02d7cc">hasEmptyParts</a> () const</td></tr>
<tr class="memdesc:aa7c0b7bbebcc6e0dede9d225cd02d7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a geometry has empty parts/rings.  <a href="classOGRGeometry.html#aa7c0b7bbebcc6e0dede9d225cd02d7cc">More...</a><br /></td></tr>
<tr class="separator:aa7c0b7bbebcc6e0dede9d225cd02d7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad660b4366042e85a96f450777d43197e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad660b4366042e85a96f450777d43197e">removeEmptyParts</a> ()</td></tr>
<tr class="memdesc:ad660b4366042e85a96f450777d43197e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove empty parts/rings from this geometry.  <a href="classOGRGeometry.html#ad660b4366042e85a96f450777d43197e">More...</a><br /></td></tr>
<tr class="separator:ad660b4366042e85a96f450777d43197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffd51d4998a8e2ae422c69b6adf480a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">swapXY</a> ()</td></tr>
<tr class="memdesc:a3ffd51d4998a8e2ae422c69b6adf480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap x and y coordinates.  <a href="classOGRGeometry.html#a3ffd51d4998a8e2ae422c69b6adf480a">More...</a><br /></td></tr>
<tr class="separator:a3ffd51d4998a8e2ae422c69b6adf480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc11c1807724ec7e3f3f777ddbede40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0dc11c1807724ec7e3f3f777ddbede40">IsRectangle</a> () const</td></tr>
<tr class="memdesc:a0dc11c1807724ec7e3f3f777ddbede40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the geometry is a polygon with 4 corners forming a rectangle.  <a href="classOGRGeometry.html#a0dc11c1807724ec7e3f3f777ddbede40">More...</a><br /></td></tr>
<tr class="separator:a0dc11c1807724ec7e3f3f777ddbede40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2a41d2ee7091a39fc3f371db9e3825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#acd2a41d2ee7091a39fc3f371db9e3825">toPoint</a> ()</td></tr>
<tr class="memdesc:acd2a41d2ee7091a39fc3f371db9e3825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPoint*.  <a href="classOGRGeometry.html#acd2a41d2ee7091a39fc3f371db9e3825">More...</a><br /></td></tr>
<tr class="separator:acd2a41d2ee7091a39fc3f371db9e3825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad669a3edadb4abd49db97b7d7324a3ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ad669a3edadb4abd49db97b7d7324a3ed">toPoint</a> () const</td></tr>
<tr class="memdesc:ad669a3edadb4abd49db97b7d7324a3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPoint*.  <a href="classOGRGeometry.html#ad669a3edadb4abd49db97b7d7324a3ed">More...</a><br /></td></tr>
<tr class="separator:ad669a3edadb4abd49db97b7d7324a3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d0dbea86042310b29903dd69ed8fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ace2d0dbea86042310b29903dd69ed8fd">toCurve</a> ()</td></tr>
<tr class="memdesc:ace2d0dbea86042310b29903dd69ed8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurve*.  <a href="classOGRGeometry.html#ace2d0dbea86042310b29903dd69ed8fd">More...</a><br /></td></tr>
<tr class="separator:ace2d0dbea86042310b29903dd69ed8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ae22b8c03d3d249f96b5ab73df8d01"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a47ae22b8c03d3d249f96b5ab73df8d01">toCurve</a> () const</td></tr>
<tr class="memdesc:a47ae22b8c03d3d249f96b5ab73df8d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurve*.  <a href="classOGRGeometry.html#a47ae22b8c03d3d249f96b5ab73df8d01">More...</a><br /></td></tr>
<tr class="separator:a47ae22b8c03d3d249f96b5ab73df8d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd4fd93ce3b53eb809d72b301bf6a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a0bd4fd93ce3b53eb809d72b301bf6a6e">toLineString</a> ()</td></tr>
<tr class="memdesc:a0bd4fd93ce3b53eb809d72b301bf6a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLineString*.  <a href="classOGRGeometry.html#a0bd4fd93ce3b53eb809d72b301bf6a6e">More...</a><br /></td></tr>
<tr class="separator:a0bd4fd93ce3b53eb809d72b301bf6a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ca3e2914a891b9500f30057ecfeaba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a87ca3e2914a891b9500f30057ecfeaba">toLineString</a> () const</td></tr>
<tr class="memdesc:a87ca3e2914a891b9500f30057ecfeaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLineString*.  <a href="classOGRGeometry.html#a87ca3e2914a891b9500f30057ecfeaba">More...</a><br /></td></tr>
<tr class="separator:a87ca3e2914a891b9500f30057ecfeaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087c768a91d977f065caa4f7b75e71b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a087c768a91d977f065caa4f7b75e71b6">toLinearRing</a> ()</td></tr>
<tr class="memdesc:a087c768a91d977f065caa4f7b75e71b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLinearRing*.  <a href="classOGRGeometry.html#a087c768a91d977f065caa4f7b75e71b6">More...</a><br /></td></tr>
<tr class="separator:a087c768a91d977f065caa4f7b75e71b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84f8179340c71a8a080f74d667554db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ac84f8179340c71a8a080f74d667554db">toLinearRing</a> () const</td></tr>
<tr class="memdesc:ac84f8179340c71a8a080f74d667554db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRLinearRing*.  <a href="classOGRGeometry.html#ac84f8179340c71a8a080f74d667554db">More...</a><br /></td></tr>
<tr class="separator:ac84f8179340c71a8a080f74d667554db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a3f3726ec41a2579ccaadf34d109b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCircularString.html">OGRCircularString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a07a3f3726ec41a2579ccaadf34d109b9">toCircularString</a> ()</td></tr>
<tr class="memdesc:a07a3f3726ec41a2579ccaadf34d109b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCircularString*.  <a href="classOGRGeometry.html#a07a3f3726ec41a2579ccaadf34d109b9">More...</a><br /></td></tr>
<tr class="separator:a07a3f3726ec41a2579ccaadf34d109b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875b6ecbd4f1676999766e157c3a6534"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCircularString.html">OGRCircularString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a875b6ecbd4f1676999766e157c3a6534">toCircularString</a> () const</td></tr>
<tr class="memdesc:a875b6ecbd4f1676999766e157c3a6534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCircularString*.  <a href="classOGRGeometry.html#a875b6ecbd4f1676999766e157c3a6534">More...</a><br /></td></tr>
<tr class="separator:a875b6ecbd4f1676999766e157c3a6534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60510a2c16c5735dc358bc2a19b1640d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a60510a2c16c5735dc358bc2a19b1640d">toCompoundCurve</a> ()</td></tr>
<tr class="memdesc:a60510a2c16c5735dc358bc2a19b1640d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCompoundCurve*.  <a href="classOGRGeometry.html#a60510a2c16c5735dc358bc2a19b1640d">More...</a><br /></td></tr>
<tr class="separator:a60510a2c16c5735dc358bc2a19b1640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707f30f63e8edaefa72c61bedbf9612b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a707f30f63e8edaefa72c61bedbf9612b">toCompoundCurve</a> () const</td></tr>
<tr class="memdesc:a707f30f63e8edaefa72c61bedbf9612b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCompoundCurve*.  <a href="classOGRGeometry.html#a707f30f63e8edaefa72c61bedbf9612b">More...</a><br /></td></tr>
<tr class="separator:a707f30f63e8edaefa72c61bedbf9612b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab897e836fd4781637a34014833b1ee3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRSurface.html">OGRSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab897e836fd4781637a34014833b1ee3d">toSurface</a> ()</td></tr>
<tr class="memdesc:ab897e836fd4781637a34014833b1ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSurface*.  <a href="classOGRGeometry.html#ab897e836fd4781637a34014833b1ee3d">More...</a><br /></td></tr>
<tr class="separator:ab897e836fd4781637a34014833b1ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c3418b804db5eef7e16b86dee45f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRSurface.html">OGRSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a7d6c3418b804db5eef7e16b86dee45f2">toSurface</a> () const</td></tr>
<tr class="memdesc:a7d6c3418b804db5eef7e16b86dee45f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRSurface*.  <a href="classOGRGeometry.html#a7d6c3418b804db5eef7e16b86dee45f2">More...</a><br /></td></tr>
<tr class="separator:a7d6c3418b804db5eef7e16b86dee45f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dff1a7736b53eb4d98c9176059fb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a27dff1a7736b53eb4d98c9176059fb80">toPolygon</a> ()</td></tr>
<tr class="memdesc:a27dff1a7736b53eb4d98c9176059fb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolygon*.  <a href="classOGRGeometry.html#a27dff1a7736b53eb4d98c9176059fb80">More...</a><br /></td></tr>
<tr class="separator:a27dff1a7736b53eb4d98c9176059fb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947a2bdd824116d5edef0361bca4eb8a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPolygon.html">OGRPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a947a2bdd824116d5edef0361bca4eb8a">toPolygon</a> () const</td></tr>
<tr class="memdesc:a947a2bdd824116d5edef0361bca4eb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolygon*.  <a href="classOGRGeometry.html#a947a2bdd824116d5edef0361bca4eb8a">More...</a><br /></td></tr>
<tr class="separator:a947a2bdd824116d5edef0361bca4eb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62fb2faaa7fe58555a39509a5ef2714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRTriangle.html">OGRTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#aa62fb2faaa7fe58555a39509a5ef2714">toTriangle</a> ()</td></tr>
<tr class="memdesc:aa62fb2faaa7fe58555a39509a5ef2714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangle*.  <a href="classOGRGeometry.html#aa62fb2faaa7fe58555a39509a5ef2714">More...</a><br /></td></tr>
<tr class="separator:aa62fb2faaa7fe58555a39509a5ef2714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9439b0742c3bb6173c221357befb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRTriangle.html">OGRTriangle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abad9439b0742c3bb6173c221357befb5">toTriangle</a> () const</td></tr>
<tr class="memdesc:abad9439b0742c3bb6173c221357befb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangle*.  <a href="classOGRGeometry.html#abad9439b0742c3bb6173c221357befb5">More...</a><br /></td></tr>
<tr class="separator:abad9439b0742c3bb6173c221357befb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2307d44f31cc898ecbc2c8349bbc82f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a2307d44f31cc898ecbc2c8349bbc82f9">toCurvePolygon</a> ()</td></tr>
<tr class="memdesc:a2307d44f31cc898ecbc2c8349bbc82f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurvePolygon*.  <a href="classOGRGeometry.html#a2307d44f31cc898ecbc2c8349bbc82f9">More...</a><br /></td></tr>
<tr class="separator:a2307d44f31cc898ecbc2c8349bbc82f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ec9e634d5afc42f0891b5cf3e5f92a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a11ec9e634d5afc42f0891b5cf3e5f92a">toCurvePolygon</a> () const</td></tr>
<tr class="memdesc:a11ec9e634d5afc42f0891b5cf3e5f92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRCurvePolygon*.  <a href="classOGRGeometry.html#a11ec9e634d5afc42f0891b5cf3e5f92a">More...</a><br /></td></tr>
<tr class="separator:a11ec9e634d5afc42f0891b5cf3e5f92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdf3c79104eb641260abcc2b4a7cc43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a9fdf3c79104eb641260abcc2b4a7cc43">toGeometryCollection</a> ()</td></tr>
<tr class="memdesc:a9fdf3c79104eb641260abcc2b4a7cc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRGeometryCollection*.  <a href="classOGRGeometry.html#a9fdf3c79104eb641260abcc2b4a7cc43">More...</a><br /></td></tr>
<tr class="separator:a9fdf3c79104eb641260abcc2b4a7cc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304deeb16cfc1c986cd9b587918113d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a304deeb16cfc1c986cd9b587918113d0">toGeometryCollection</a> () const</td></tr>
<tr class="memdesc:a304deeb16cfc1c986cd9b587918113d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRGeometryCollection*.  <a href="classOGRGeometry.html#a304deeb16cfc1c986cd9b587918113d0">More...</a><br /></td></tr>
<tr class="separator:a304deeb16cfc1c986cd9b587918113d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cd71af4f5c75ac0b9ccd64bd4b1117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab7cd71af4f5c75ac0b9ccd64bd4b1117">toMultiPoint</a> ()</td></tr>
<tr class="memdesc:ab7cd71af4f5c75ac0b9ccd64bd4b1117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPoint*.  <a href="classOGRGeometry.html#ab7cd71af4f5c75ac0b9ccd64bd4b1117">More...</a><br /></td></tr>
<tr class="separator:ab7cd71af4f5c75ac0b9ccd64bd4b1117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b970c7593290b0c8c17d07bd907e3d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a1b970c7593290b0c8c17d07bd907e3d8">toMultiPoint</a> () const</td></tr>
<tr class="memdesc:a1b970c7593290b0c8c17d07bd907e3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPoint*.  <a href="classOGRGeometry.html#a1b970c7593290b0c8c17d07bd907e3d8">More...</a><br /></td></tr>
<tr class="separator:a1b970c7593290b0c8c17d07bd907e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a79860e0f5a7f7e1962a0854d140f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4a79860e0f5a7f7e1962a0854d140f6d">toMultiLineString</a> ()</td></tr>
<tr class="memdesc:a4a79860e0f5a7f7e1962a0854d140f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiLineString*.  <a href="classOGRGeometry.html#a4a79860e0f5a7f7e1962a0854d140f6d">More...</a><br /></td></tr>
<tr class="separator:a4a79860e0f5a7f7e1962a0854d140f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ee3c54d11a08bdf87d9729bfd6de7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ab35ee3c54d11a08bdf87d9729bfd6de7">toMultiLineString</a> () const</td></tr>
<tr class="memdesc:ab35ee3c54d11a08bdf87d9729bfd6de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiLineString*.  <a href="classOGRGeometry.html#ab35ee3c54d11a08bdf87d9729bfd6de7">More...</a><br /></td></tr>
<tr class="separator:ab35ee3c54d11a08bdf87d9729bfd6de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e387baec4de093ff6af3ec7ad76cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a07e387baec4de093ff6af3ec7ad76cbe">toMultiPolygon</a> ()</td></tr>
<tr class="memdesc:a07e387baec4de093ff6af3ec7ad76cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPolygon*.  <a href="classOGRGeometry.html#a07e387baec4de093ff6af3ec7ad76cbe">More...</a><br /></td></tr>
<tr class="separator:a07e387baec4de093ff6af3ec7ad76cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2f638c062af644f6ced36e7a50c21"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a26e2f638c062af644f6ced36e7a50c21">toMultiPolygon</a> () const</td></tr>
<tr class="memdesc:a26e2f638c062af644f6ced36e7a50c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiPolygon*.  <a href="classOGRGeometry.html#a26e2f638c062af644f6ced36e7a50c21">More...</a><br /></td></tr>
<tr class="separator:a26e2f638c062af644f6ced36e7a50c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8345d52f5748268059f485790ad8b3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a8345d52f5748268059f485790ad8b3a1">toMultiCurve</a> ()</td></tr>
<tr class="memdesc:a8345d52f5748268059f485790ad8b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiCurve*.  <a href="classOGRGeometry.html#a8345d52f5748268059f485790ad8b3a1">More...</a><br /></td></tr>
<tr class="separator:a8345d52f5748268059f485790ad8b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bac4f129be3a7c6c39a26d5d77d1f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a80bac4f129be3a7c6c39a26d5d77d1f2">toMultiCurve</a> () const</td></tr>
<tr class="memdesc:a80bac4f129be3a7c6c39a26d5d77d1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiCurve*.  <a href="classOGRGeometry.html#a80bac4f129be3a7c6c39a26d5d77d1f2">More...</a><br /></td></tr>
<tr class="separator:a80bac4f129be3a7c6c39a26d5d77d1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bfa0ab44ce276ef9666724856c40cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a93bfa0ab44ce276ef9666724856c40cf">toMultiSurface</a> ()</td></tr>
<tr class="memdesc:a93bfa0ab44ce276ef9666724856c40cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiSurface*.  <a href="classOGRGeometry.html#a93bfa0ab44ce276ef9666724856c40cf">More...</a><br /></td></tr>
<tr class="separator:a93bfa0ab44ce276ef9666724856c40cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffad1c5ffb37213e2aea7c20d8f7272"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#afffad1c5ffb37213e2aea7c20d8f7272">toMultiSurface</a> () const</td></tr>
<tr class="memdesc:afffad1c5ffb37213e2aea7c20d8f7272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRMultiSurface*.  <a href="classOGRGeometry.html#afffad1c5ffb37213e2aea7c20d8f7272">More...</a><br /></td></tr>
<tr class="separator:afffad1c5ffb37213e2aea7c20d8f7272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1990bb40f7ef045f9f9e796883591b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a4d1990bb40f7ef045f9f9e796883591b">toPolyhedralSurface</a> ()</td></tr>
<tr class="memdesc:a4d1990bb40f7ef045f9f9e796883591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolyhedralSurface*.  <a href="classOGRGeometry.html#a4d1990bb40f7ef045f9f9e796883591b">More...</a><br /></td></tr>
<tr class="separator:a4d1990bb40f7ef045f9f9e796883591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18c6c25bdfee09e0fdd8d99e2e7015d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#af18c6c25bdfee09e0fdd8d99e2e7015d">toPolyhedralSurface</a> () const</td></tr>
<tr class="memdesc:af18c6c25bdfee09e0fdd8d99e2e7015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRPolyhedralSurface*.  <a href="classOGRGeometry.html#af18c6c25bdfee09e0fdd8d99e2e7015d">More...</a><br /></td></tr>
<tr class="separator:af18c6c25bdfee09e0fdd8d99e2e7015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bef33c21122557417dd57517421201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a46bef33c21122557417dd57517421201">toTriangulatedSurface</a> ()</td></tr>
<tr class="memdesc:a46bef33c21122557417dd57517421201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangulatedSurface*.  <a href="classOGRGeometry.html#a46bef33c21122557417dd57517421201">More...</a><br /></td></tr>
<tr class="separator:a46bef33c21122557417dd57517421201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e8fb584a3412b2a605b97218f52fb3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a35e8fb584a3412b2a605b97218f52fb3">toTriangulatedSurface</a> () const</td></tr>
<tr class="memdesc:a35e8fb584a3412b2a605b97218f52fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Down-cast to OGRTriangulatedSurface*.  <a href="classOGRGeometry.html#a35e8fb584a3412b2a605b97218f52fb3">More...</a><br /></td></tr>
<tr class="separator:a35e8fb584a3412b2a605b97218f52fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a187ab3414db599fcaa2085583bdadc23"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a187ab3414db599fcaa2085583bdadc23">CastToCompoundCurve</a> (<a class="el" href="classOGRCurve.html">OGRCurve</a> *puCurve)</td></tr>
<tr class="memdesc:a187ab3414db599fcaa2085583bdadc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to compound curve.  <a href="classOGRCurve.html#a187ab3414db599fcaa2085583bdadc23">More...</a><br /></td></tr>
<tr class="separator:a187ab3414db599fcaa2085583bdadc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1b8c8eef386b694e658196af4af311"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRLineString.html">OGRLineString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a8e1b8c8eef386b694e658196af4af311">CastToLineString</a> (<a class="el" href="classOGRCurve.html">OGRCurve</a> *poCurve)</td></tr>
<tr class="memdesc:a8e1b8c8eef386b694e658196af4af311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to linestring.  <a href="classOGRCurve.html#a8e1b8c8eef386b694e658196af4af311">More...</a><br /></td></tr>
<tr class="separator:a8e1b8c8eef386b694e658196af4af311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51a2a5fd618dd6d3365033dd3bec1c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#ae51a2a5fd618dd6d3365033dd3bec1c0">CastToLinearRing</a> (<a class="el" href="classOGRCurve.html">OGRCurve</a> *poCurve)</td></tr>
<tr class="memdesc:ae51a2a5fd618dd6d3365033dd3bec1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to linear ring.  <a href="classOGRCurve.html#ae51a2a5fd618dd6d3365033dd3bec1c0">More...</a><br /></td></tr>
<tr class="separator:ae51a2a5fd618dd6d3365033dd3bec1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3083a9978cf5ad3658b1b86342e256"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#adc3083a9978cf5ad3658b1b86342e256">createGEOSContext</a> ()</td></tr>
<tr class="memdesc:adc3083a9978cf5ad3658b1b86342e256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new GEOS context.  <a href="classOGRGeometry.html#adc3083a9978cf5ad3658b1b86342e256">More...</a><br /></td></tr>
<tr class="separator:adc3083a9978cf5ad3658b1b86342e256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050eca02b140070855dff24bc5b18800"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#a050eca02b140070855dff24bc5b18800">freeGEOSContext</a> (<a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> hGEOSCtxt)</td></tr>
<tr class="memdesc:a050eca02b140070855dff24bc5b18800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a GEOS context.  <a href="classOGRGeometry.html#a050eca02b140070855dff24bc5b18800">More...</a><br /></td></tr>
<tr class="separator:a050eca02b140070855dff24bc5b18800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae518798c9e80bad59b0907f43d375876"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#ae518798c9e80bad59b0907f43d375876">ToHandle</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *poGeom)</td></tr>
<tr class="memdesc:ae518798c9e80bad59b0907f43d375876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRGeometry* to a OGRGeometryH.  <a href="classOGRGeometry.html#ae518798c9e80bad59b0907f43d375876">More...</a><br /></td></tr>
<tr class="separator:ae518798c9e80bad59b0907f43d375876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3407a6fa0e90e4625b023e9ef17c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRGeometry.html#abaf3407a6fa0e90e4625b023e9ef17c1">FromHandle</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:abaf3407a6fa0e90e4625b023e9ef17c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRGeometryH to a OGRGeometry*.  <a href="classOGRGeometry.html#abaf3407a6fa0e90e4625b023e9ef17c1">More...</a><br /></td></tr>
<tr class="separator:abaf3407a6fa0e90e4625b023e9ef17c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a66138d495381143e1ccd13697f85fdf3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a66138d495381143e1ccd13697f85fdf3">ContainsPoint</a> (const <a class="el" href="classOGRPoint.html">OGRPoint</a> *p) const</td></tr>
<tr class="memdesc:a66138d495381143e1ccd13697f85fdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a point is contained in a (closed) curve.  <a href="classOGRCurve.html#a66138d495381143e1ccd13697f85fdf3">More...</a><br /></td></tr>
<tr class="separator:a66138d495381143e1ccd13697f85fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e80959432bc0b1d67d7cdc77d9c47b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#a17e80959432bc0b1d67d7cdc77d9c47b">IntersectsPoint</a> (const <a class="el" href="classOGRPoint.html">OGRPoint</a> *p) const</td></tr>
<tr class="memdesc:a17e80959432bc0b1d67d7cdc77d9c47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a point intersects a (closed) curve.  <a href="classOGRCurve.html#a17e80959432bc0b1d67d7cdc77d9c47b">More...</a><br /></td></tr>
<tr class="separator:a17e80959432bc0b1d67d7cdc77d9c47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ce550d800d8b9aa99f2849403b8ba"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRCurve.html#ab43ce550d800d8b9aa99f2849403b8ba">get_AreaOfCurveSegments</a> () const =0</td></tr>
<tr class="memdesc:ab43ce550d800d8b9aa99f2849403b8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the area of the purely curve portions of a (closed) curve.  <a href="classOGRCurve.html#ab43ce550d800d8b9aa99f2849403b8ba">More...</a><br /></td></tr>
<tr class="separator:ab43ce550d800d8b9aa99f2849403b8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a261992c218c14c510ac3add63d62185d"><td class="memItemLeft" align="right" valign="top"><a id="a261992c218c14c510ac3add63d62185d"></a>
ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (const <a class="el" href="classOGRCurve.html">OGRCurve</a> *)</td></tr>
<tr class="separator:a261992c218c14c510ac3add63d62185d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1463f9c5cac135e8f0d5072a5126ccf1"><td class="memItemLeft" align="right" valign="top"><a id="a1463f9c5cac135e8f0d5072a5126ccf1"></a>
ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (const <a class="el" href="classOGRCurve.html">OGRCurve</a> *)</td></tr>
<tr class="separator:a1463f9c5cac135e8f0d5072a5126ccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract curve base class for <a class="el" href="classOGRLineString.html" title="Concrete representation of a multi-vertex line.">OGRLineString</a>, <a class="el" href="classOGRCircularString.html" title="Concrete representation of a circular string, that is to say a curve made of one or several arc circl...">OGRCircularString</a> and <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves.">OGRCompoundCurve</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af57de03effd32d0d09cbdc0ed146b508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57de03effd32d0d09cbdc0ed146b508">&#9670;&nbsp;</a></span>assignSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::assignSpatialReference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, but does not copy it.</p>
<p>Starting with GDAL 2.3, this will also assign the spatial reference to potential sub-geometries of the geometry (<a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects.">OGRGeometryCollection</a>, OGRCurvePolygon/OGRPolygon, <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves.">OGRCompoundCurve</a>, <a class="el" href="classOGRPolyhedralSurface.html" title="PolyhedralSurface class.">OGRPolyhedralSurface</a> and their derived classes).</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536" title="Assign spatial reference to this object.">OGR_G_AssignSpatialReference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSR</td><td>new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a86b29f811703af5522625f65486166c2">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a12ded5e985fce2cdefa38f2b6ff662fe">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a10ebc5b56476b8fba1c18357c5bc71d2">OGRCurvePolygon</a>, and <a class="el" href="classOGRCompoundCurve.html#a60baa8dfeda75467ed04064ee85272b4">OGRCompoundCurve</a>.</p>

</div>
</div>
<a id="aaad53c365dbcae56712f4deddd891d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad53c365dbcae56712f4deddd891d5b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRCurve::ConstIterator OGRCurve::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return begin of a point iterator. </p>
<p>Using this iterator for standard range-based loops is safe, but due to implementation limitations, you shouldn't try to access (dereference) more than one iterator step at a time, since you will get a reference to the same <a class="el" href="classOGRPoint.html" title="Point class.">OGRPoint</a>&amp; object. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abb8eebc159f59a20d63f40539577dde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8eebc159f59a20d63f40539577dde7">&#9670;&nbsp;</a></span>Boundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b" title="Compute boundary.">OGR_G_Boundary()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a8694e757f44388bd6da4cf7be696b7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8694e757f44388bd6da4cf7be696b7e7">&#9670;&nbsp;</a></span>Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Buffer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nQuadSegs</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a398ad99b74f10fe63cdf81d8674edfc2" title="Compute buffer of geometry.">OGR_G_Buffer()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td class="paramname">nQuadSegs</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="ac226d1821ce677689f1de12bbe6497b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac226d1821ce677689f1de12bbe6497b5">&#9670;&nbsp;</a></span>BufferEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::BufferEx </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p>The following options are supported. See the GEOS library for more detailed descriptions.</p>
<ul>
<li>
ENDCAP_STYLE=ROUND/FLAT/SQUARE </li>
<li>
JOIN_STYLE=ROUND/MITRE/BEVEL </li>
<li>
MITRE_LIMIT=double </li>
<li>
QUADRANT_SEGMENTS=double </li>
<li>
SINGLE_SIDED=YES/NO </li>
</ul>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aa6daaf8d57da28ab6c45b8a8b3094901" title="Compute buffer of geometry.">OGR_G_BufferEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

</div>
</div>
<a id="a187ab3414db599fcaa2085583bdadc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187ab3414db599fcaa2085583bdadc23">&#9670;&nbsp;</a></span>CastToCompoundCurve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a> * OGRCurve::CastToCompoundCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td>
          <td class="paramname"><em>poCurve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast to compound curve. </p>
<p>The passed in geometry is consumed and a new one returned (or NULL in case of failure)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCurve</td><td>the input geometry - ownership is passed to the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ae51a2a5fd618dd6d3365033dd3bec1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51a2a5fd618dd6d3365033dd3bec1c0">&#9670;&nbsp;</a></span>CastToLinearRing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a> * OGRCurve::CastToLinearRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td>
          <td class="paramname"><em>poCurve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast to linear ring. </p>
<p>The passed in geometry is consumed and a new one returned (or NULL in case of failure)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCurve</td><td>the input geometry - ownership is passed to the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a8e1b8c8eef386b694e658196af4af311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1b8c8eef386b694e658196af4af311">&#9670;&nbsp;</a></span>CastToLineString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a> * OGRCurve::CastToLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCurve.html">OGRCurve</a> *&#160;</td>
          <td class="paramname"><em>poCurve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast to linestring. </p>
<p>The passed in geometry is consumed and a new one returned (or NULL in case of failure)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCurve</td><td>the input geometry - ownership is passed to the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a91787f669b2a148169667e270e7e40df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91787f669b2a148169667e270e7e40df">&#9670;&nbsp;</a></span>Centroid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::Centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html" title="Point class.">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b" title="Compute the geometry centroid.">OGR_G_Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 as a <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes.">OGRGeometry</a> method (previously was restricted to <a class="el" href="classOGRPolygon.html" title="Concrete class representing polygons.">OGRPolygon</a>) </dd></dl>

</div>
</div>
<a id="af857076da2d2adf2ad943d4df56326b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af857076da2d2adf2ad943d4df56326b9">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOGRCurve.html">OGRCurve</a>* OGRCurve::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of this object. </p>
<p>This method relates to the SFCOM IGeometry::clone() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a new object instance with the same geometry, and spatial reference system as the original. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161">OGRGeometry</a>.</p>

<p>Implemented in <a class="el" href="classOGRSimpleCurve.html#aa19d2a0cedbedac6d3b12c30523654d6">OGRSimpleCurve</a>, <a class="el" href="classOGRCompoundCurve.html#a599edcca1b99d5c88c0b588e77accc7b">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a4f9bc3ffa8ad1dcb96080e68bd36e54f">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#a1dc0ad4099e35743988e7b22d3363800">OGRLinearRing</a>, and <a class="el" href="classOGRLineString.html#af1be30abacfe26a3c2bf8026b65670f7">OGRLineString</a>.</p>

</div>
</div>
<a id="aeb6cf249316b3046e0d4f77ec400e844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6cf249316b3046e0d4f77ec400e844">&#9670;&nbsp;</a></span>closeRings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::closeRings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end. </p>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#a53b4239519af6079fa735e9d91938d5c">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#aff7bce5d2c53421164b31cc9cb803d03">OGRPolygon</a>, and <a class="el" href="classOGRLinearRing.html#aa094e3579479b77a9dfbcafd91a3f366">OGRLinearRing</a>.</p>

</div>
</div>
<a id="a4eebda9322568a50da1cb8bb2bcf0a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eebda9322568a50da1cb8bb2bcf0a9e">&#9670;&nbsp;</a></span>ConcaveHull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::ConcaveHull </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowHoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute "concave hull" of a geometry. </p>
<p>The concave hull is fully contained within the convex hull and also contains all the points of the input, but in a smaller area. The area ratio is the ratio of the area of the convex hull and the concave hull. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.</p>
<p>A new geometry object is created and returned containing the concave hull of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a32f11850c5ed2f86b99e4682178c6797" title="Compute &quot;concave hull&quot; of a geometry.">OGR_G_ConcaveHull()</a>.</p>
<p>This method is built on the GEOS &gt;= 3.11 library If OGR is built without the GEOS &gt;= 3.11 librray, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfRatio</td><td>Ratio of the area of the convex hull and the concave hull. </td></tr>
    <tr><td class="paramname">bAllowHoles</td><td>Whether holes are allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="ae818178178f80c2987c6173ab4da041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae818178178f80c2987c6173ab4da041e">&#9670;&nbsp;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object contains the passed geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8" title="Test for containment.">OGR_G_Contains()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if poOtherGeom contains this geometry, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCurvePolygon.html#a3e60f2ed59b940cf72746a2b9c4dfe18">OGRCurvePolygon</a>.</p>

</div>
</div>
<a id="a66138d495381143e1ccd13697f85fdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66138d495381143e1ccd13697f85fdf3">&#9670;&nbsp;</a></span>ContainsPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurve::ContainsPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a point is contained in a (closed) curve. </p>
<p>Final users should use <a class="el" href="classOGRGeometry.html#ae818178178f80c2987c6173ab4da041e" title="Test for containment.">OGRGeometry::Contains()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if it is inside the curve, FALSE otherwise or -1 if unknown.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a83020c007c4f3beabe1e01edba173135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83020c007c4f3beabe1e01edba173135">&#9670;&nbsp;</a></span>ConvexHull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::ConvexHull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d" title="Compute convex hull.">OGR_G_ConvexHull()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a35c4f4d75ec84fa225a9a4dee0a609c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c4f4d75ec84fa225a9a4dee0a609c1">&#9670;&nbsp;</a></span>CoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::CoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf" title="Get the dimension of the coordinates in this geometry.">OGR_G_CoordinateDimension()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="adc3083a9978cf5ad3658b1b86342e256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3083a9978cf5ad3658b1b86342e256">&#9670;&nbsp;</a></span>createGEOSContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a> OGRGeometry::createGEOSContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new GEOS context. </p>
<dl class="section return"><dt>Returns</dt><dd>a new GEOS context. </dd></dl>

</div>
</div>
<a id="adf30cb59307e8d5889e9fcf71d371afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf30cb59307e8d5889e9fcf71d371afb">&#9670;&nbsp;</a></span>Crosses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Crosses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other passed into the method are crossing.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c" title="Test for crossing.">OGR_G_Crosses()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a003935f17119f329b1c00008d9fbcac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003935f17119f329b1c00008d9fbcac7">&#9670;&nbsp;</a></span>CurveToLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a> * OGRCurve::CurveToLine </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a linestring from a curve geometry. </p>
<p>The returned geometry is a new instance whose ownership belongs to the caller.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>This method relates to the ISO SQL/MM Part 3 ICurve::CurveToLine() method.</p>
<p>This function is the same as C function OGR_G_CurveToLine().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. See <a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c" title="Converts an arc circle into an approximate line string.">OGRGeometryFactory::curveToLineString()</a> for valid options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a line string approximating the curve</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#a64056004379603e6393f91fd50fa4ee0">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#ae94af689654ada3f92625f8b6cadb98d">OGRCircularString</a>, and <a class="el" href="classOGRLineString.html#a9c97a589d9984363e7d5a881d9e5cc34">OGRLineString</a>.</p>

</div>
</div>
<a id="a45b0d68bea79509e675bd773c30eb350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b0d68bea79509e675bd773c30eb350">&#9670;&nbsp;</a></span>DelaunayTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bOnlyEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Delaunay triangulation of the vertices of the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#acf65b24716b3538cb883de3fa0d35a8a" title="Return a Delaunay triangulation of the vertices of the geometry.">OGR_G_DelaunayTriangulation()</a>.</p>
<p>This function is built on the GEOS library, v3.4 or above. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfTolerance</td><td>optional snapping tolerance to use for improved robustness </td></tr>
    <tr><td class="paramname">bOnlyEdges</td><td>if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1 </dd></dl>

</div>
</div>
<a id="a6f49d7599f955e3d459c4dd13bbf1f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f49d7599f955e3d459c4dd13bbf1f9e">&#9670;&nbsp;</a></span>Difference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the second geometry removed.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64" title="Compute difference.">OGR_G_Difference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry removed from "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

</div>
</div>
<a id="aaa4f0b34b165b589ffbef7d3ea65c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f0b34b165b589ffbef7d3ea65c00c">&#9670;&nbsp;</a></span>Disjoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other passed into the method are disjoint.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503" title="Test for disjointness.">OGR_G_Disjoint()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a72e832f8dc1001de35e9e888a4bae8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e832f8dc1001de35e9e888a4bae8b3">&#9670;&nbsp;</a></span>Distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401" title="Compute distance between two geometries.">OGR_G_Distance()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="aa2e39301afc475f5fff022af690fcf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e39301afc475f5fff022af690fcf84">&#9670;&nbsp;</a></span>Distance3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeometry::Distance3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 3D distance between two geometries. </p>
<p>The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is built on the SFCGAL library, check it for the definition of the geometry operation. If OGR is built without the SFCGAL library, this method will always return -1.0</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a7313a805a15bf78a26c52ff1bc6242e2" title="Returns the 3D distance between two geometries.">OGR_G_Distance3D()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>distance between the two geometries </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a360570554fcd805f9fe673062ba5a22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360570554fcd805f9fe673062ba5a22b">&#9670;&nbsp;</a></span>dumpReadable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string OGRGeometry::dumpReadable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>A few options can be defined to change the default dump : </p><ul>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=WKT or YES (default) : dump the geometry as a WKT </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
<li>
XY_COORD_PRECISION=integer: number of decimal figures for X,Y coordinates in WKT (added in GDAL 3.9) </li>
<li>
Z_COORD_PRECISION=integer: number of decimal figures for Z coordinates in WKT (added in GDAL 3.9) </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the geometry representation. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="ae8836b9e2d6a79eee8f88c61718e1e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8836b9e2d6a79eee8f88c61718e1e50">&#9670;&nbsp;</a></span>dumpReadable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::dumpReadable </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>A few options can be defined to change the default dump : </p><ul>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=WKT or YES (default) : dump the geometry as a WKT </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f" title="Dump geometry in well known text format to indicated output file.">OGR_G_DumpReadable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>the text file to write the geometry to. </td></tr>
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1702b5b8142abe761061a6cd44e50b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1702b5b8142abe761061a6cd44e50b05">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear geometry information. </p>
<p>This restores the geometry to its initial state after construction, and before assignment of actual geometry.</p>
<p>This method relates to the SFCOM IGeometry::Empty() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2" title="Clear geometry information.">OGR_G_Empty()</a>. </p>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#af86a1c685793d23f685d7893e1eb7703">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a4182104d611a46942fcd36edba32c52e">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a4f8b6b73430f36513a65d27f556e796d">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a498b65455f48c2c15dfecd7cb65d4158">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#ab3e03f7f9094bb69be3d60233dd28353">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a51e977d29d7d2a063d2f8f046f61a519">OGRPoint</a>.</p>

</div>
</div>
<a id="a2e9e8e178c7e70efdecd1c50d95d537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9e8e178c7e70efdecd1c50d95d537e">&#9670;&nbsp;</a></span>EndPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurve::EndPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the curve end point. </p>
<p>This method relates to the SF COM ICurve::get_EndPoint() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poPoint</td><td>the point to be assigned the end location. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#a9dc5417fba9adedf67445cccb0d3ed1a">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#a791b5c37322ab381ee43282c92d6f34a">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a1b80c7f464de1d332215f16d35138590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b80c7f464de1d332215f16d35138590">&#9670;&nbsp;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This operation implements the SQL/MM ST_OrderingEquals() operation.</p>
<p>The comparison is done in a structural way, that is to say that the geometry types must be identical, as well as the number and ordering of sub-geometries and vertices. Or equivalently, two geometries are considered equal by this method if their WKT/WKB representation is equal. Note: this must be distinguished for equality in a spatial way (which is the purpose of the ST_Equals() operation).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3" title="Returns TRUE if two geometries are equivalent.">OGR_G_Equals()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a92e0592444ba2aa5077ad4dfe2ca6245">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a6ab977bb05710b88a96e88dce5b8e834">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a866bf18d2c0a73d1ced4ff982aee6c25">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ac85c5a90238f59bb15c05427784d5903">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#ab048c1cf1d5903076d1e1e6d0d894cb2">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a3d4c93922bd9205df46cf6f448c3aab8">OGRPoint</a>.</p>

</div>
</div>
<a id="a0adbc7e5862ce784ee4aee0f6c5bf294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adbc7e5862ce784ee4aee0f6c5bf294">&#9670;&nbsp;</a></span>exportToGEOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__geometry_8h.html#adc1d7838410d13f36b3fa41c17a1a57e">GEOSGeom</a> OGRGeometry::exportToGEOS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveEmptyParts</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a GEOSGeom object corresponding to the geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
    <tr><td class="paramname">bRemoveEmptyParts</td><td>Whether empty parts of the geometry should be removed before exporting to GEOS (GDAL &gt;= 3.10) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a GEOSGeom object corresponding to the geometry. </dd></dl>

</div>
</div>
<a id="abbd63002f416db1ea0eb24857b5ef9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd63002f416db1ea0eb24857b5ef9f2">&#9670;&nbsp;</a></span>exportToGML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToGML </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>The supported options are : </p><ul>
<li>
FORMAT=GML2/GML3/GML32 (GML2 or GML32 added in GDAL 2.1). If not set, it will default to GML 2.1.2 output.  </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used .  </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3, deprecated by SRSNAME_FORMAT in GDAL &gt;=2.2). Defaults to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order.  </li>
<li>
SRSNAME_FORMAT=SHORT/OGC_URN/OGC_URL (Only valid for FORMAT=GML3, added in GDAL 2.2). Defaults to OGC_URN. If SHORT, then srsName will be in the form AUTHORITY_NAME:AUTHORITY_CODE. If OGC_URN, then srsName will be in the form urn:ogc:def:crs:AUTHORITY_NAME::AUTHORITY_CODE. If OGC_URL, then srsName will be in the form <a href="http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE">http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE</a>. For OGC_URN and OGC_URL, in the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it.  </li>
<li>
GMLID=astring. If specified, a gml:id attribute will be written in the top-level geometry element with the provided value. Required for GML 3.2 compatibility.  </li>
<li>
SRSDIMENSION_LOC=POSLIST/GEOMETRY/GEOMETRY,POSLIST. (Only valid for FORMAT=GML3/GML32, GDAL &gt;= 2.0) Default to POSLIST. For 2.5D geometries, define the location where to attach the srsDimension attribute. There are diverging implementations. Some put in on the &lt;gml:posList&gt; element, other on the top geometry element.  </li>
<li>
NAMESPACE_DECL=YES/NO. If set to YES, xmlns:gml="http://www.opengis.net/gml" will be added to the root node for GML &lt; 3.2 or xmlns:gml="http://www.opengis.net/gml/3.2" for GML 3.2  </li>
<li>
XY_COORD_RESOLUTION=double (added in GDAL 3.9): Resolution for the coordinate precision of the X and Y coordinates. Expressed in the units of the X and Y axis of the SRS. eg 1e-5 for up to 5 decimal digits. 0 for the default behavior.  </li>
<li>
Z_COORD_RESOLUTION=double (added in GDAL 3.9): Resolution for the coordinate precision of the Z coordinates. Expressed in the units of the Z axis of the SRS. 0 for the default behavior.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a06fc1cec4a17a2926640f95c6bf7a442" title="Convert a geometry into GML format.">OGR_G_ExportToGMLEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="af39899a5c670d2475281cbf5adf8fa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39899a5c670d2475281cbf5adf8fa97">&#9670;&nbsp;</a></span>exportToJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToJson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>The following options are supported : </p><ul>
<li>
XY_COORD_PRECISION=integer: number of decimal figures for X,Y coordinates (added in GDAL 3.9) </li>
<li>
Z_COORD_PRECISION=integer: number of decimal figures for Z coordinates (added in GDAL 3.9) </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47" title="Convert a geometry into GeoJSON format.">OGR_G_ExportToJson()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>Null terminated list of options, or null (added in 3.9) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ab73487475ea43a2e677fe0556bf738e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73487475ea43a2e677fe0556bf738e0">&#9670;&nbsp;</a></span>exportToKML()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * OGRGeometry::exportToKML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3" title="Convert a geometry into KML format.">OGR_G_ExportToKML()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A KML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="abf4bcfa2fd949bf8c889a1b128a6dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4bcfa2fd949bf8c889a1b128a6dbb5">&#9670;&nbsp;</a></span>exportToWkb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eByteOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6" title="Convert a geometry well known binary format.">OGR_G_ExportToWkb()</a> or <a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.">OGR_G_ExportToIsoWkb()</a>, depending on the value of eWkbVariant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eByteOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyData</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a> byte in size. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>What standard to use when exporting geometries with three dimensions (or more). The default wkbVariantOldOgc is the historical OGR variant. wkbVariantIso is the variant defined in ISO SQL/MM and adopted by OGC for SFSQL 1.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="a96db112c727147a65329c1eea1ca57b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96db112c727147a65329c1eea1ca57b4">&#9670;&nbsp;</a></span>exportToWkb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkb </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ae18ca8de10fb5fc90705d4e91791566f" title="Convert a geometry into well known binary format.">OGR_G_ExportToWkbEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> byte in size. </td></tr>
    <tr><td class="paramname">psOptions</td><td>WKB export options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a0304617ff4dd36e7ac7f220904566873">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#adc5a4268f43709b5f33f1c0647edee5a">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#aa568fca9b0225756a8d8e50fa20852bf">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#acce34b5497984619d0fb14f831856313">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ace12c465943c38961a9b8f163020544b">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a27a9faab90e5393f60d6a7d697ffb346">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a4fcc441e77ab420fd57030f58c2ccfbd">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a66a082cfdc00462aaa83347be25fa95e">OGRPoint</a>.</p>

</div>
</div>
<a id="ad17cfebfd9826a22763dff6280ba196e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17cfebfd9826a22763dff6280ba196e">&#9670;&nbsp;</a></span>exportToWkt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszDstText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>variant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This method relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb" title="Convert a geometry into well known text format.">OGR_G_ExportToWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszDstText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>. </td></tr>
    <tr><td class="paramname">variant</td><td>the specification that must be conformed too :<ul>
<li>wkbVariantOgc for old-style 99-402 extended dimension (Z) WKB types</li>
<li>wkbVariantIso for SFSQL 1.2 and ISO SQL/MM Part 3</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="afc5e4417e06fb4726ba80461b30aa289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5e4417e06fb4726ba80461b30aa289">&#9670;&nbsp;</a></span>exportToWkt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string OGRGeometry::exportToWkt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRWktOptions.html">OGRWktOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="structOGRWktOptions.html">OGRWktOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>err</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Export a WKT geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Output options. </td></tr>
    <tr><td class="paramname">err</td><td>Pointer to error code, if desired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>WKT string representing this geometry. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a9c69bb2d308b5777496edd126ea5cc71">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a964932e6e3f312f11dc036aa8e005e3e">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a52aac3839dd21ff654087b25f270b8e3">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#a16bcbe4d14913784d5c7f0e78811e0e4">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#ae0159f56063edceb26af8d08c867f0c9">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#aa8228298589c236298e6ee93ded61ccf">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#abd121f40115c136e53cfa68b1e372dab">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a02ff39b5de89dcbfdc27315177fccfe1">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a09338292b7382ade8d59a5fa40867f4b">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a6a7585eb43e23cbf88801e1c6d3cadd8">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a7f3dddb6bafe6c4f2ef7fd7dbcbbfbbd">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#aae9f53d063786c0435e73ace0fe95507">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#adf36bd8f80c3215d3ca43576273be29e">OGRPoint</a>.</p>

</div>
</div>
<a id="aaae1a2ced937a5900b2bfeb717bad6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae1a2ced937a5900b2bfeb717bad6c9">&#9670;&nbsp;</a></span>flattenTo2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::flattenTo2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert geometry to strictly 2D. </p>
<p>In a sense this converts all Z coordinates to 0.0.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8" title="Convert geometry to strictly 2D.">OGR_G_FlattenTo2D()</a>. </p>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a5eabebeefe1ce008a24d1fd97da59547">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aec6c186d031be3085e5de02fd176ce5b">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a42e2b4087c482df97a2cb8ba6d9eb7c1">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a9334ab5ea081f810a6fa50ffb4ac4308">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a67a63edcc3290d3c60a83ede1c995624">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a9b2ab4bcbeb865be20d80d01f39c99cc">OGRPoint</a>.</p>

</div>
</div>
<a id="a050eca02b140070855dff24bc5b18800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050eca02b140070855dff24bc5b18800">&#9670;&nbsp;</a></span>freeGEOSContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::freeGEOSContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__geometry_8h.html#a8fbe3d578fe2ba147a7a6a0c7a3d8f85">GEOSContextHandle_t</a>&#160;</td>
          <td class="paramname"><em>hGEOSCtxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a GEOS context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGEOSCtxt</td><td>GEOS context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaf3407a6fa0e90e4625b023e9ef17c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf3407a6fa0e90e4625b023e9ef17c1">&#9670;&nbsp;</a></span>FromHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOGRGeometry.html">OGRGeometry</a>* OGRGeometry::FromHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRGeometryH to a OGRGeometry*. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ac25187cc705e970be8d7f311c6b02808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25187cc705e970be8d7f311c6b02808">&#9670;&nbsp;</a></span>get_Area()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRCurve::get_Area </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the area of the (closed) curve. </p>
<p>This method is designed to be used by <a class="el" href="classOGRCurvePolygon.html#a6159cf2c28cd236ad2aa593c005c473a" title="Get the area of the surface object.">OGRCurvePolygon::get_Area()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the area of the geometry in square units of the spatial reference system in use.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRCurve.html#a7711a5d7cff10b67f75949f7a494c0e2" title="Get the area of the (closed) curve, considered as a surface on the underlying ellipsoid of the SRS at...">get_GeodesicArea()</a> for an alternative method returning areas computed on the ellipsoid, an in square meters.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#ac05d106a97f8a389e7ef1c1ae037198e">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#aab0d4691347838c48fc2dc0551d7fa5c">OGRCircularString</a>, and <a class="el" href="classOGRLineString.html#ac7dc616df6b5a8842523428f2804c378">OGRLineString</a>.</p>

</div>
</div>
<a id="ab43ce550d800d8b9aa99f2849403b8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43ce550d800d8b9aa99f2849403b8ba">&#9670;&nbsp;</a></span>get_AreaOfCurveSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRCurve::get_AreaOfCurveSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the area of the purely curve portions of a (closed) curve. </p>
<p>This method is designed to be used on a closed convex curve.</p>
<dl class="section return"><dt>Returns</dt><dd>the area of the feature in square units of the spatial reference system in use.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#a77abc9171a1d686094573f40b702fef0">OGRCompoundCurve</a>.</p>

</div>
</div>
<a id="a7711a5d7cff10b67f75949f7a494c0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7711a5d7cff10b67f75949f7a494c0e2">&#9670;&nbsp;</a></span>get_GeodesicArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRCurve::get_GeodesicArea </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRSOverride</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the area of the (closed) curve, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry. </p>
<p>This method is designed to be used by <a class="el" href="classOGRCurvePolygon.html#a7d872967b12ec5cf55846555fe32c983" title="Get the area of the surface object, considered as a surface on the underlying ellipsoid of the SRS at...">OGRCurvePolygon::get_GeodesicArea()</a>.</p>
<p>The returned area will always be in square meters, and assumes that polygon edges describe geodesic lines on the ellipsoid.</p>
<p>Note that geometries with circular arcs will be linearized in their original coordinate space first, so the resulting geodesic area will be an approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSRSOverride</td><td>If not null, overrides <a class="el" href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd" title="Returns spatial reference system for object.">OGRGeometry::getSpatialReference()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the geometry in square meters, or a negative value in case of error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRCurve.html#ac25187cc705e970be8d7f311c6b02808" title="Get the area of the (closed) curve.">get_Area()</a> for an alternative method returning areas computed in 2D Cartesian space.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#aed17c6687d3291311312ac316f6456a8">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a487ef0f99f47bcc07c371ef27336465c">OGRCircularString</a>, and <a class="el" href="classOGRLineString.html#a977e72600ef55436f7d9879208ee442d">OGRLineString</a>.</p>

</div>
</div>
<a id="a6c046d6a445e958cd370437f63db8d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c046d6a445e958cd370437f63db8d8e">&#9670;&nbsp;</a></span>get_IsClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurve::get_IsClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return TRUE if curve is closed. </p>
<p>Tests if a curve is closed. A curve is closed if its start point is equal to its end point.</p>
<p>For equality tests, the M dimension is ignored.</p>
<p>This method relates to the SFCOM ICurve::get_IsClosed() method.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if closed, else FALSE. </dd></dl>

</div>
</div>
<a id="a09d2e65489ca56fc4f09a281b50f3e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d2e65489ca56fc4f09a281b50f3e74">&#9670;&nbsp;</a></span>get_Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OGRCurve::get_Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the curve. </p>
<p>This method relates to the SFCOM ICurve::get_Length() method.</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the curve, zero if the curve hasn't been initialized. </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#a8e8fe866812ff248898a7d5dd63b9100">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#aa4c1bf02bb6a5f7d3b037e220593d492">OGRCircularString</a>, and <a class="el" href="classOGRSimpleCurve.html#a99f30c037f9c11338b4c75d316bdefc2">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a4a6fdd4df7c043558b5428d8f1c35b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6fdd4df7c043558b5428d8f1c35b16">&#9670;&nbsp;</a></span>getCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::getCoordinateDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this object. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry.">OGR_G_GetCoordinateDimension()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>use <a class="el" href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1" title="Get the dimension of the coordinates in this object.">CoordinateDimension()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 or 3. </dd></dl>

</div>
</div>
<a id="a1068398fd3af02de78bd2b9dbbb837f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1068398fd3af02de78bd2b9dbbb837f1">&#9670;&nbsp;</a></span>getCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::getCurveGeometry </td>
          <td>(</td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return curve version of this geometry. </p>
<p>Returns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating curve geometries.</p>
<p>If the geometry has no curve portion, the returned geometry will be a clone of it.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse method is <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480" title="Return, possibly approximate, non-curve version of this geometry.">OGRGeometry::getLinearGeometry()</a>.</p>
<p>This function is the same as C function <a class="el" href="ogr__api_8h.html#a21a8713301c4f28c30aa7bd034411402" title="Return curve version of this geometry.">OGR_G_GetCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#a25a7ee787f1e660014a5ffa69a94f28e">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#af35b73e64c9b296afa0685575d6e524f">OGRPolygon</a>, and <a class="el" href="classOGRLineString.html#ab9eab58c0487fcc49c1595e99c881d26">OGRLineString</a>.</p>

</div>
</div>
<a id="a0d1abb0177b55c0ef8320832e5096101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1abb0177b55c0ef8320832e5096101">&#9670;&nbsp;</a></span>getDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurve::getDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimension of this object. </p>
<p>This method corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the object, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104" title="Get the dimension of this geometry.">OGR_G_GetDimension()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

<p>Implements <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb">OGRGeometry</a>.</p>

</div>
</div>
<a id="aa3d42b06ae6f7bbef6d1a2886da8d398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d42b06ae6f7bbef6d1a2886da8d398">&#9670;&nbsp;</a></span>getEnvelope() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGR_G_GetEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a5ba7de77775dd7e782811b8421958faf">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a88d5e2e936a95b8c866ef36aea57b402">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a5c37b416860a3fd2b2aaf471ffd9ad69">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ac651de749818c615ef3be71fc9ab2383">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a9ed8ac2d4d3283866caf0ca2c57d69c3">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a8bf6dd6fb48dd2c05ab23cd2c9474a1d">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#ad265a468bc28d774e70b648c4e8001df">OGRPoint</a>.</p>

</div>
</div>
<a id="a3926892dbde299ffd652ee109b5967c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3926892dbde299ffd652ee109b5967c5">&#9670;&nbsp;</a></span>getEnvelope() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::getEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce" title="Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.">OGR_G_GetEnvelope3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#af29c8434458527b796847804fa2b5d61">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a8ef6f62e0446c66ea4874a4bbcbf8d35">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a46fa4514aead52995de7aee70a6b8bb3">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a14ca542873325ac5737b9ee7f232c651">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a42fd0f525d83caa5968cce77b1105e48">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a899397ea5545f3c8e306c30d2adf9ccb">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#aeccd80f6034d2ae786f44a78991ac314">OGRPoint</a>.</p>

</div>
</div>
<a id="aba109e1c53ce1452942f85eae66d88b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba109e1c53ce1452942f85eae66d88b8">&#9670;&nbsp;</a></span>getGeometryName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRGeometry::getGeometryName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a" title="Fetch WKT name for geometry type.">OGR_G_GetGeometryName()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>name used for this geometry type in well known text format. The returned pointer is to a static internal string and should not be modified or freed. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a97027c7c97c031cc858170d2ae851ca8">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a5dd73ff324e0c25402e64db11e3b192a">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a95172676d264da6bd7453d3196d54fac">OGRMultiPoint</a>, <a class="el" href="classOGRTriangulatedSurface.html#a156c11aa645cb91ce5c74b5338e67b82">OGRTriangulatedSurface</a>, <a class="el" href="classOGRPolyhedralSurface.html#aa1c960495b0a4851b27a08b2b539bb2d">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a1040d86861577dbe80a68b7cabcd0a1d">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#aa2cc2f5a5d7f69979d23a86dfe8ceeef">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a53eb7b3785dbc4cb79893756d140de1e">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#af85e6b2097861cc92f74678acfb341f0">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#a70ab4a9518743c87ab7d36b731fce530">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a657a572a4c14c429f6729b22f813a0b8">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#af234b900eac034fa6cb224859ef81f6e">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#ac6fd941ff17e4a583c1744cd12fcc1e8">OGRCircularString</a>, <a class="el" href="classOGRLinearRing.html#a7ea2cff1b5a9f37ee137fd6ac36cc498">OGRLinearRing</a>, <a class="el" href="classOGRLineString.html#a33b8f9ab541e0a083f0a597852be1db5">OGRLineString</a>, and <a class="el" href="classOGRPoint.html#ab179d07fae1da649afd568f465c9476e">OGRPoint</a>.</p>

</div>
</div>
<a id="a5c6bca18682cb933e3227552d480e1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6bca18682cb933e3227552d480e1a5">&#9670;&nbsp;</a></span>getGeometryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRGeometry::getGeometryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten()</a> macro to the return result.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type.">OGR_G_GetGeometryType()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type code. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#a33043ad4b8c6e79b8c8bbdfbb25be8b7">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a5005ce01767bccf7a4de7de175ec6c27">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#a9c162729b796f8d2af528f12a6fd6e95">OGRMultiPoint</a>, <a class="el" href="classOGRTriangulatedSurface.html#a1aba9929118409503d72ca9e6ac03a7f">OGRTriangulatedSurface</a>, <a class="el" href="classOGRPolyhedralSurface.html#a8e00dff027b039688b6097d7700edd69">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#aadf1464a49e1ad2dc35a08184e58ca5e">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#aedfcb9f739896250129f7020fc5678ef">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#ac5f92c525b0569a971c5d47bc0f9f1c1">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#a48b5fd19cbd9e93e4961a46660bb8181">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#a5f1316ac915dad438b599c825b8c0068">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a9a1a2d708cdf852785a66417f9889bfc">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#af0c737a27f323cf7fdd92c62c973d9dc">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a95883a6e918b8b07b2dac0a10c589f65">OGRCircularString</a>, <a class="el" href="classOGRLineString.html#aabbfb9f0024b1def22428d68d3b88d00">OGRLineString</a>, and <a class="el" href="classOGRPoint.html#a9545758cbbf6ae93548f19851fd0f594">OGRPoint</a>.</p>

</div>
</div>
<a id="ac3989a0ff917a1e46d02170033996329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3989a0ff917a1e46d02170033996329">&#9670;&nbsp;</a></span>getIsoGeometryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRGeometry::getIsoGeometryType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the geometry type that conforms with ISO SQL/MM Part3. </p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type that conforms with ISO SQL/MM Part3 </dd></dl>

</div>
</div>
<a id="ada1408cd0015a83b697eb27aebaf5480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1408cd0015a83b697eb27aebaf5480">&#9670;&nbsp;</a></span>getLinearGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::getLinearGeometry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return, possibly approximate, non-curve version of this geometry. </p>
<p>Returns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse method is <a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1" title="Return curve version of this geometry.">OGRGeometry::getCurveGeometry()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a540a6941c76bd4da7fdf2dca081d07e5" title="Return, possibly approximate, linear version of this geometry.">OGR_G_GetLinearGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. See <a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c" title="Converts an arc circle into an approximate line string.">OGRGeometryFactory::curveToLineString()</a> for valid options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#aa4ac63e76ac14460bb5f883208deaed7">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a19479ddee1f05fe4d6b4ae9f52cbfb71">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a10c3cdd9accf2547e975ddb78558e9b4">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a1fbf857d7dc61def6aafaf42dc45f118">OGRCompoundCurve</a>, and <a class="el" href="classOGRCircularString.html#ae4dbce1e06fa7f072902fcc2594428d0">OGRCircularString</a>.</p>

</div>
</div>
<a id="a2fd7942e610dbbafea8814cc1e330cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd7942e610dbbafea8814cc1e330cb4">&#9670;&nbsp;</a></span>getNumPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurve::getNumPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of points of a curve geometry. </p>
<p>This method, as a method of <a class="el" href="classOGRCurve.html" title="Abstract curve base class for OGRLineString, OGRCircularString and OGRCompoundCurve.">OGRCurve</a>, does not relate to a standard. For circular strings or linestrings, it returns the number of points, conforming to SF COM NumPoints(). For compound curves, it returns the sum of the number of points of each of its components (non including intermediate starting/ending points of the different parts).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of points of the curve.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#af6d8f024013f7fd7f7f1c6d68806d3a6">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#ae31f9882782e9f396c729d56c8e1edcf">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a6a0e729a1330a28dd40a66d0396b7d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0e729a1330a28dd40a66d0396b7d9c">&#9670;&nbsp;</a></span>getPointIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPointIterator.html">OGRPointIterator</a> * OGRCurve::getPointIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a point iterator over the curve. </p>
<p>The curve must not be modified while an iterator exists on it.</p>
<p>The iterator must be destroyed with <a class="el" href="classOGRPointIterator.html#ab5bbe328274ff86ae7c3734a207c254e" title="Destroys a point iterator.">OGRPointIterator::destroy()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a point iterator over the curve.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#a702b23c287499fc075d2837b3c82d5df">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#ae97040bc2869a945f516517bffc7a328">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a66a53c103e37c6d1ead00d2d74586ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a53c103e37c6d1ead00d2d74586ddd">&#9670;&nbsp;</a></span>getSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRGeometry::getSpatialReference </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns spatial reference system for object. </p>
<p>This method relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf" title="Returns spatial reference system for geometry.">OGR_G_GetSpatialReference()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the spatial reference object. The object may be shared with many geometry objects, and should not be modified. </dd></dl>

</div>
</div>
<a id="a15afb03f64091205af0530d8d1262798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15afb03f64091205af0530d8d1262798">&#9670;&nbsp;</a></span>hasCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::hasCurveGeometry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bLookForNonLinear</em> = <code>FALSE</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if this geometry is or has curve geometry. </p>
<p>Returns if a geometry is, contains or may contain a CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE.</p>
<p>If bLookForNonLinear is set to TRUE, it will be actually looked if the geometry or its subgeometries are or contain a non-linear geometry in them. In which case, if the method returns TRUE, it means that <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a> would return an approximate version of the geometry. Otherwise, <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a> would do a conversion, but with just converting container type, like COMPOUNDCURVE -&gt; LINESTRING, MULTICURVE -&gt; MULTILINESTRING or MULTISURFACE -&gt; MULTIPOLYGON, resulting in a "loss-less" conversion.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#af4f8e7d05f06a1fe69ea9638085e5e26" title="Returns if this geometry is or has curve geometry.">OGR_G_HasCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bLookForNonLinear</td><td>set it to TRUE to check if the geometry is or contains a CIRCULARSTRING.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this geometry is or has curve geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRMultiLineString.html#a678746170012f8bb9a06edaa8b913f19">OGRMultiLineString</a>, <a class="el" href="classOGRMultiCurve.html#a487d0d04e3fa4adabfbd2015c67a1dc5">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#adae8036c3438d18714a9da1f01b0d8dd">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#a7cb0d5b6c4772cd8ead5582c9f2ac117">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a1bbc86aef701032ea2e4817d0a7c55aa">OGRMultiPolygon</a>, <a class="el" href="classOGRMultiSurface.html#af552b59005624d9cfbd77f9731f75ea0">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#affd13afe6b29f1bca6823f88aadaffe0">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a473e648dc1d29d9776811b27ad53b7a2">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#af3e3b31c4b80544151852e825f3f555c">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ae3514beab03dc72a2a551218d6e52491">OGRCompoundCurve</a>, and <a class="el" href="classOGRCircularString.html#afb4ef3593c52575d22dcef4bd7166e49">OGRCircularString</a>.</p>

</div>
</div>
<a id="aa7c0b7bbebcc6e0dede9d225cd02d7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c0b7bbebcc6e0dede9d225cd02d7cc">&#9670;&nbsp;</a></span>hasEmptyParts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRGeometry::hasEmptyParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a geometry has empty parts/rings. </p>
<p>Returns true if <a class="el" href="classOGRGeometry.html#ad660b4366042e85a96f450777d43197e" title="Remove empty parts/rings from this geometry.">removeEmptyParts()</a> will modify the geometry.</p>
<p>This is different from <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111" title="Returns TRUE (non-zero) if the object has no points.">IsEmpty()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a2f903c98864111c7fd36d98acdb21685">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a636e024cd49bd849580bb974a783165c">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#ab68b3d8d04a972574df76758d0dbe92a">OGRCurvePolygon</a>, and <a class="el" href="classOGRCompoundCurve.html#a520749195198ecfd9f88a544c71e2675">OGRCompoundCurve</a>.</p>

</div>
</div>
<a id="ae2231c970e4075202cafb4f6a69e07e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2231c970e4075202cafb4f6a69e07e6">&#9670;&nbsp;</a></span>importFromWkb() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em> = <code>static_cast&lt;size_t&gt;(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em> = <code><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6a7459e8d11fa69e89271771c8d0f265d8">wkbVariantOldOgc</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary.">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>if wkbVariantPostGIS1, special interpretation is done for curve geometries code</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a0fe73abb288066cc511546350829c136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe73abb288066cc511546350829c136">&#9670;&nbsp;</a></span>importFromWkb() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkb </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>nBytesConsumedOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary.">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f" title="Assign geometry from well known binary data.">OGR_G_ImportFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known. </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>if wkbVariantPostGIS1, special interpretation is done for curve geometries code </td></tr>
    <tr><td class="paramname">nBytesConsumedOut</td><td>output parameter. Number of bytes consumed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiLineString.html#ae21ff12bb9a7b2e1213c4a76c540d1aa">OGRMultiLineString</a>, <a class="el" href="classOGRPolyhedralSurface.html#a40ea584bca7befc22b14f3e9548c23b4">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiPolygon.html#a805f89128ae9c95893176c44a640191f">OGRMultiPolygon</a>, <a class="el" href="classOGRGeometryCollection.html#a836603b47b5026649cbd6a908061e2da">OGRGeometryCollection</a>, <a class="el" href="classOGRTriangle.html#a669e6383ac8f68d632ddb6366eea998f">OGRTriangle</a>, <a class="el" href="classOGRPolygon.html#a8527c3c09a7e677131d29acc9ff8636b">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a7b22999d7055ac9f2d9d92728213e33f">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ae41c9e29bf628c05abde405cb6818553">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a3a6a7938e624e4e1f1a426109a20f188">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a93d53d119c85f47c9e7659269c93c6b8">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#af73944697981ecad2f0f88b6c8b350a0">OGRPoint</a>.</p>

</div>
</div>
<a id="ac7129d4459a847a8ea6ec8b5efc24c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7129d4459a847a8ea6ec8b5efc24c71">&#9670;&nbsp;</a></span>importFromWkt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>in GDAL 2.3 </dd></dl>

</div>
</div>
<a id="af1bb0f7cae630c31511766718bcc5b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bb0f7cae630c31511766718bcc5b66">&#9670;&nbsp;</a></span>importFromWkt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::importFromWkt </td>
          <td>(</td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppszInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type. This method is used by the <a class="el" href="classOGRGeometryFactory.html" title="Create geometry objects from well known text/binary.">OGRGeometryFactory</a> class, but not normally called by application code.</p>
<p>This method relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8" title="Assign geometry from well known text data.">OGR_G_ImportFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszInput</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

<p>Implemented in <a class="el" href="classOGRMultiCurve.html#a6f58ca204d4882bb2bbc0c8e7cdb7dee">OGRMultiCurve</a>, <a class="el" href="classOGRMultiPoint.html#ac4151d5a2b0fa6879007ffc9496ba9cd">OGRMultiPoint</a>, <a class="el" href="classOGRPolyhedralSurface.html#a8ccd8d83db6335228e3aa4ae7fbf9b37">OGRPolyhedralSurface</a>, <a class="el" href="classOGRMultiSurface.html#a809baf6868016dfe4efdcd9f7a13b42f">OGRMultiSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aa151b02502d60eb5d9a2eaa7a68fde63">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a7e59ca06b3f87c688d4ad4ff3b31fd24">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#a154a45e780861e77d1a17520c08a527d">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ab44a873bdf7e9adfa5ae19a7578893a1">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#ad03352f887b09040332ff1c17e87dcb3">OGRCircularString</a>, <a class="el" href="classOGRSimpleCurve.html#a35279777e9d344683e8521fefa4b674e">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a280e5260440a81ff8374f7d14c99f4ab">OGRPoint</a>.</p>

</div>
</div>
<a id="ae2fc420ca5d995bfef55adb1819a31f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fc420ca5d995bfef55adb1819a31f2">&#9670;&nbsp;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c" title="Do these features intersect?">Intersects()</a> method can be used to test if two geometries intersect.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb" title="Compute intersection.">OGR_G_Intersection()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry intersected with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

</div>
</div>
<a id="a12b9bf1e607908703d68bcdd5a82440c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b9bf1e607908703d68bcdd5a82440c">&#9670;&nbsp;</a></span>Intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.</p>
<p>The poOtherGeom argument may be safely NULL, but in this case the method will always return TRUE. That is, a NULL geometry is treated as being everywhere.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect?">OGR_G_Intersects()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCurvePolygon.html#a78ec798e8a8918c0bf71edceff9765da">OGRCurvePolygon</a>, and <a class="el" href="classOGRPoint.html#ae732577a0dbaccb0aafe03caf49b65dd">OGRPoint</a>.</p>

</div>
</div>
<a id="a17e80959432bc0b1d67d7cdc77d9c47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e80959432bc0b1d67d7cdc77d9c47b">&#9670;&nbsp;</a></span>IntersectsPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurve::IntersectsPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a point intersects a (closed) curve. </p>
<p>Final users should use <a class="el" href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c" title="Do these features intersect?">OGRGeometry::Intersects()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if it intersects the curve, FALSE otherwise or -1 if unknown.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ae9867dbbd6b840ca9c9240c7cb9c3b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9867dbbd6b840ca9c9240c7cb9c3b8c">&#9670;&nbsp;</a></span>Is3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Is3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the geometry has a Z component. </p>

</div>
</div>
<a id="abda3c4627b8de0b9066e0133e6a65cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda3c4627b8de0b9066e0133e6a65cb1">&#9670;&nbsp;</a></span>isClockwise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRCurve::isClockwise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if the ring has clockwise winding (or less than 2 points) </p>
<p>Assumes that the line is closed.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if clockwise otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRLineString.html#a9cf3dc8a4a3324c65528afef39d13d52">OGRLineString</a>.</p>

</div>
</div>
<a id="ac124a8520c4fbd02fd9b4b0e9ba42c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac124a8520c4fbd02fd9b4b0e9ba42c0a">&#9670;&nbsp;</a></span>IsConvex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRCurve::IsConvex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a (closed) curve forms a convex shape. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the curve forms a convex shape.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac8653ba97e53f3e3b041946ca2acc111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8653ba97e53f3e3b041946ca2acc111">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE (non-zero) if the object has no points. </p>
<p>Normally this returns FALSE except between when an object is instantiated and points have been assigned.</p>
<p>This method relates to the SFCOM IGeometry::IsEmpty() method.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if object is empty, otherwise FALSE. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#a2282450711465eed4f559d0fb29f72f8">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a909d9a27284d3e1f32b5d17bd34568ef">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#aa659e9d7d87da1ae552a69a7fc5508f9">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#af8f2d0c97340ab615dd2424d3b03e1eb">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#afec30fb77311843160528536ab9bd3a3">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#abc9e91d93d4707bc0fa25754bb70d583">OGRPoint</a>.</p>

</div>
</div>
<a id="a959d5776c17018e362b580b1e61e1caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959d5776c17018e362b580b1e61e1caa">&#9670;&nbsp;</a></span>IsMeasured()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsMeasured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the geometry has a M component. </p>

</div>
</div>
<a id="a0dc11c1807724ec7e3f3f777ddbede40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc11c1807724ec7e3f3f777ddbede40">&#9670;&nbsp;</a></span>IsRectangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRGeometry::IsRectangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the geometry is a polygon with 4 corners forming a rectangle. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

</div>
</div>
<a id="afe3c69f5b89fa5eb0bfb03e4880822bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3c69f5b89fa5eb0bfb03e4880822bf">&#9670;&nbsp;</a></span>IsRing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826" title="Test if the geometry is a ring.">OGR_G_IsRing()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="afe41ef903c94999a81a98c356b32e624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe41ef903c94999a81a98c356b32e624">&#9670;&nbsp;</a></span>IsSimple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsSimple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is simple. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73" title="Returns TRUE if the geometry is simple.">OGR_G_IsSimple()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a681c8b8f8136764fd689ffbce24085d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681c8b8f8136764fd689ffbce24085d3">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b" title="Test if the geometry is valid.">OGR_G_IsValid()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always return FALSE.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRCircularString.html#a540c540f8454d5c6726969caf3e8f904">OGRCircularString</a>.</p>

</div>
</div>
<a id="a700a2d4b1c719e1f65fa3009bfc04f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700a2d4b1c719e1f65fa3009bfc04f78">&#9670;&nbsp;</a></span>MakeValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::MakeValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to make an invalid geometry valid without losing vertices. </p>
<p>Already-valid geometries are cloned without further intervention.</p>
<p>Running <a class="el" href="classOGRGeometryFactory.html#a9dda76280700944f813f6b4c8e7be7a0" title="Remove sub-geometries from a geometry collection that do not have the maximum topological dimensional...">OGRGeometryFactory::removeLowerDimensionSubGeoms()</a> as a post-processing step is often desired.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4e24b3b68c6fc20ed8a315451bd61514" title="Attempts to make an invalid geometry valid without losing vertices.">OGR_G_MakeValid()</a>.</p>
<p>This function is built on the GEOS &gt;= 3.8 library, check it for the definition of the geometry operation. If OGR is built without the GEOS &gt;= 3.8 library, this function will return a clone of the input geometry if it is valid, or NULL if it is invalid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or NULL. The following options are available: <ul>
<li>
METHOD=LINEWORK/STRUCTURE. LINEWORK is the default method, which combines all rings into a set of noded lines and then extracts valid polygons from that linework. The STRUCTURE method (requires GEOS &gt;= 3.10 and GDAL &gt;= 3.4) first makes all rings valid, then merges shells and subtracts holes from shells to generate valid result. Assumes that holes and shells are correctly categorized. </li>
<li>
KEEP_COLLAPSED=YES/NO. Only for METHOD=STRUCTURE. NO (default): collapses are converted to empty geometries YES: collapses are converted to a valid geometry of lower dimension. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="aa518a2cafc2a2394bc3a5196fa7dd017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa518a2cafc2a2394bc3a5196fa7dd017">&#9670;&nbsp;</a></span>Normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to bring geometry into normalized/canonical form. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#affbc131cab986a87e0db5b8b4dda91e3" title="Attempts to bring geometry into normalized/canonical form.">OGR_G_Normalize()</a>.</p>
<p>This function is built on the GEOS library; check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a432b89868f8094004467e8e9b51ad5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432b89868f8094004467e8e9b51ad5ca">&#9670;&nbsp;</a></span>Overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other passed into the method overlap, that is their intersection has a non-zero area.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb" title="Test for overlap.">OGR_G_Overlaps()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a9f35edabf2e5d40a79f07f77d56a2459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f35edabf2e5d40a79f07f77d56a2459">&#9670;&nbsp;</a></span>Polygonize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Polygonize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b" title="Polygonizes a set of sparse edges.">OGR_G_Polygonize()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="ad660b4366042e85a96f450777d43197e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad660b4366042e85a96f450777d43197e">&#9670;&nbsp;</a></span>removeEmptyParts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::removeEmptyParts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove empty parts/rings from this geometry. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a70fb35c751777e47c590c3fdb3c038a4">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a915a2701666b542b8be121b850e902e5">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#afb504bdf32f5da406f0de9021cc18ab9">OGRCurvePolygon</a>, and <a class="el" href="classOGRCompoundCurve.html#a98d063b1fdcafdb567be096b8026a08f">OGRCompoundCurve</a>.</p>

</div>
</div>
<a id="a0f008712013032d876cc60860d317a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f008712013032d876cc60860d317a33">&#9670;&nbsp;</a></span>roundCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::roundCoordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRGeomCoordinatePrecision.html">OGRGeomCoordinatePrecision</a> &amp;&#160;</td>
          <td class="paramname"><em>sPrecision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round coordinates of the geometry to the specified precision. </p>
<p>Note that this is not the same as <a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGRGeometry::SetPrecision()</a>. The later will return valid geometries, whereas <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a> does not make such guarantee and may return geometries with invalidities, if they are not compatible of the specified precision. <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a> supports curve geometries, whereas <a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">SetPrecision()</a> does not currently.</p>
<p>One use case for <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a> is to undo the effect of quantizeCoordinates().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sPrecision</td><td>Contains the precision requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ad3667da6ea2f9416c8f1b747391d0171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3667da6ea2f9416c8f1b747391d0171">&#9670;&nbsp;</a></span>roundCoordinatesIEEE754()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::roundCoordinatesIEEE754 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOGRGeomCoordinateBinaryPrecision.html">OGRGeomCoordinateBinaryPrecision</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Round coordinates of a geometry, exploiting characteristics of the IEEE-754 double-precision binary representation. </p>
<p>Determines the number of bits (N) required to represent a coordinate value with a specified number of digits after the decimal point, and then sets all but the N most significant bits to zero. The resulting coordinate value will still round to the original value (e.g. after <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a>), but will have improved compressiblity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>Contains the precision requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a91685bd7c0bdd67cd073a8b4da3c06a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91685bd7c0bdd67cd073a8b4da3c06a5">&#9670;&nbsp;</a></span>segmentize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::segmentize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>This method modifies the geometry to add intermediate vertices if necessary so that the maximum length between 2 consecutive vertices is lower than dfMaxLength.</p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423" title="Modify the geometry such it has no segment longer then the given distance.">OGR_G_Segmentize()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMaxLength</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRGeometryCollection.html#aa3dfea765e5d59542825a80d060af98e">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a922d66445e62efa2199595821dfc3d44">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ac55ba5da766a3adcd73d1664e516532c">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a699d38f5d172b803411aba9fcb8a10ef">OGRCircularString</a>, and <a class="el" href="classOGRSimpleCurve.html#a9241df908a32e3e6a89027797a730be1">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="ad4dc0ab8f5269e24faad26387e344913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dc0ab8f5269e24faad26387e344913">&#9670;&nbsp;</a></span>set3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::set3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td>
          <td class="paramname"><em>bIs3D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or remove the Z coordinate dimension. </p>
<p>This method adds or removes the explicit Z coordinate dimension. Removing the Z coordinate dimension of a geometry will remove any existing Z values. Adding the Z dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIs3D</td><td>Should the geometry have a Z dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a83b3277b37d362cc0863e90174314610">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#aaa7c464bf1dd02bcfbe3d942b4398c05">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#afb4e059b5d4965304f795044910c8769">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a110a942d747ec30dd1e0a43a74f642a8">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#a77dd58c81f9e3bb2fe5882e437d85319">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a79f84a2b948d511f28c47c47577dea49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f84a2b948d511f28c47c47577dea49">&#9670;&nbsp;</a></span>setCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::setCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewDimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>use <a class="el" href="classOGRGeometry.html#ad4dc0ab8f5269e24faad26387e344913" title="Add or remove the Z coordinate dimension.">set3D()</a> or <a class="el" href="classOGRGeometry.html#a5f1d7eea437838415a14f9dc54523857" title="Add or remove the M coordinate dimension.">setMeasured()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nNewDimension</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a31f3c231a49f20332fdc5050883ac173">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#accce5440870d67ee44499cfa9045e1af">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#adf41d14265fdabd4b4ceb3d8c22341fa">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a7a66c4c9a9f70fe0cf3ff1e587f54d85">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a0002d7766820341a235cf339c515623d">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a7ca8c6afb50f61d5fbd4a9bdd04f65f6">OGRPoint</a>.</p>

</div>
</div>
<a id="a5f1d7eea437838415a14f9dc54523857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1d7eea437838415a14f9dc54523857">&#9670;&nbsp;</a></span>setMeasured()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::setMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a>&#160;</td>
          <td class="paramname"><em>bIsMeasured</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add or remove the M coordinate dimension. </p>
<p>This method adds or removes the explicit M coordinate dimension. Removing the M coordinate dimension of a geometry will remove any existing M values. Adding the M dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIsMeasured</td><td>Should the geometry have a M dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a2546d2dd69b3fb42eeecf78c9a54c542">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a579b3b5efb71816115c68b90155df3b5">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#adf784aaad99c0878b5bc8f8e5a65c3b0">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a2eebb511ed8a59fe3d6c08a804f55891">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#a8f8630903d62298da0b82c403b4ba2df">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a36db4751a05c870f180fde6f1a6d939c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36db4751a05c870f180fde6f1a6d939c">&#9670;&nbsp;</a></span>SetPrecision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SetPrecision </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfGridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the geometry's precision, rounding all its coordinates to the precision grid, and making sure the geometry is still valid. </p>
<p>This is a stronger version of <a class="el" href="classOGRGeometry.html#a0f008712013032d876cc60860d317a33" title="Round coordinates of the geometry to the specified precision.">roundCoordinates()</a>.</p>
<p>Note that at time of writing GEOS does no supported curve geometries. So currently if this function is called on such a geometry, OGR will first call <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480" title="Return, possibly approximate, non-curve version of this geometry.">getLinearGeometry()</a> on the input and <a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1" title="Return curve version of this geometry.">getCurveGeometry()</a> on the output, but that it is unlikely to yield to the expected result.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a90133f7d05c95ae681274cce4481c74f" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGR_G_SetPrecision()</a>.</p>
<p>This function is built on the GEOSGeom_setPrecision_r() function of the GEOS library. Check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfGridSize</td><td>size of the precision grid, or 0 for FLOATING precision. </td></tr>
    <tr><td class="paramname">nFlags</td><td>The bitwise OR of zero, one or several of OGR_GEOS_PREC_NO_TOPO and OGR_GEOS_PREC_KEEP_COLLAPSED</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a40909bc6bc40b9aecfdae5cb70160eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40909bc6bc40b9aecfdae5cb70160eaa">&#9670;&nbsp;</a></span>Simplify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Simplify </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the geometry. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c" title="Compute a simplified geometry.">OGR_G_Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a3951fc5d0043af5794dd08d738e0a1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951fc5d0043af5794dd08d738e0a1dc">&#9670;&nbsp;</a></span>SimplifyPreserveTopology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6" title="Simplify the geometry while preserving topology.">OGR_G_SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a28510cf9de71e098b50d241f6ab99cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28510cf9de71e098b50d241f6ab99cd1">&#9670;&nbsp;</a></span>StartPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurve::StartPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the curve start point. </p>
<p>This method relates to the SF COM ICurve::get_StartPoint() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poPoint</td><td>the point to be assigned the start location. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#a33888a6d9a344d0416bc6baad9bb62a5">OGRCompoundCurve</a>, and <a class="el" href="classOGRSimpleCurve.html#aa950fd6890ae1560a8f54c3ec834732a">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a3ffd51d4998a8e2ae422c69b6adf480a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffd51d4998a8e2ae422c69b6adf480a">&#9670;&nbsp;</a></span>swapXY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeometry::swapXY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPolyhedralSurface.html#a56b0ea1f8755897755fbc73bb328158b">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a129ed0276ea145b66ce1da1a5a0c6b1e">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a820f36b21407a7400b0af0a5d95b0e5e">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a222976c0791c8fe47cb26efc245ff2e6">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a2c243eb37885b8affd9f6c7cbd24ff7e">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#a6598d91071a583dce1c462aa6f4778c4">OGRPoint</a>.</p>

</div>
</div>
<a id="ab0a5c298bb0dcc4d44500278238e0ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a5c298bb0dcc4d44500278238e0ac2">&#9670;&nbsp;</a></span>SymDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::SymDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the second geometry passed into the method.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5" title="Compute symmetric difference.">OGR_G_SymDifference()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a07a3f3726ec41a2579ccaadf34d109b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a3f3726ec41a2579ccaadf34d109b9">&#9670;&nbsp;</a></span>toCircularString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCircularString.html">OGRCircularString</a>* OGRGeometry::toCircularString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCircularString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCircularString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a875b6ecbd4f1676999766e157c3a6534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875b6ecbd4f1676999766e157c3a6534">&#9670;&nbsp;</a></span>toCircularString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCircularString.html">OGRCircularString</a>* OGRGeometry::toCircularString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCircularString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCircularString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a60510a2c16c5735dc358bc2a19b1640d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60510a2c16c5735dc358bc2a19b1640d">&#9670;&nbsp;</a></span>toCompoundCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a>* OGRGeometry::toCompoundCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCompoundCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCompoundCurve. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a707f30f63e8edaefa72c61bedbf9612b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707f30f63e8edaefa72c61bedbf9612b">&#9670;&nbsp;</a></span>toCompoundCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCompoundCurve.html">OGRCompoundCurve</a>* OGRGeometry::toCompoundCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCompoundCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCompoundCurve. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ace2d0dbea86042310b29903dd69ed8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2d0dbea86042310b29903dd69ed8fd">&#9670;&nbsp;</a></span>toCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurve.html">OGRCurve</a>* OGRGeometry::toCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurve*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(<a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">getGeometryType()</a>, wkbCurve). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a47ae22b8c03d3d249f96b5ab73df8d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae22b8c03d3d249f96b5ab73df8d01">&#9670;&nbsp;</a></span>toCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurve.html">OGRCurve</a>* OGRGeometry::toCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurve*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(<a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">getGeometryType()</a>, wkbCurve). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a2307d44f31cc898ecbc2c8349bbc82f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2307d44f31cc898ecbc2c8349bbc82f9">&#9670;&nbsp;</a></span>toCurvePolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a>* OGRGeometry::toCurvePolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurvePolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCurvePolygon or wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a11ec9e634d5afc42f0891b5cf3e5f92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ec9e634d5afc42f0891b5cf3e5f92a">&#9670;&nbsp;</a></span>toCurvePolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRCurvePolygon.html">OGRCurvePolygon</a>* OGRGeometry::toCurvePolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRCurvePolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbCurvePolygon or wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a9fdf3c79104eb641260abcc2b4a7cc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdf3c79104eb641260abcc2b4a7cc43">&#9670;&nbsp;</a></span>toGeometryCollection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a>* OGRGeometry::toGeometryCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRGeometryCollection*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(<a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">getGeometryType()</a>, wkbGeometryCollection). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a304deeb16cfc1c986cd9b587918113d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304deeb16cfc1c986cd9b587918113d0">&#9670;&nbsp;</a></span>toGeometryCollection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRGeometryCollection.html">OGRGeometryCollection</a>* OGRGeometry::toGeometryCollection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRGeometryCollection*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(<a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">getGeometryType()</a>, wkbGeometryCollection). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ae518798c9e80bad59b0907f43d375876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae518798c9e80bad59b0907f43d375876">&#9670;&nbsp;</a></span>ToHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGRGeometry::ToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRGeometry* to a OGRGeometryH. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a087c768a91d977f065caa4f7b75e71b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087c768a91d977f065caa4f7b75e71b6">&#9670;&nbsp;</a></span>toLinearRing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLinearRing.html">OGRLinearRing</a>* OGRGeometry::toLinearRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLinearRing*. </p>
<p>Implies prior checking that EQUAL(<a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type.">getGeometryName()</a>, "LINEARRING"). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ac84f8179340c71a8a080f74d667554db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84f8179340c71a8a080f74d667554db">&#9670;&nbsp;</a></span>toLinearRing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLinearRing.html">OGRLinearRing</a>* OGRGeometry::toLinearRing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLinearRing*. </p>
<p>Implies prior checking that EQUAL(<a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type.">getGeometryName()</a>, "LINEARRING"). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a0bd4fd93ce3b53eb809d72b301bf6a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd4fd93ce3b53eb809d72b301bf6a6e">&#9670;&nbsp;</a></span>toLineString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRLineString.html">OGRLineString</a>* OGRGeometry::toLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a87ca3e2914a891b9500f30057ecfeaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ca3e2914a891b9500f30057ecfeaba">&#9670;&nbsp;</a></span>toLineString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLineString.html">OGRLineString</a>* OGRGeometry::toLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a8345d52f5748268059f485790ad8b3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8345d52f5748268059f485790ad8b3a1">&#9670;&nbsp;</a></span>toMultiCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a>* OGRGeometry::toMultiCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiCurve and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a80bac4f129be3a7c6c39a26d5d77d1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bac4f129be3a7c6c39a26d5d77d1f2">&#9670;&nbsp;</a></span>toMultiCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiCurve.html">OGRMultiCurve</a>* OGRGeometry::toMultiCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiCurve and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a4a79860e0f5a7f7e1962a0854d140f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a79860e0f5a7f7e1962a0854d140f6d">&#9670;&nbsp;</a></span>toMultiLineString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a>* OGRGeometry::toMultiLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ab35ee3c54d11a08bdf87d9729bfd6de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35ee3c54d11a08bdf87d9729bfd6de7">&#9670;&nbsp;</a></span>toMultiLineString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiLineString.html">OGRMultiLineString</a>* OGRGeometry::toMultiLineString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiLineString*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiLineString. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ab7cd71af4f5c75ac0b9ccd64bd4b1117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cd71af4f5c75ac0b9ccd64bd4b1117">&#9670;&nbsp;</a></span>toMultiPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a>* OGRGeometry::toMultiPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a1b970c7593290b0c8c17d07bd907e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b970c7593290b0c8c17d07bd907e3d8">&#9670;&nbsp;</a></span>toMultiPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiPoint.html">OGRMultiPoint</a>* OGRGeometry::toMultiPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a07e387baec4de093ff6af3ec7ad76cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e387baec4de093ff6af3ec7ad76cbe">&#9670;&nbsp;</a></span>toMultiPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a>* OGRGeometry::toMultiPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPolygon. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a26e2f638c062af644f6ced36e7a50c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e2f638c062af644f6ced36e7a50c21">&#9670;&nbsp;</a></span>toMultiPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiPolygon.html">OGRMultiPolygon</a>* OGRGeometry::toMultiPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiPolygon. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a93bfa0ab44ce276ef9666724856c40cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bfa0ab44ce276ef9666724856c40cf">&#9670;&nbsp;</a></span>toMultiSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a>* OGRGeometry::toMultiSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiSurface and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="afffad1c5ffb37213e2aea7c20d8f7272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffad1c5ffb37213e2aea7c20d8f7272">&#9670;&nbsp;</a></span>toMultiSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRMultiSurface.html">OGRMultiSurface</a>* OGRGeometry::toMultiSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRMultiSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbMultiSurface and derived types. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="acd2a41d2ee7091a39fc3f371db9e3825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2a41d2ee7091a39fc3f371db9e3825">&#9670;&nbsp;</a></span>toPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPoint.html">OGRPoint</a>* OGRGeometry::toPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad669a3edadb4abd49db97b7d7324a3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad669a3edadb4abd49db97b7d7324a3ed">&#9670;&nbsp;</a></span>toPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPoint.html">OGRPoint</a>* OGRGeometry::toPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPoint*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPoint. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a27dff1a7736b53eb4d98c9176059fb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dff1a7736b53eb4d98c9176059fb80">&#9670;&nbsp;</a></span>toPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolygon.html">OGRPolygon</a>* OGRGeometry::toPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a947a2bdd824116d5edef0361bca4eb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947a2bdd824116d5edef0361bca4eb8a">&#9670;&nbsp;</a></span>toPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPolygon.html">OGRPolygon</a>* OGRGeometry::toPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolygon*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolygon or wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a4d1990bb40f7ef045f9f9e796883591b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1990bb40f7ef045f9f9e796883591b">&#9670;&nbsp;</a></span>toPolyhedralSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a>* OGRGeometry::toPolyhedralSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolyhedralSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolyhedralSurface or wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="af18c6c25bdfee09e0fdd8d99e2e7015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18c6c25bdfee09e0fdd8d99e2e7015d">&#9670;&nbsp;</a></span>toPolyhedralSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRPolyhedralSurface.html">OGRPolyhedralSurface</a>* OGRGeometry::toPolyhedralSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRPolyhedralSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbPolyhedralSurface or wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ac7e3b0fc468d61eb3b7516154fe648e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e3b0fc468d61eb3b7516154fe648e8">&#9670;&nbsp;</a></span>toSimpleCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a>* OGRCurve::toSimpleCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSimpleCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbLineString or wkbCircularString. </p>

</div>
</div>
<a id="a253b329aac356125fffd2cc50f5788e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b329aac356125fffd2cc50f5788e4">&#9670;&nbsp;</a></span>toSimpleCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRSimpleCurve.html">OGRSimpleCurve</a>* OGRCurve::toSimpleCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSimpleCurve*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbLineString or wkbCircularString. </p>

</div>
</div>
<a id="ab897e836fd4781637a34014833b1ee3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab897e836fd4781637a34014833b1ee3d">&#9670;&nbsp;</a></span>toSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSurface.html">OGRSurface</a>* OGRGeometry::toSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSurface*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(<a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">getGeometryType()</a>, wkbSurface). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a7d6c3418b804db5eef7e16b86dee45f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6c3418b804db5eef7e16b86dee45f2">&#9670;&nbsp;</a></span>toSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRSurface.html">OGRSurface</a>* OGRGeometry::toSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRSurface*. </p>
<p>Implies prior checking that OGR_GT_IsSubClass(<a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">getGeometryType()</a>, wkbSurface). </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aa62fb2faaa7fe58555a39509a5ef2714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62fb2faaa7fe58555a39509a5ef2714">&#9670;&nbsp;</a></span>toTriangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRTriangle.html">OGRTriangle</a>* OGRGeometry::toTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangle*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abad9439b0742c3bb6173c221357befb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad9439b0742c3bb6173c221357befb5">&#9670;&nbsp;</a></span>toTriangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRTriangle.html">OGRTriangle</a>* OGRGeometry::toTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangle*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTriangle. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a46bef33c21122557417dd57517421201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bef33c21122557417dd57517421201">&#9670;&nbsp;</a></span>toTriangulatedSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a>* OGRGeometry::toTriangulatedSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangulatedSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a35e8fb584a3412b2a605b97218f52fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e8fb584a3412b2a605b97218f52fb3">&#9670;&nbsp;</a></span>toTriangulatedSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRTriangulatedSurface.html">OGRTriangulatedSurface</a>* OGRGeometry::toTriangulatedSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Down-cast to OGRTriangulatedSurface*. </p>
<p>Implies prior checking that <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten(getGeometryType())</a> == wkbTIN. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="abd1be78538ab56a7c16cfa65797eeb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1be78538ab56a7c16cfa65797eeb0c">&#9670;&nbsp;</a></span>Touches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Touches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other passed into the method are touching.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9" title="Test for touching.">OGR_G_Touches()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="aa9e8bfb3c2129f25cf622660f734e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e8bfb3c2129f25cf622660f734e1ba">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRCoordinateTransformation.html">OGRCoordinateTransformation</a> *&#160;</td>
          <td class="paramname"><em>poCT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this method does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This method only does reprojection on a point-by-point basis. It does not include advanced logic to deal with discontinuities at poles or antimeridian. For that, use the <a class="el" href="classOGRGeometryFactory.html#a47b03de00271a9ca9902d2c8920414ad" title="Transform a geometry.">OGRGeometryFactory::transformWithOptions()</a> method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry.">OGR_G_Transform()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poCT</td><td>the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Implemented in <a class="el" href="classOGRGeometryCollection.html#ad5f7ae4a8937b11450277f22ba599af2">OGRGeometryCollection</a>, <a class="el" href="classOGRCurvePolygon.html#a6c14e71640ee125335023f2f0124aecc">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#ae3c157dbef9191d4f1c8cf00e2c133b9">OGRCompoundCurve</a>, <a class="el" href="classOGRLinearRing.html#a969a7a442a3ae16f1e042e5413113509">OGRLinearRing</a>, <a class="el" href="classOGRSimpleCurve.html#aaccfa682c2fa499d3613fc5980d881a7">OGRSimpleCurve</a>, <a class="el" href="classOGRPoint.html#a620731c7abab289a7b109c4ea8c39fe0">OGRPoint</a>, and <a class="el" href="classOGRPolyhedralSurface.html#aa8ba9e1bc7f4f8ddd50634b095ffa441">OGRPolyhedralSurface</a>.</p>

</div>
</div>
<a id="abc0ec206bcafdd27eef5ef455d366af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0ec206bcafdd27eef5ef455d366af3">&#9670;&nbsp;</a></span>transformTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRGeometry::transformTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSR</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This method will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This method will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this method requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> object it is significantly more expensive to use this method to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> in advance, and call <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba" title="Apply arbitrary coordinate transformation to geometry.">transform()</a> with that transformation. This method exists primarily for convenience when only transforming a single geometry.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63" title="Transform geometry to new spatial reference system.">OGR_G_TransformTo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poSR</td><td>spatial reference system to transform to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

</div>
</div>
<a id="a744223cab4361ffcdab949cebf27d5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744223cab4361ffcdab949cebf27d5ad">&#9670;&nbsp;</a></span>UnaryUnion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::UnaryUnion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the union of all components of a single geometry. </p>
<p>Usually used to convert a collection into the smallest set of polygons that cover the same area.</p>
<p>See <a href="https://postgis.net/docs/ST_UnaryUnion.html">https://postgis.net/docs/ST_UnaryUnion.html</a> for more details.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae4e284189448b23bc3dae1ad7ab54b50" title="Returns the union of all components of a single geometry.">OGR_G_UnaryUnion()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a9e4f808adcccaedbecc29fe034d312dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4f808adcccaedbecc29fe034d312dc">&#9670;&nbsp;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::Union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0" title="Compute union.">OGR_G_Union()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the other geometry unioned with "this" geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a94533c5ac2331889ac93089c3316971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94533c5ac2331889ac93089c3316971c">&#9670;&nbsp;</a></span>UnionCascaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRGeometry::UnionCascaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute union using cascading. </p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>The input geometry must be a MultiPolygon.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f" title="Compute union using cascading.">OGR_G_UnionCascaded()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use <a class="el" href="classOGRGeometry.html#a744223cab4361ffcdab949cebf27d5ad" title="Returns the union of all components of a single geometry.">UnaryUnion()</a> instead </dd></dl>

</div>
</div>
<a id="a690570c5282483c043c0badbf94ce38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690570c5282483c043c0badbf94ce38b">&#9670;&nbsp;</a></span>Value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCurve::Value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRPoint.html">OGRPoint</a> *&#160;</td>
          <td class="paramname"><em>poPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch point at given distance along curve. </p>
<p>This method relates to the SF COM ICurve::get_Value() method.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aadec1c54cea3139fce7b5866e41fc9b8" title="Fetch point at given distance along curve.">OGR_G_Value()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfDistance</td><td>distance along the curve at which to sample position. This distance should be between zero and <a class="el" href="classOGRCurve.html#a09d2e65489ca56fc4f09a281b50f3e74" title="Returns the length of the curve.">get_Length()</a> for this curve. </td></tr>
    <tr><td class="paramname">poPoint</td><td>the point to be assigned the curve position. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classOGRCompoundCurve.html#acb8f13fd5984b006ba9011047ada71de">OGRCompoundCurve</a>, <a class="el" href="classOGRCircularString.html#a510f278253e059721c0bcba9751e0b92">OGRCircularString</a>, and <a class="el" href="classOGRSimpleCurve.html#a4958b1d7eff5caf93918c62d6ffe7666">OGRSimpleCurve</a>.</p>

</div>
</div>
<a id="a9803164ead0c4fbea9eafce64184160c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9803164ead0c4fbea9eafce64184160c">&#9670;&nbsp;</a></span>Within()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a1a234b9cde6d25c581b72e2b3c5af664">OGRBoolean</a> OGRGeometry::Within </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poOtherGeom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if actual geometry object is within the passed geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">IsValid()</a> before, otherwise the result might be wrong.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72" title="Test for containment.">OGR_G_Within()</a>.</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poOtherGeom</td><td>the geometry to compare to this geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if poOtherGeom is within this geometry, otherwise FALSE. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRPoint.html#a6d60b7f1e06f837425e598ddc47443a8">OGRPoint</a>.</p>

</div>
</div>
<a id="acd1a8164dae2e44e50990756ed6b8b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1a8164dae2e44e50990756ed6b8b4a">&#9670;&nbsp;</a></span>WkbSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGeometry::WkbSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This method returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This method relates to the SFCOM IWks::WkbSize() method.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>size of binary representation in bytes. </dd></dl>

<p>Implemented in <a class="el" href="classOGRPolyhedralSurface.html#af21589e667b666b6a5f2d7c0ac3c351a">OGRPolyhedralSurface</a>, <a class="el" href="classOGRGeometryCollection.html#a54ab93473041f3bb22a700547b5ce878">OGRGeometryCollection</a>, <a class="el" href="classOGRPolygon.html#a6e5fccb1ca9e2b655c420f2bad47b9cb">OGRPolygon</a>, <a class="el" href="classOGRCurvePolygon.html#ae402b4ce557a98b5f2871d5de9852a5b">OGRCurvePolygon</a>, <a class="el" href="classOGRCompoundCurve.html#a6e99d5466268f937839601f9d4119c67">OGRCompoundCurve</a>, <a class="el" href="classOGRSimpleCurve.html#a0f7e5cf3a544bdd9aacaafaa8f78f5ce">OGRSimpleCurve</a>, and <a class="el" href="classOGRPoint.html#aaba8135dfeb19ae3d16899b466acc082">OGRPoint</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogr__geometry_8h_source.html">ogr_geometry.h</a></li>
<li>ogrcurve.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
