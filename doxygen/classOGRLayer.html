<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: OGRLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOGRLayer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OGRLayer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents a layer of simple features, with access methods.  
 <a href="classOGRLayer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ogrsf__frmts_8h_source.html">ogrsf_frmts.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OGRLayer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOGRLayer.png" usemap="#OGRLayer_map" alt=""/>
  <map id="OGRLayer_map" name="OGRLayer_map">
<area href="classGDALMajorObject.html" title="Object with metadata." alt="GDALMajorObject" shape="rect" coords="98,0,284,24"/>
<area href="classGNMGenericLayer.html" title="GNM layer which represents a geography network layer of generic format." alt="GNMGenericLayer" shape="rect" coords="0,112,186,136"/>
<area href="classOGRGNMWrappedResultLayer.html" title="The OGRGNMWrappedResultLayer class for search paths queries results." alt="OGRGNMWrappedResultLayer" shape="rect" coords="196,112,382,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6ffe33197f239fc68161f2e01daecff2"><td class="memItemLeft" align="right" valign="top"><a id="a6ffe33197f239fc68161f2e01daecff2"></a>
typedef std::vector&lt; std::unique_ptr&lt; <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a>, OGRSpatialReferenceReleaser &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6ffe33197f239fc68161f2e01daecff2">GetSupportedSRSListRetType</a></td></tr>
<tr class="memdesc:a6ffe33197f239fc68161f2e01daecff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of <a class="el" href="classOGRLayer.html#a2c576ac25d6001967f55e8bae6b8ec53" title="Get the list of SRS supported.">OGRLayer::GetSupportedSRSList()</a> <br /></td></tr>
<tr class="separator:a6ffe33197f239fc68161f2e01daecff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95f19fa71f244c4408ceb92d5fe6b308"><td class="memItemLeft" align="right" valign="top">FeatureIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a95f19fa71f244c4408ceb92d5fe6b308">begin</a> ()</td></tr>
<tr class="memdesc:a95f19fa71f244c4408ceb92d5fe6b308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin of feature iterator.  <a href="classOGRLayer.html#a95f19fa71f244c4408ceb92d5fe6b308">More...</a><br /></td></tr>
<tr class="separator:a95f19fa71f244c4408ceb92d5fe6b308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd93204c89e3cafa062507c60f41cb9"><td class="memItemLeft" align="right" valign="top"><a id="a8cd93204c89e3cafa062507c60f41cb9"></a>
FeatureIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a8cd93204c89e3cafa062507c60f41cb9">end</a> ()</td></tr>
<tr class="memdesc:a8cd93204c89e3cafa062507c60f41cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of feature iterator. <br /></td></tr>
<tr class="separator:a8cd93204c89e3cafa062507c60f41cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3735e444204d46f517eec251712f4d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d">GetSpatialFilter</a> ()</td></tr>
<tr class="memdesc:adc3735e444204d46f517eec251712f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the current spatial filter for this layer.  <a href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d">More...</a><br /></td></tr>
<tr class="separator:adc3735e444204d46f517eec251712f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4ab45cf97cbc470f0d60474d3e4169"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">SetSpatialFilter</a> (<a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:a0b4ab45cf97cbc470f0d60474d3e4169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169">More...</a><br /></td></tr>
<tr class="separator:a0b4ab45cf97cbc470f0d60474d3e4169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd16bcdb3e8f720003fb24cd68f25460"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460">SetSpatialFilterRect</a> (double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr class="memdesc:acd16bcdb3e8f720003fb24cd68f25460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460">More...</a><br /></td></tr>
<tr class="separator:acd16bcdb3e8f720003fb24cd68f25460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac60fb86ee178be016655532070ee3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3">SetSpatialFilter</a> (int iGeomField, <a class="el" href="classOGRGeometry.html">OGRGeometry</a> *)</td></tr>
<tr class="memdesc:aebac60fb86ee178be016655532070ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3">More...</a><br /></td></tr>
<tr class="separator:aebac60fb86ee178be016655532070ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd4ceb8f4ec20594be63280c8e4498a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">SetSpatialFilterRect</a> (int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr class="memdesc:a5cd4ceb8f4ec20594be63280c8e4498a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="classOGRLayer.html#a5cd4ceb8f4ec20594be63280c8e4498a">More...</a><br /></td></tr>
<tr class="separator:a5cd4ceb8f4ec20594be63280c8e4498a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c6cc5fa3577df5be538284c1b0dde"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">SetAttributeFilter</a> (const char *)</td></tr>
<tr class="memdesc:acb2c6cc5fa3577df5be538284c1b0dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new attribute query.  <a href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde">More...</a><br /></td></tr>
<tr class="separator:acb2c6cc5fa3577df5be538284c1b0dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0f2cd7f0587584b8f382c6a913583c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">ResetReading</a> ()=0</td></tr>
<tr class="memdesc:aad0f2cd7f0587584b8f382c6a913583c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset feature reading to start on the first feature.  <a href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c">More...</a><br /></td></tr>
<tr class="separator:aad0f2cd7f0587584b8f382c6a913583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d21ff33b32d14fa4e9885b9edecad6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">GetNextFeature</a> ()=0</td></tr>
<tr class="memdesc:a47d21ff33b32d14fa4e9885b9edecad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6">More...</a><br /></td></tr>
<tr class="separator:a47d21ff33b32d14fa4e9885b9edecad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b0869ff6fcadda35cbac1f3edf8eae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae">SetNextByIndex</a> (<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nIndex)</td></tr>
<tr class="memdesc:ac0b0869ff6fcadda35cbac1f3edf8eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move read cursor to the nIndex'th feature in the current resultset.  <a href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae">More...</a><br /></td></tr>
<tr class="separator:ac0b0869ff6fcadda35cbac1f3edf8eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace902dfb44335fb1a877aa035ecff209"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209">GetFeature</a> (<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nFID)</td></tr>
<tr class="memdesc:ace902dfb44335fb1a877aa035ecff209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209">More...</a><br /></td></tr>
<tr class="separator:ace902dfb44335fb1a877aa035ecff209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ea789c139b6894258e1788eb01e7e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGDALDataset.html">GDALDataset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a527ea789c139b6894258e1788eb01e7e">GetDataset</a> ()</td></tr>
<tr class="memdesc:a527ea789c139b6894258e1788eb01e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dataset associated with this layer.  <a href="classOGRLayer.html#a527ea789c139b6894258e1788eb01e7e">More...</a><br /></td></tr>
<tr class="separator:a527ea789c139b6894258e1788eb01e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa8511632cbb7cff06a908e6668f55"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55">GetArrowStream</a> (struct ArrowArrayStream *out_stream, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr)</td></tr>
<tr class="memdesc:a3ffa8511632cbb7cff06a908e6668f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a Arrow C stream.  <a href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55">More...</a><br /></td></tr>
<tr class="separator:a3ffa8511632cbb7cff06a908e6668f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6238309c2ca47804da68096f838740"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aad6238309c2ca47804da68096f838740">IsArrowSchemaSupported</a> (const struct ArrowSchema *schema, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions, std::string &amp;osErrorMsg) const</td></tr>
<tr class="memdesc:aad6238309c2ca47804da68096f838740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the provided ArrowSchema is supported for writing.  <a href="classOGRLayer.html#aad6238309c2ca47804da68096f838740">More...</a><br /></td></tr>
<tr class="separator:aad6238309c2ca47804da68096f838740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931c8aac9aa389fa58cacdecbf731579"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a931c8aac9aa389fa58cacdecbf731579">CreateFieldFromArrowSchema</a> (const struct ArrowSchema *schema, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr)</td></tr>
<tr class="memdesc:a931c8aac9aa389fa58cacdecbf731579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a field from an ArrowSchema.  <a href="classOGRLayer.html#a931c8aac9aa389fa58cacdecbf731579">More...</a><br /></td></tr>
<tr class="separator:a931c8aac9aa389fa58cacdecbf731579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaae8cb73e0e45d6eb8a06a44b4836c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c">WriteArrowBatch</a> (const struct ArrowSchema *schema, struct ArrowArray *array, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions=nullptr)</td></tr>
<tr class="memdesc:adaaae8cb73e0e45d6eb8a06a44b4836c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a batch of rows from an ArrowArray.  <a href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c">More...</a><br /></td></tr>
<tr class="separator:adaaae8cb73e0e45d6eb8a06a44b4836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681139bfd585b74d7218e51a32144283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283">SetFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr class="memdesc:a681139bfd585b74d7218e51a32144283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite/replace an existing feature.  <a href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283">More...</a><br /></td></tr>
<tr class="separator:a681139bfd585b74d7218e51a32144283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1e32016f481596a55e1d988a15a067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">CreateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr class="memdesc:aaa1e32016f481596a55e1d988a15a067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067">More...</a><br /></td></tr>
<tr class="separator:aaa1e32016f481596a55e1d988a15a067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fde458509b0cccc23d2ce89c1fd9dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb">UpsertFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr class="memdesc:a0fde458509b0cccc23d2ce89c1fd9dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite/replace an existing feature or create a new feature within a layer.  <a href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb">More...</a><br /></td></tr>
<tr class="separator:a0fde458509b0cccc23d2ce89c1fd9dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ff65e1809eefacfa1d8f56deb1b39d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d">UpdateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature, int nUpdatedFieldsCount, const int *panUpdatedFieldsIdx, int nUpdatedGeomFieldsCount, const int *panUpdatedGeomFieldsIdx, bool bUpdateStyleString)</td></tr>
<tr class="memdesc:ad4ff65e1809eefacfa1d8f56deb1b39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update (part of) an existing feature.  <a href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d">More...</a><br /></td></tr>
<tr class="separator:ad4ff65e1809eefacfa1d8f56deb1b39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2342e79e0248076c2205047e1928f296"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2342e79e0248076c2205047e1928f296">DeleteFeature</a> (<a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nFID)</td></tr>
<tr class="memdesc:a2342e79e0248076c2205047e1928f296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete feature from layer.  <a href="classOGRLayer.html#a2342e79e0248076c2205047e1928f296">More...</a><br /></td></tr>
<tr class="separator:a2342e79e0248076c2205047e1928f296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f5ec7728cacc2f7d94882a9f1a22e"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e">GetName</a> ()</td></tr>
<tr class="memdesc:a287f5ec7728cacc2f7d94882a9f1a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer name.  <a href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e">More...</a><br /></td></tr>
<tr class="separator:a287f5ec7728cacc2f7d94882a9f1a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a25520ce08d5a681443348e930604"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604">GetGeomType</a> ()</td></tr>
<tr class="memdesc:a818a25520ce08d5a681443348e930604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer geometry type.  <a href="classOGRLayer.html#a818a25520ce08d5a681443348e930604">More...</a><br /></td></tr>
<tr class="separator:a818a25520ce08d5a681443348e930604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80473bcfd11341e70dd35bebe94026cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">GetLayerDefn</a> ()=0</td></tr>
<tr class="memdesc:a80473bcfd11341e70dd35bebe94026cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf">More...</a><br /></td></tr>
<tr class="separator:a80473bcfd11341e70dd35bebe94026cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef41bcd7adad1ac5ddcef54d6b38713c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c">FindFieldIndex</a> (const char *pszFieldName, int bExactMatch)</td></tr>
<tr class="memdesc:aef41bcd7adad1ac5ddcef54d6b38713c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of field in the layer.  <a href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c">More...</a><br /></td></tr>
<tr class="separator:aef41bcd7adad1ac5ddcef54d6b38713c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c06b4993f8eb76b569f37365cd19ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab">GetSpatialRef</a> ()</td></tr>
<tr class="memdesc:a75c06b4993f8eb76b569f37365cd19ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab">More...</a><br /></td></tr>
<tr class="separator:a75c06b4993f8eb76b569f37365cd19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c576ac25d6001967f55e8bae6b8ec53"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOGRLayer.html#a6ffe33197f239fc68161f2e01daecff2">GetSupportedSRSListRetType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2c576ac25d6001967f55e8bae6b8ec53">GetSupportedSRSList</a> (int iGeomField)</td></tr>
<tr class="memdesc:a2c576ac25d6001967f55e8bae6b8ec53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of SRS supported.  <a href="classOGRLayer.html#a2c576ac25d6001967f55e8bae6b8ec53">More...</a><br /></td></tr>
<tr class="separator:a2c576ac25d6001967f55e8bae6b8ec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c677104b157df424dbb7cba88757342"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a1c677104b157df424dbb7cba88757342">SetActiveSRS</a> (int iGeomField, const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *poSRS)</td></tr>
<tr class="memdesc:a1c677104b157df424dbb7cba88757342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the active SRS.  <a href="classOGRLayer.html#a1c677104b157df424dbb7cba88757342">More...</a><br /></td></tr>
<tr class="separator:a1c677104b157df424dbb7cba88757342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0e1a43fd1a0a6d55d766384da7b6a5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2d0e1a43fd1a0a6d55d766384da7b6a5">GetFeatureCount</a> (int bForce=TRUE)</td></tr>
<tr class="memdesc:a2d0e1a43fd1a0a6d55d766384da7b6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="classOGRLayer.html#a2d0e1a43fd1a0a6d55d766384da7b6a5">More...</a><br /></td></tr>
<tr class="separator:a2d0e1a43fd1a0a6d55d766384da7b6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be658ddb5b33d1ed95c31286774bbd2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2">GetExtent</a> (<a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE)</td></tr>
<tr class="memdesc:a3be658ddb5b33d1ed95c31286774bbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2">More...</a><br /></td></tr>
<tr class="separator:a3be658ddb5b33d1ed95c31286774bbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3cc550866eee1668bea2315f9df9c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a47a3cc550866eee1668bea2315f9df9c">GetExtent</a> (int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce=TRUE)</td></tr>
<tr class="memdesc:a47a3cc550866eee1668bea2315f9df9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="classOGRLayer.html#a47a3cc550866eee1668bea2315f9df9c">More...</a><br /></td></tr>
<tr class="separator:a47a3cc550866eee1668bea2315f9df9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c96b5540aaf8d5c2769430ed0e8be9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ad3c96b5540aaf8d5c2769430ed0e8be9">GetExtent3D</a> (int iGeomField, <a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psExtent3D, int bForce=TRUE)</td></tr>
<tr class="memdesc:ad3c96b5540aaf8d5c2769430ed0e8be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the 3D extent of this layer, on the specified geometry field.  <a href="classOGRLayer.html#ad3c96b5540aaf8d5c2769430ed0e8be9">More...</a><br /></td></tr>
<tr class="separator:ad3c96b5540aaf8d5c2769430ed0e8be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedbda1a62f9b89b8e5f24332cf22286"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286">TestCapability</a> (const char *)=0</td></tr>
<tr class="memdesc:aeedbda1a62f9b89b8e5f24332cf22286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286">More...</a><br /></td></tr>
<tr class="separator:aeedbda1a62f9b89b8e5f24332cf22286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb9669950015866ae2460d9b26755df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adcb9669950015866ae2460d9b26755df">Rename</a> (const char *pszNewName)</td></tr>
<tr class="memdesc:adcb9669950015866ae2460d9b26755df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename layer.  <a href="classOGRLayer.html#adcb9669950015866ae2460d9b26755df">More...</a><br /></td></tr>
<tr class="separator:adcb9669950015866ae2460d9b26755df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ece498332c3054281f17939dceeab4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a69ece498332c3054281f17939dceeab4">CreateField</a> (const <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *poField, int bApproxOK=TRUE)</td></tr>
<tr class="memdesc:a69ece498332c3054281f17939dceeab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field on a layer.  <a href="classOGRLayer.html#a69ece498332c3054281f17939dceeab4">More...</a><br /></td></tr>
<tr class="separator:a69ece498332c3054281f17939dceeab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebe7c671dca995549543eecf0f7a76a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a">DeleteField</a> (int iField)</td></tr>
<tr class="memdesc:aaebe7c671dca995549543eecf0f7a76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing field on a layer.  <a href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a">More...</a><br /></td></tr>
<tr class="separator:aaebe7c671dca995549543eecf0f7a76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd364a150d91f8d65d967646e0f92d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3">ReorderFields</a> (int *panMap)</td></tr>
<tr class="memdesc:aebd364a150d91f8d65d967646e0f92d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder all the fields of a layer.  <a href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3">More...</a><br /></td></tr>
<tr class="separator:aebd364a150d91f8d65d967646e0f92d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52f539d34466c10b7c031a8270544b4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4">AlterFieldDefn</a> (int iField, <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *poNewFieldDefn, int nFlagsIn)</td></tr>
<tr class="memdesc:af52f539d34466c10b7c031a8270544b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the definition of an existing field on a layer.  <a href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4">More...</a><br /></td></tr>
<tr class="separator:af52f539d34466c10b7c031a8270544b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a87755bff79d25c5774280023dda0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b">AlterGeomFieldDefn</a> (int iGeomField, const <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *poNewGeomFieldDefn, int nFlagsIn)</td></tr>
<tr class="memdesc:a49a87755bff79d25c5774280023dda0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the definition of an existing geometry field on a layer.  <a href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b">More...</a><br /></td></tr>
<tr class="separator:a49a87755bff79d25c5774280023dda0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a4b0693ff9490881d213484b0bfe5d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a87a4b0693ff9490881d213484b0bfe5d">CreateGeomField</a> (const <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *poField, int bApproxOK=TRUE)</td></tr>
<tr class="memdesc:a87a4b0693ff9490881d213484b0bfe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new geometry field on a layer.  <a href="classOGRLayer.html#a87a4b0693ff9490881d213484b0bfe5d">More...</a><br /></td></tr>
<tr class="separator:a87a4b0693ff9490881d213484b0bfe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb07284c734e485d8611b7c8599254f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f">SyncToDisk</a> ()</td></tr>
<tr class="memdesc:aebb07284c734e485d8611b7c8599254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending changes to disk.  <a href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f">More...</a><br /></td></tr>
<tr class="separator:aebb07284c734e485d8611b7c8599254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65f762d5b3c6fc4ca0f0cc4aafcdcbe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ac65f762d5b3c6fc4ca0f0cc4aafcdcbe">GetStyleTable</a> ()</td></tr>
<tr class="memdesc:ac65f762d5b3c6fc4ca0f0cc4aafcdcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns layer style table.  <a href="classOGRLayer.html#ac65f762d5b3c6fc4ca0f0cc4aafcdcbe">More...</a><br /></td></tr>
<tr class="separator:ac65f762d5b3c6fc4ca0f0cc4aafcdcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2687d4312c044bb3a20bd13974ba8905"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905">SetStyleTableDirectly</a> (<a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *poStyleTable)</td></tr>
<tr class="memdesc:a2687d4312c044bb3a20bd13974ba8905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set layer style table.  <a href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905">More...</a><br /></td></tr>
<tr class="separator:a2687d4312c044bb3a20bd13974ba8905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fa0802c0686fb0e6ca6337e11cd7d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5">SetStyleTable</a> (<a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *poStyleTable)</td></tr>
<tr class="memdesc:a33fa0802c0686fb0e6ca6337e11cd7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set layer style table.  <a href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5">More...</a><br /></td></tr>
<tr class="separator:a33fa0802c0686fb0e6ca6337e11cd7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2855f6fae6f97fa1cebcc2f57a0f974f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2855f6fae6f97fa1cebcc2f57a0f974f">StartTransaction</a> ()</td></tr>
<tr class="memdesc:a2855f6fae6f97fa1cebcc2f57a0f974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, StartTransaction creates a transaction.  <a href="classOGRLayer.html#a2855f6fae6f97fa1cebcc2f57a0f974f">More...</a><br /></td></tr>
<tr class="separator:a2855f6fae6f97fa1cebcc2f57a0f974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cafa399e8f3027158787c87c3d1b97e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6cafa399e8f3027158787c87c3d1b97e">CommitTransaction</a> ()</td></tr>
<tr class="memdesc:a6cafa399e8f3027158787c87c3d1b97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, CommitTransaction commits a transaction.  <a href="classOGRLayer.html#a6cafa399e8f3027158787c87c3d1b97e">More...</a><br /></td></tr>
<tr class="separator:a6cafa399e8f3027158787c87c3d1b97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab046dbffc4fbd5bacc6ef75da0686d82"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ab046dbffc4fbd5bacc6ef75da0686d82">RollbackTransaction</a> ()</td></tr>
<tr class="memdesc:ab046dbffc4fbd5bacc6ef75da0686d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction.  <a href="classOGRLayer.html#ab046dbffc4fbd5bacc6ef75da0686d82">More...</a><br /></td></tr>
<tr class="separator:ab046dbffc4fbd5bacc6ef75da0686d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cb9a05310d7b17d9dfec9e83a18e61"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61">GetFIDColumn</a> ()</td></tr>
<tr class="memdesc:af0cb9a05310d7b17d9dfec9e83a18e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the FID column, or "" if not supported.  <a href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61">More...</a><br /></td></tr>
<tr class="separator:af0cb9a05310d7b17d9dfec9e83a18e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68036c23622c954ce3a91861f22b724"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724">GetGeometryColumn</a> ()</td></tr>
<tr class="memdesc:af68036c23622c954ce3a91861f22b724"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the geometry column, or "" if not supported.  <a href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724">More...</a><br /></td></tr>
<tr class="separator:af68036c23622c954ce3a91861f22b724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f2e7ee476337082cea814226be11a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a">SetIgnoredFields</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszFields)</td></tr>
<tr class="memdesc:aaf3f2e7ee476337082cea814226be11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which fields can be omitted when retrieving features from the layer.  <a href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a">More...</a><br /></td></tr>
<tr class="separator:aaf3f2e7ee476337082cea814226be11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770e610904df8c3ebac47419e86ece69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structOGRGeometryTypeCounter.html">OGRGeometryTypeCounter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a770e610904df8c3ebac47419e86ece69">GetGeometryTypes</a> (int iGeomField, int nFlagsGGT, int &amp;nEntryCountOut, GDALProgressFunc pfnProgress, void *pProgressData)</td></tr>
<tr class="memdesc:a770e610904df8c3ebac47419e86ece69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get actual geometry types found in features.  <a href="classOGRLayer.html#a770e610904df8c3ebac47419e86ece69">More...</a><br /></td></tr>
<tr class="separator:a770e610904df8c3ebac47419e86ece69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5202606175f7e7dcd76c3eb237ac8303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a5202606175f7e7dcd76c3eb237ac8303">Intersection</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a5202606175f7e7dcd76c3eb237ac8303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two layers.  <a href="classOGRLayer.html#a5202606175f7e7dcd76c3eb237ac8303">More...</a><br /></td></tr>
<tr class="separator:a5202606175f7e7dcd76c3eb237ac8303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0598c7dab1f4dbe3e2735e27450c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adf0598c7dab1f4dbe3e2735e27450c9c">Union</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:adf0598c7dab1f4dbe3e2735e27450c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two layers.  <a href="classOGRLayer.html#adf0598c7dab1f4dbe3e2735e27450c9c">More...</a><br /></td></tr>
<tr class="separator:adf0598c7dab1f4dbe3e2735e27450c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781aa76c6b44b19de09f61816e32245b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">SymDifference</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions, GDALProgressFunc pfnProgress, void *pProgressArg)</td></tr>
<tr class="memdesc:a781aa76c6b44b19de09f61816e32245b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrical difference of two layers.  <a href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b">More...</a><br /></td></tr>
<tr class="separator:a781aa76c6b44b19de09f61816e32245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ff64cc8b070819da0a7e121ff07b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a385ff64cc8b070819da0a7e121ff07b3">Identity</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a385ff64cc8b070819da0a7e121ff07b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the features of this layer with the ones from the identity layer.  <a href="classOGRLayer.html#a385ff64cc8b070819da0a7e121ff07b3">More...</a><br /></td></tr>
<tr class="separator:a385ff64cc8b070819da0a7e121ff07b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b86f3a070fe99e39631c994be4fce08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6b86f3a070fe99e39631c994be4fce08">Update</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a6b86f3a070fe99e39631c994be4fce08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this layer with features from the update layer.  <a href="classOGRLayer.html#a6b86f3a070fe99e39631c994be4fce08">More...</a><br /></td></tr>
<tr class="separator:a6b86f3a070fe99e39631c994be4fce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822deb3b2d047185e3a454692619291c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a822deb3b2d047185e3a454692619291c">Clip</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a822deb3b2d047185e3a454692619291c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip off areas that are not covered by the method layer.  <a href="classOGRLayer.html#a822deb3b2d047185e3a454692619291c">More...</a><br /></td></tr>
<tr class="separator:a822deb3b2d047185e3a454692619291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fa292ae87af3bc0d3abb3963a71914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a23fa292ae87af3bc0d3abb3963a71914">Erase</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerMethod, <a class="el" href="classOGRLayer.html">OGRLayer</a> *pLayerResult, char **papszOptions=nullptr, GDALProgressFunc pfnProgress=nullptr, void *pProgressArg=nullptr)</td></tr>
<tr class="memdesc:a23fa292ae87af3bc0d3abb3963a71914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove areas that are covered by the method layer.  <a href="classOGRLayer.html#a23fa292ae87af3bc0d3abb3963a71914">More...</a><br /></td></tr>
<tr class="separator:a23fa292ae87af3bc0d3abb3963a71914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae783de2e9ee2629e6bf27fd3b8622fb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ae783de2e9ee2629e6bf27fd3b8622fb5">Reference</a> ()</td></tr>
<tr class="memdesc:ae783de2e9ee2629e6bf27fd3b8622fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment layer reference count.  <a href="classOGRLayer.html#ae783de2e9ee2629e6bf27fd3b8622fb5">More...</a><br /></td></tr>
<tr class="separator:ae783de2e9ee2629e6bf27fd3b8622fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2271d53f75d4f6ff2f4a8aeb71e825d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2271d53f75d4f6ff2f4a8aeb71e825d6">Dereference</a> ()</td></tr>
<tr class="memdesc:a2271d53f75d4f6ff2f4a8aeb71e825d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement layer reference count.  <a href="classOGRLayer.html#a2271d53f75d4f6ff2f4a8aeb71e825d6">More...</a><br /></td></tr>
<tr class="separator:a2271d53f75d4f6ff2f4a8aeb71e825d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3cea24856572302ae11ed97ca33375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adf3cea24856572302ae11ed97ca33375">GetRefCount</a> () const</td></tr>
<tr class="memdesc:adf3cea24856572302ae11ed97ca33375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch reference count.  <a href="classOGRLayer.html#adf3cea24856572302ae11ed97ca33375">More...</a><br /></td></tr>
<tr class="separator:adf3cea24856572302ae11ed97ca33375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c02b991bfa78552eeb0cbcdcf1aed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">ReorderField</a> (int iOldFieldPos, int iNewFieldPos)</td></tr>
<tr class="memdesc:ab4c02b991bfa78552eeb0cbcdcf1aed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder an existing field on a layer.  <a href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8">More...</a><br /></td></tr>
<tr class="separator:ab4c02b991bfa78552eeb0cbcdcf1aed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb345b2a42f86842b520e09069526f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#aafb345b2a42f86842b520e09069526f0">GetMOFlags</a> () const</td></tr>
<tr class="memdesc:aafb345b2a42f86842b520e09069526f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GMO_ flags.  <a href="classGDALMajorObject.html#aafb345b2a42f86842b520e09069526f0">More...</a><br /></td></tr>
<tr class="separator:aafb345b2a42f86842b520e09069526f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1af15d780eba6cc9937160d8cc6b2b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#ae1af15d780eba6cc9937160d8cc6b2b7">SetMOFlags</a> (int nFlagsIn)</td></tr>
<tr class="memdesc:ae1af15d780eba6cc9937160d8cc6b2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign GMO_flags.  <a href="classGDALMajorObject.html#ae1af15d780eba6cc9937160d8cc6b2b7">More...</a><br /></td></tr>
<tr class="separator:ae1af15d780eba6cc9937160d8cc6b2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af769554a8632dda9f99db325664a37cf"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#af769554a8632dda9f99db325664a37cf">GetDescription</a> () const</td></tr>
<tr class="memdesc:af769554a8632dda9f99db325664a37cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch object description.  <a href="classGDALMajorObject.html#af769554a8632dda9f99db325664a37cf">More...</a><br /></td></tr>
<tr class="separator:af769554a8632dda9f99db325664a37cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af334bc8d152f130a55783ea36938735b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#af334bc8d152f130a55783ea36938735b">SetDescription</a> (const char *)</td></tr>
<tr class="memdesc:af334bc8d152f130a55783ea36938735b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set object description.  <a href="classGDALMajorObject.html#af334bc8d152f130a55783ea36938735b">More...</a><br /></td></tr>
<tr class="separator:af334bc8d152f130a55783ea36938735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e2cebbfa60a5e3f5cb4aa2e9b80d12"><td class="memItemLeft" align="right" valign="top">virtual char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12">GetMetadataDomainList</a> ()</td></tr>
<tr class="memdesc:a83e2cebbfa60a5e3f5cb4aa2e9b80d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch list of metadata domains.  <a href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12">More...</a><br /></td></tr>
<tr class="separator:a83e2cebbfa60a5e3f5cb4aa2e9b80d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce3bf5795bbebfe9bc643e2152bb360"><td class="memItemLeft" align="right" valign="top">virtual char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a8ce3bf5795bbebfe9bc643e2152bb360">GetMetadata</a> (const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:a8ce3bf5795bbebfe9bc643e2152bb360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch metadata.  <a href="classGDALMajorObject.html#a8ce3bf5795bbebfe9bc643e2152bb360">More...</a><br /></td></tr>
<tr class="separator:a8ce3bf5795bbebfe9bc643e2152bb360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ab7226d95b20e3e1f42461a1f62906"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a61ab7226d95b20e3e1f42461a1f62906">SetMetadata</a> (char **papszMetadata, const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:a61ab7226d95b20e3e1f42461a1f62906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata.  <a href="classGDALMajorObject.html#a61ab7226d95b20e3e1f42461a1f62906">More...</a><br /></td></tr>
<tr class="separator:a61ab7226d95b20e3e1f42461a1f62906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17f496c8b6d0c0be6f52437d3ba8a6d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#ad17f496c8b6d0c0be6f52437d3ba8a6d">GetMetadataItem</a> (const char *pszName, const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:ad17f496c8b6d0c0be6f52437d3ba8a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch single metadata item.  <a href="classGDALMajorObject.html#ad17f496c8b6d0c0be6f52437d3ba8a6d">More...</a><br /></td></tr>
<tr class="separator:ad17f496c8b6d0c0be6f52437d3ba8a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e157735f6ff6e11935c2a2dbcc24c92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92">SetMetadataItem</a> (const char *pszName, const char *pszValue, const char *pszDomain=&quot;&quot;)</td></tr>
<tr class="memdesc:a3e157735f6ff6e11935c2a2dbcc24c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set single metadata item.  <a href="classGDALMajorObject.html#a3e157735f6ff6e11935c2a2dbcc24c92">More...</a><br /></td></tr>
<tr class="separator:a3e157735f6ff6e11935c2a2dbcc24c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6f202957750f4477a94a1a76c3ae91f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6f202957750f4477a94a1a76c3ae91f3">ToHandle</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *poLayer)</td></tr>
<tr class="memdesc:a6f202957750f4477a94a1a76c3ae91f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRLayer* to a OGRLayerH.  <a href="classOGRLayer.html#a6f202957750f4477a94a1a76c3ae91f3">More...</a><br /></td></tr>
<tr class="separator:a6f202957750f4477a94a1a76c3ae91f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6114f65f0fa09b55b4324a876623c7d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6114f65f0fa09b55b4324a876623c7d3">FromHandle</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer)</td></tr>
<tr class="memdesc:a6114f65f0fa09b55b4324a876623c7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OGRLayerH to a OGRLayer*.  <a href="classOGRLayer.html#a6114f65f0fa09b55b4324a876623c7d3">More...</a><br /></td></tr>
<tr class="separator:a6114f65f0fa09b55b4324a876623c7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341ee268785b7e54714f789de59f23fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="gdal_8h.html#ace297748fac88851533c56ddec20084f">GDALMajorObjectH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#a341ee268785b7e54714f789de59f23fe">ToHandle</a> (<a class="el" href="classGDALMajorObject.html">GDALMajorObject</a> *poMajorObject)</td></tr>
<tr class="memdesc:a341ee268785b7e54714f789de59f23fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a GDALMajorObject* to a GDALMajorObjectH.  <a href="classGDALMajorObject.html#a341ee268785b7e54714f789de59f23fe">More...</a><br /></td></tr>
<tr class="separator:a341ee268785b7e54714f789de59f23fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aeaa832ad40d9bf5e4a23e43c8c92c2ce"><td class="memItemLeft" align="right" valign="top"><a id="aeaa832ad40d9bf5e4a23e43c8c92c2ce"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aeaa832ad40d9bf5e4a23e43c8c92c2ce">DEFAULT_ARROW_FID_NAME</a> = &quot;OGC_FID&quot;</td></tr>
<tr class="memdesc:aeaa832ad40d9bf5e4a23e43c8c92c2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field name used by <a class="el" href="classOGRLayer.html#ad3ec416786dda7808b11b772942e2b60" title="Default implementation of the ArrowArrayStream::get_schema() callback.">GetArrowSchema()</a> for a FID column when <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61" title="This method returns the name of the underlying database column being used as the FID column,...">GetFIDColumn()</a> is not set. <br /></td></tr>
<tr class="separator:aeaa832ad40d9bf5e4a23e43c8c92c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae079dc0eac54cc4ad068c7bdfb295acd"><td class="memItemLeft" align="right" valign="top"><a id="ae079dc0eac54cc4ad068c7bdfb295acd"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ae079dc0eac54cc4ad068c7bdfb295acd">DEFAULT_ARROW_GEOMETRY_NAME</a> = &quot;wkb_geometry&quot;</td></tr>
<tr class="memdesc:ae079dc0eac54cc4ad068c7bdfb295acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Field name used by <a class="el" href="classOGRLayer.html#ad3ec416786dda7808b11b772942e2b60" title="Default implementation of the ArrowArrayStream::get_schema() callback.">GetArrowSchema()</a> for the name of the (single) geometry column (returned by <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column,...">GetGeometryColumn()</a>) is not set. <br /></td></tr>
<tr class="separator:ae079dc0eac54cc4ad068c7bdfb295acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a604ff4dcb92b2ef184c106765c1ed600"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a604ff4dcb92b2ef184c106765c1ed600">ISetFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr class="memdesc:a604ff4dcb92b2ef184c106765c1ed600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite/replace an existing feature.  <a href="classOGRLayer.html#a604ff4dcb92b2ef184c106765c1ed600">More...</a><br /></td></tr>
<tr class="separator:a604ff4dcb92b2ef184c106765c1ed600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474993a66cecaa1443c2e82cc14ae615"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a474993a66cecaa1443c2e82cc14ae615">ICreateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr class="memdesc:a474993a66cecaa1443c2e82cc14ae615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="classOGRLayer.html#a474993a66cecaa1443c2e82cc14ae615">More...</a><br /></td></tr>
<tr class="separator:a474993a66cecaa1443c2e82cc14ae615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc7613af3d5324c7cb01e848d27c09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a3ebc7613af3d5324c7cb01e848d27c09">IUpsertFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature)</td></tr>
<tr class="memdesc:a3ebc7613af3d5324c7cb01e848d27c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite/replace an existing feature or create a new feature within a layer.  <a href="classOGRLayer.html#a3ebc7613af3d5324c7cb01e848d27c09">More...</a><br /></td></tr>
<tr class="separator:a3ebc7613af3d5324c7cb01e848d27c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df7531259b276477a74c7f265a2fc62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a3df7531259b276477a74c7f265a2fc62">IUpdateFeature</a> (<a class="el" href="classOGRFeature.html">OGRFeature</a> *poFeature, int nUpdatedFieldsCount, const int *panUpdatedFieldsIdx, int nUpdatedGeomFieldsCount, const int *panUpdatedGeomFieldsIdx, bool bUpdateStyleString)</td></tr>
<tr class="memdesc:a3df7531259b276477a74c7f265a2fc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update (part of) an existing feature.  <a href="classOGRLayer.html#a3df7531259b276477a74c7f265a2fc62">More...</a><br /></td></tr>
<tr class="separator:a3df7531259b276477a74c7f265a2fc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec416786dda7808b11b772942e2b60"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ad3ec416786dda7808b11b772942e2b60">GetArrowSchema</a> (struct ArrowArrayStream *, struct ArrowSchema *out_schema)</td></tr>
<tr class="memdesc:ad3ec416786dda7808b11b772942e2b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the ArrowArrayStream::get_schema() callback.  <a href="classOGRLayer.html#ad3ec416786dda7808b11b772942e2b60">More...</a><br /></td></tr>
<tr class="separator:ad3ec416786dda7808b11b772942e2b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66920f61837a2944468c8c9a434e5bf6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a66920f61837a2944468c8c9a434e5bf6">GetNextArrowArray</a> (struct ArrowArrayStream *, struct ArrowArray *out_array)</td></tr>
<tr class="memdesc:a66920f61837a2944468c8c9a434e5bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the ArrowArrayStream::get_next() callback.  <a href="classOGRLayer.html#a66920f61837a2944468c8c9a434e5bf6">More...</a><br /></td></tr>
<tr class="separator:a66920f61837a2944468c8c9a434e5bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb80dab3954bfa409520f132dd11e479"><td class="memItemLeft" align="right" valign="top"><a id="afb80dab3954bfa409520f132dd11e479"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#afb80dab3954bfa409520f132dd11e479">CanPostFilterArrowArray</a> (const struct ArrowSchema *schema) const</td></tr>
<tr class="memdesc:afb80dab3954bfa409520f132dd11e479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the <a class="el" href="classOGRLayer.html#ab22d1c941fa9de205d3ea74e765d3978" title="Remove rows that aren&#39;t selected by the spatial or attribute filter.">PostFilterArrowArray()</a> can work on the schema to remove rows that aren't selected by the spatial or attribute filter. <br /></td></tr>
<tr class="separator:afb80dab3954bfa409520f132dd11e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d1c941fa9de205d3ea74e765d3978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ab22d1c941fa9de205d3ea74e765d3978">PostFilterArrowArray</a> (const struct ArrowSchema *schema, struct ArrowArray *array, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions) const</td></tr>
<tr class="memdesc:ab22d1c941fa9de205d3ea74e765d3978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove rows that aren't selected by the spatial or attribute filter.  <a href="classOGRLayer.html#ab22d1c941fa9de205d3ea74e765d3978">More...</a><br /></td></tr>
<tr class="separator:ab22d1c941fa9de205d3ea74e765d3978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a75ef69ecc93177d0f57f8d745b111"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGDALMajorObject.html#aa3a75ef69ecc93177d0f57f8d745b111">BuildMetadataDomainList</a> (char **papszList, int bCheckNonEmpty,...) <a class="el" href="cpl__port_8h.html#a3181c953b783da525be0a6c1975be31a">CPL_NULL_TERMINATED</a></td></tr>
<tr class="memdesc:aa3a75ef69ecc93177d0f57f8d745b111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for custom implementations of <a class="el" href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12" title="Fetch list of metadata domains.">GetMetadataDomainList()</a>  <a href="classGDALMajorObject.html#aa3a75ef69ecc93177d0f57f8d745b111">More...</a><br /></td></tr>
<tr class="separator:aa3a75ef69ecc93177d0f57f8d745b111"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a7ab18ef0293fd0938a0a1ffd5ecd4a4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a7ab18ef0293fd0938a0a1ffd5ecd4a4d">ReleaseArray</a> (struct ArrowArray *array)</td></tr>
<tr class="memdesc:a7ab18ef0293fd0938a0a1ffd5ecd4a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a ArrowArray.  <a href="classOGRLayer.html#a7ab18ef0293fd0938a0a1ffd5ecd4a4d">More...</a><br /></td></tr>
<tr class="separator:a7ab18ef0293fd0938a0a1ffd5ecd4a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fa8ac39a35e5511bea40cf3acad354"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#ad0fa8ac39a35e5511bea40cf3acad354">ReleaseSchema</a> (struct ArrowSchema *schema)</td></tr>
<tr class="memdesc:ad0fa8ac39a35e5511bea40cf3acad354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a ArrowSchema.  <a href="classOGRLayer.html#ad0fa8ac39a35e5511bea40cf3acad354">More...</a><br /></td></tr>
<tr class="separator:ad0fa8ac39a35e5511bea40cf3acad354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6637ccd2cf24eb39c50b9cadcafdf52e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a6637ccd2cf24eb39c50b9cadcafdf52e">ReleaseStream</a> (struct ArrowArrayStream *stream)</td></tr>
<tr class="memdesc:a6637ccd2cf24eb39c50b9cadcafdf52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a ArrowArrayStream.  <a href="classOGRLayer.html#a6637ccd2cf24eb39c50b9cadcafdf52e">More...</a><br /></td></tr>
<tr class="separator:a6637ccd2cf24eb39c50b9cadcafdf52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5ebed9bab6fcda662e211954f5437"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aced5ebed9bab6fcda662e211954f5437">StaticGetArrowSchema</a> (struct ArrowArrayStream *, struct ArrowSchema *out_schema)</td></tr>
<tr class="memdesc:aced5ebed9bab6fcda662e211954f5437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the ArrowArrayStream::get_schema() callback.  <a href="classOGRLayer.html#aced5ebed9bab6fcda662e211954f5437">More...</a><br /></td></tr>
<tr class="separator:aced5ebed9bab6fcda662e211954f5437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0a2c772c12364df27789a54fd03403"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#aee0a2c772c12364df27789a54fd03403">StaticGetNextArrowArray</a> (struct ArrowArrayStream *, struct ArrowArray *out_array)</td></tr>
<tr class="memdesc:aee0a2c772c12364df27789a54fd03403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the ArrowArrayStream::get_next() callback.  <a href="classOGRLayer.html#aee0a2c772c12364df27789a54fd03403">More...</a><br /></td></tr>
<tr class="separator:aee0a2c772c12364df27789a54fd03403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb51b032a0de17336aaecf74571e80e0"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#adb51b032a0de17336aaecf74571e80e0">GetLastErrorArrowArrayStream</a> (struct ArrowArrayStream *)</td></tr>
<tr class="memdesc:adb51b032a0de17336aaecf74571e80e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the ArrowArrayStream::get_last_error() callback.  <a href="classOGRLayer.html#adb51b032a0de17336aaecf74571e80e0">More...</a><br /></td></tr>
<tr class="separator:adb51b032a0de17336aaecf74571e80e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6bb295b1d7c80058d339f671c22de8"><td class="memItemLeft" align="right" valign="top"><a id="a2d6bb295b1d7c80058d339f671c22de8"></a>
static struct ArrowSchema *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a2d6bb295b1d7c80058d339f671c22de8">CreateSchemaForWKBGeometryColumn</a> (const <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *poFieldDefn, const char *pszArrowFormat, const char *pszExtensionName)</td></tr>
<tr class="memdesc:a2d6bb295b1d7c80058d339f671c22de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a ArrowSchema* corresponding to the WKB encoding of a geometry column. <br /></td></tr>
<tr class="separator:a2d6bb295b1d7c80058d339f671c22de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a044f1bbefd25b687daeae46d3d2a006f"><td class="memItemLeft" align="right" valign="top"><a id="a044f1bbefd25b687daeae46d3d2a006f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>OGRArrowArrayHelper</b></td></tr>
<tr class="separator:a044f1bbefd25b687daeae46d3d2a006f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85da9cbdc9d5a32f6479415f4d2d57"><td class="memItemLeft" align="right" valign="top">FeatureIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a1a85da9cbdc9d5a32f6479415f4d2d57">begin</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *poLayer)</td></tr>
<tr class="memdesc:a1a85da9cbdc9d5a32f6479415f4d2d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return begin of feature iterator.  <a href="classOGRLayer.html#a1a85da9cbdc9d5a32f6479415f4d2d57">More...</a><br /></td></tr>
<tr class="separator:a1a85da9cbdc9d5a32f6479415f4d2d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772fc157e7edff5deb096e7aedf7ece6"><td class="memItemLeft" align="right" valign="top">FeatureIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOGRLayer.html#a772fc157e7edff5deb096e7aedf7ece6">end</a> (<a class="el" href="classOGRLayer.html">OGRLayer</a> *poLayer)</td></tr>
<tr class="memdesc:a772fc157e7edff5deb096e7aedf7ece6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return end of feature iterator.  <a href="classOGRLayer.html#a772fc157e7edff5deb096e7aedf7ece6">More...</a><br /></td></tr>
<tr class="separator:a772fc157e7edff5deb096e7aedf7ece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a layer of simple features, with access methods. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af52f539d34466c10b7c031a8270544b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52f539d34466c10b7c031a8270544b4">&#9670;&nbsp;</a></span>AlterFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::AlterFieldDefn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poNewFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec" title="Alter the definition of an existing field on a layer.">OGR_L_AlterFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iField</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td class="paramname">poNewFieldDefn</td><td>new field definition </td></tr>
    <tr><td class="paramname">nFlags</td><td>combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a69f80c8342c6ad3b6d16ad33d8b2153c">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a49a87755bff79d25c5774280023dda0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a87755bff79d25c5774280023dda0b">&#9670;&nbsp;</a></span>AlterGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::AlterGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poNewGeomFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlagsIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alter the definition of an existing geometry field on a layer. </p>
<p>You must use this to alter the definition of an existing geometry field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>Note that altering the SRS does <em>not</em> cause coordinate reprojection to occur: this is simply a modification of the layer metadata (correcting a wrong SRS definition). No modification to existing geometries will ever be performed, so this method cannot be used to e.g. promote single part geometries to their multipart equivalents.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCAlterGeomFieldDefn capability. Some drivers might not support all update flags. The GDAL_DMD_ALTER_GEOM_FIELD_DEFN_FLAGS driver metadata item can be queried to examine which flags may be supported by a driver.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a9d73a820734d51982ab964e6d57e7d4f" title="Alter the definition of an existing geometry field on a layer.">OGR_L_AlterGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td class="paramname">poNewGeomFieldDefn</td><td>new field definition </td></tr>
    <tr><td class="paramname">nFlagsIn</td><td>combination of ALTER_GEOM_FIELD_DEFN_NAME_FLAG, ALTER_GEOM_FIELD_DEFN_TYPE_FLAG, ALTER_GEOM_FIELD_DEFN_NULLABLE_FLAG, ALTER_GEOM_FIELD_DEFN_SRS_FLAG, ALTER_GEOM_FIELD_DEFN_SRS_COORD_EPOCH_FLAG to indicate which of the name and/or type and/or nullability and/or SRS and/or coordinate epoch from the new field definition must be taken into account. Or ALTER_GEOM_FIELD_DEFN_ALL_FLAG to update all members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 3.6.0 </dd></dl>

</div>
</div>
<a id="a95f19fa71f244c4408ceb92d5fe6b308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f19fa71f244c4408ceb92d5fe6b308">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OGRLayer::FeatureIterator OGRLayer::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return begin of feature iterator. </p>
<p>Using this iterator for standard range-based loops is safe, but due to implementation limitations, you shouldn't try to access (dereference) more than one iterator step at a time, since the OGRFeatureUniquePtr reference is reused.</p>
<p>Only one iterator per layer can be active at a time. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aa3a75ef69ecc93177d0f57f8d745b111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a75ef69ecc93177d0f57f8d745b111">&#9670;&nbsp;</a></span>BuildMetadataDomainList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** GDALMajorObject::BuildMetadataDomainList </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bCheckNonEmpty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for custom implementations of <a class="el" href="classGDALMajorObject.html#a83e2cebbfa60a5e3f5cb4aa2e9b80d12" title="Fetch list of metadata domains.">GetMetadataDomainList()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszList</td><td>initial list of domains. May be NULL. Will become invalid after function call (use return value) </td></tr>
    <tr><td class="paramname">bCheckNonEmpty</td><td>if TRUE, each candidate domain will be tested to be non empty </td></tr>
    <tr><td class="paramname">...</td><td>NULL terminated variadic list of candidate domains.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL or a string list. Must be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a822deb3b2d047185e3a454692619291c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822deb3b2d047185e3a454692619291c">&#9670;&nbsp;</a></span>Clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip off areas that are not covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2" title="Clip off areas that are not covered by the method layer.">OGR_L_Clip()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a6cafa399e8f3027158787c87c3d1b97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cafa399e8f3027158787c87c3d1b97e">&#9670;&nbsp;</a></span>CommitTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::CommitTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a6135ef3b16c3cc974682365783603cc6" title="For datasources which support transactions, CommitTransaction commits a transaction.">OGR_L_CommitTransaction()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a92933b3aeef549807394bf578416aad2">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="aaa1e32016f481596a55e1d988a15a067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1e32016f481596a55e1d988a15a067">&#9670;&nbsp;</a></span>CreateFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::CreateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>Starting with GDAL 2.0, drivers should specialize the <a class="el" href="classOGRLayer.html#a474993a66cecaa1443c2e82cc14ae615" title="Create and write a new feature within a layer.">ICreateFeature()</a> method, since <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> is no longer virtual.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a>.</p>
<p>To create a feature, but set it if it exists see <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGRLayer::UpsertFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a>, <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a>, <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="a69ece498332c3054281f17939dceeab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ece498332c3054281f17939dceeab4">&#9670;&nbsp;</a></span>CreateField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::CreateField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRFieldDefn.html">OGRFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275" title="Create a new field on a layer.">OGR_L_CreateField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poField</td><td>field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a6c0dafbcce326f964adf0a9179066a9c">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#aab7c696d435facb07d4e3eb4d09996a0">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a931c8aac9aa389fa58cacdecbf731579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931c8aac9aa389fa58cacdecbf731579">&#9670;&nbsp;</a></span>CreateFieldFromArrowSchema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRLayer::CreateFieldFromArrowSchema </td>
          <td>(</td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a field from an ArrowSchema. </p>
<p>This should only be used for attribute fields. Geometry fields should be created with <a class="el" href="classOGRLayer.html#a87a4b0693ff9490881d213484b0bfe5d" title="Create a new geometry field on a layer.">CreateGeomField()</a>. The FID field should also not be passed with this method.</p>
<p>Contrary to the <a class="el" href="classOGRLayer.html#aad6238309c2ca47804da68096f838740" title="Returns whether the provided ArrowSchema is supported for writing.">IsArrowSchemaSupported()</a> and <a class="el" href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c" title="Writes a batch of rows from an ArrowArray.">WriteArrowBatch()</a> methods, the passed schema must be for an individual field, and thus, is <em>not</em> of type struct (format=+s) (unless writing a set of fields grouped together in the same structure).</p>
<p>Additional field metadata can be speciffed through the ArrowSchema::metadata field with the potential following items: </p><ul>
<li>
"GDAL:OGR:alternative_name": value of <a class="el" href="classOGRFieldDefn.html#ad65cd1946750fb8bc80d9f8414e576bd" title="Fetch the alternative name (or &quot;alias&quot;) for this field.">OGRFieldDefn::GetAlternativeNameRef()</a> </li>
<li>
"GDAL:OGR:comment": value of <a class="el" href="classOGRFieldDefn.html#ab03617cad10b80e943b6419f17a1c489" title="Return the (optional) comment for this field.">OGRFieldDefn::GetComment()</a> </li>
<li>
"GDAL:OGR:default": value of <a class="el" href="classOGRFieldDefn.html#ac4210fa7c6f10ed090a5558224447cfa" title="Get default field value.">OGRFieldDefn::GetDefault()</a> </li>
<li>
"GDAL:OGR:subtype": value of <a class="el" href="classOGRFieldDefn.html#a3c18c491717be99e2e1a3c96cfc2ffd9" title="Fetch subtype of this field.">OGRFieldDefn::GetSubType()</a> </li>
<li>
"GDAL:OGR:width": value of <a class="el" href="classOGRFieldDefn.html#aa8c4090f59d60ca949ba3fd0eada9f36" title="Get the formatting width for this field.">OGRFieldDefn::GetWidth()</a> (serialized as a string) </li>
<li>
"GDAL:OGR:unique": value of <a class="el" href="classOGRFieldDefn.html#a20df702a2e152c946407d7c4796095a4" title="Return whether this field has a unique constraint.">OGRFieldDefn::IsUnique()</a> (serialized as "true" or "false") </li>
<li>
"GDAL:OGR:domain_name": value of <a class="el" href="classOGRFieldDefn.html#ae36192269558570b6627073f82542c9c" title="Return the name of the field domain for this field.">OGRFieldDefn::GetDomainName()</a> </li>
</ul>
<p>This method and <a class="el" href="classOGRLayer.html#a69ece498332c3054281f17939dceeab4" title="Create a new field on a layer.">CreateField()</a> are mutually exclusive in the same session.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aaea1ddbc6c9dacc75986ea77ba1f56fc" title="Creates a field from an ArrowSchema.">OGR_L_CreateFieldFromArrowSchema()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>Schema of the field to create. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options (none currently). Null terminated list, or nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<a id="a87a4b0693ff9490881d213484b0bfe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a4b0693ff9490881d213484b0bfe5d">&#9670;&nbsp;</a></span>CreateGeomField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::CreateGeomField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOGRGeomFieldDefn.html">OGRGeomFieldDefn</a> *&#160;</td>
          <td class="paramname"><em>poField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCCreateGeomField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc" title="Create a new geometry field on a layer.">OGR_L_CreateGeomField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poField</td><td>geometry field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.11 </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a50f4f641ebb4a22134ddd66a59125316">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a889597a2d838e3a83e98dd756d60d461">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a2342e79e0248076c2205047e1928f296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2342e79e0248076c2205047e1928f296">&#9670;&nbsp;</a></span>DeleteFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::DeleteFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability.">TestCapability()</a> layer method may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ae5acdeffac0c7a8ee33ac3a55db18949" title="Delete feature from layer.">OGR_L_DeleteFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nFID</td><td>the feature id to be deleted from the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#ade0d4b235a725ad16faac2e0b659e33b">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="aaebe7c671dca995549543eecf0f7a76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebe7c671dca995549543eecf0f7a76a">&#9670;&nbsp;</a></span>DeleteField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::DeleteField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2" title="Delete an existing field on a layer.">OGR_L_DeleteField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iField</td><td>index of the field to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a7958d03d3b963bce513902e7a94a1dd0">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a2271d53f75d4f6ff2f4a8aeb71e825d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2271d53f75d4f6ff2f4a8aeb71e825d6">&#9670;&nbsp;</a></span>Dereference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::Dereference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement layer reference count. </p>
<p>This method is the same as the C function OGR_L_Dereference().</p>
<dl class="section return"><dt>Returns</dt><dd>the reference count after decrementing. </dd></dl>

</div>
</div>
<a id="a23fa292ae87af3bc0d3abb3963a71914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fa292ae87af3bc0d3abb3963a71914">&#9670;&nbsp;</a></span>Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove areas that are covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer but not in the method layer. The features in the result layer have attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285" title="Remove areas that are covered by the method layer.">OGR_L_Erase()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="aef41bcd7adad1ac5ddcef54d6b38713c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef41bcd7adad1ac5ddcef54d6b38713c">&#9670;&nbsp;</a></span>FindFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::FindFieldIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bExactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the index of field in the layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5" title="Find the index of field in a layer.">OGR_L_FindFieldIndex()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>field index, or -1 if the field doesn't exist </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a3cf969adb8b5e2358846844a58b890fd">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a6114f65f0fa09b55b4324a876623c7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6114f65f0fa09b55b4324a876623c7d3">&#9670;&nbsp;</a></span>FromHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOGRLayer.html">OGRLayer</a>* OGRLayer::FromHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRLayerH to a OGRLayer*. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad3ec416786dda7808b11b772942e2b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ec416786dda7808b11b772942e2b60">&#9670;&nbsp;</a></span>GetArrowSchema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::GetArrowSchema </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>out_schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the ArrowArrayStream::get_schema() callback. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a3ffa8511632cbb7cff06a908e6668f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa8511632cbb7cff06a908e6668f55">&#9670;&nbsp;</a></span>GetArrowStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRLayer::GetArrowStream </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"><em>out_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a Arrow C stream. </p>
<p>On successful return, and when the stream interfaces is no longer needed, it must must be freed with out_stream-&gt;release(out_stream). Please carefully read <a href="https://arrow.apache.org/docs/format/CStreamInterface.html">https://arrow.apache.org/docs/format/CStreamInterface.html</a> for more details on using Arrow C stream.</p>
<p>The method may take into account ignored fields set with <a class="el" href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a" title="Set which fields can be omitted when retrieving features from the layer.">SetIgnoredFields()</a> (the default implementation does), and should take into account filters set with <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">SetSpatialFilter()</a> and <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde" title="Set a new attribute query.">SetAttributeFilter()</a>. Note however that specialized implementations may fallback to the default (slower) implementation when filters are set. Drivers that have a specialized implementation should advertise the OLCFastGetArrowStream capability.</p>
<p>There are extra precautions to take into account in a OGR context. Unless otherwise specified by a particular driver implementation, the get_schema(), get_next() and get_last_error() function pointers of the ArrowArrayStream structure should no longer be used after the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a>, from which the ArrowArrayStream structure was initialized, has been destroyed (typically at dataset closing). The reason is that those function pointers will typically point to methods of the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> instance. However, the ArrowSchema and ArrowArray structures filled from those callbacks can be used and must be released independently from the ArrowArrayStream or the layer.</p>
<p>Furthermore, unless otherwise specified by a particular driver implementation, only one ArrowArrayStream can be active at a time on a given layer (that is the last active one must be explicitly released before a next one is asked). Changing filter state, ignored columns, modifying the schema or using <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a>/GetNextFeature() while using a ArrowArrayStream is strongly discouraged and may lead to unexpected results. As a rule of thumb, no <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> methods that affect the state of a layer should be called on a layer, while an ArrowArrayStream on it is active.</p>
<p>Starting with GDAL 3.8, the ArrowSchema::metadata field filled by the get_schema() callback may be set with the potential following items: </p><ul>
<li>
"GDAL:OGR:alternative_name": value of <a class="el" href="classOGRFieldDefn.html#ad65cd1946750fb8bc80d9f8414e576bd" title="Fetch the alternative name (or &quot;alias&quot;) for this field.">OGRFieldDefn::GetAlternativeNameRef()</a> </li>
<li>
"GDAL:OGR:comment": value of <a class="el" href="classOGRFieldDefn.html#ab03617cad10b80e943b6419f17a1c489" title="Return the (optional) comment for this field.">OGRFieldDefn::GetComment()</a> </li>
<li>
"GDAL:OGR:default": value of <a class="el" href="classOGRFieldDefn.html#ac4210fa7c6f10ed090a5558224447cfa" title="Get default field value.">OGRFieldDefn::GetDefault()</a> </li>
<li>
"GDAL:OGR:subtype": value of <a class="el" href="classOGRFieldDefn.html#a3c18c491717be99e2e1a3c96cfc2ffd9" title="Fetch subtype of this field.">OGRFieldDefn::GetSubType()</a> </li>
<li>
"GDAL:OGR:width": value of <a class="el" href="classOGRFieldDefn.html#aa8c4090f59d60ca949ba3fd0eada9f36" title="Get the formatting width for this field.">OGRFieldDefn::GetWidth()</a> (serialized as a string) </li>
<li>
"GDAL:OGR:unique": value of <a class="el" href="classOGRFieldDefn.html#a20df702a2e152c946407d7c4796095a4" title="Return whether this field has a unique constraint.">OGRFieldDefn::IsUnique()</a> (serialized as "true" or "false") </li>
<li>
"GDAL:OGR:domain_name": value of <a class="el" href="classOGRFieldDefn.html#ae36192269558570b6627073f82542c9c" title="Return the name of the field domain for this field.">OGRFieldDefn::GetDomainName()</a> </li>
</ul>
<p>A potential usage can be: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ArrowArrayStream stream;</div>
<div class="line"><span class="keywordflow">if</span>( !poLayer-&gt;GetArrowStream(&amp;stream, <span class="keyword">nullptr</span>))</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d">CPLError</a>(CE_Failure, <a class="code" href="cpl__error_8h.html#a7151d0699caa1372a8566562390ff113">CPLE_AppDefined</a>, <span class="stringliteral">&quot;GetArrowStream() failed\n&quot;</span>);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>ArrowSchema schema;</div>
<div class="line"><span class="keywordflow">if</span>( stream.get_schema(&amp;stream, &amp;schema) == 0 )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Do something useful</span></div>
<div class="line">    schema.release(schema);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">while</span>( <span class="keyword">true</span> )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>ArrowArray array;</div>
<div class="line">    <span class="comment">// Look for an error (get_next() returning a non-zero code), or</span></div>
<div class="line">    <span class="comment">// end of iteration (array.release == nullptr)</span></div>
<div class="line">    <span class="keywordflow">if</span>( stream.get_next(&amp;stream, &amp;array) != 0 ||</div>
<div class="line">        array.release == <span class="keyword">nullptr</span> )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Do something useful</span></div>
<div class="line">    array.release(&amp;array);</div>
<div class="line">}</div>
<div class="line">stream.release(&amp;stream);</div>
<div class="ttc" id="acpl__error_8h_html_a7151d0699caa1372a8566562390ff113"><div class="ttname"><a href="cpl__error_8h.html#a7151d0699caa1372a8566562390ff113">CPLE_AppDefined</a></div><div class="ttdeci">#define CPLE_AppDefined</div><div class="ttdoc">Application defined error.</div><div class="ttdef"><b>Definition:</b> cpl_error.h:100</div></div>
<div class="ttc" id="acpl__error_8h_html_afda4d86428c1c533449ae6a69cdf430d"><div class="ttname"><a href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d">CPLError</a></div><div class="ttdeci">void CPLError(CPLErr eErrClass, CPLErrorNum err_no, const char *fmt,...)</div><div class="ttdoc">Report an error.</div><div class="ttdef"><b>Definition:</b> cpl_error.cpp:330</div></div>
</div><!-- fragment --><p>A full example is available in the <a href="https://gdal.org/tutorials/vector_api_tut.html#reading-from-ogr-using-the-arrow-c-stream-data-interface">Reading From OGR using the Arrow C Stream data interface</a> tutorial.</p>
<p>Options may be driver specific. The default implementation recognizes the following options: </p><ul>
<li>
INCLUDE_FID=YES/NO. Whether to include the FID column. Defaults to YES.  </li>
<li>
MAX_FEATURES_IN_BATCH=integer. Maximum number of features to retrieve in a ArrowArray batch. Defaults to 65 536. </li>
<li>
TIMEZONE="unknown", "UTC", "(+|:)HH:MM" or any other value supported by Arrow. (GDAL &gt;= 3.8) Override the timezone flag nominally provided by <a class="el" href="classOGRFieldDefn.html#ab3cf869f6b571e011e28fa52b4a83947" title="Get the time zone flag.">OGRFieldDefn::GetTZFlag()</a>, and used for the Arrow field timezone declaration, with a user specified timezone. Note that datetime values in Arrow arrays are always stored in UTC, and that the time zone flag used by GDAL to convert to UTC is the one of the OGRField::Date::TZFlag member at the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> level. The conversion to UTC of a OGRField::Date is only done if both the timezone indicated by OGRField::Date::TZFlag and the one at the <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> level (or set by this TIMEZONE option) are not unknown. </li>
<li>
GEOMETRY_METADATA_ENCODING=OGC/GEOARROW (GDAL &gt;= 3.8). The default is OGC, which will lead to setting the Arrow geometry column metadata to ARROW:extension:name=ogc.wkb. If setting to GEOMETRY_METADATA_ENCODING to GEOARROW, ARROW:extension:name=geoarrow.wkb and ARROW:extension:metadata={"crs": &lt;projjson CRS representation&gt;&gt; are set.  </li>
</ul>
<p>The Arrow/Parquet drivers recognize the following option: </p><ul>
<li>
GEOMETRY_ENCODING=WKB. To force a fallback to the generic implementation when the native geometry encoding is not WKB. Otherwise the geometry will be returned with its native Arrow encoding (possibly using GeoArrow encoding). </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_stream</td><td>Output stream. Must <em>not</em> be NULL. The content of the structure does not need to be initialized. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of key=value options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a527ea789c139b6894258e1788eb01e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ea789c139b6894258e1788eb01e7e">&#9670;&nbsp;</a></span>GetDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDALDataset.html">GDALDataset</a> * OGRLayer::GetDataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the dataset associated with this layer. </p>
<p>As of GDAL 3.9, <a class="el" href="classOGRLayer.html#a527ea789c139b6894258e1788eb01e7e" title="Return the dataset associated with this layer.">GetDataset()</a> is implemented on all in-tree drivers that have CreateLayer() capability. It may not be implemented in read-only drivers or out-of-tree drivers.</p>
<p>It is currently only used by the GetRecordBatchSchema() method to retrieve the field domain associated with a field, to fill the dictionary field of a struct ArrowSchema. It is also used by <a class="el" href="classOGRLayer.html#a931c8aac9aa389fa58cacdecbf731579" title="Creates a field from an ArrowSchema.">CreateFieldFromArrowSchema()</a> to determine which field types and subtypes are supported by the layer, by inspecting the driver metadata, and potentially use fallback types when needed.</p>
<p>This method is the same as the C function <a class="el" href="gdal_8h.html#a70546bb86026565c64be23eb58edc982" title="Return the dataset associated with this layer.">OGR_L_GetDataset()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>dataset, or nullptr when unknown. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="af769554a8632dda9f99db325664a37cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af769554a8632dda9f99db325664a37cf">&#9670;&nbsp;</a></span>GetDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * GDALMajorObject::GetDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch object description. </p>
<p>The semantics of the returned description are specific to the derived type. For GDALDatasets it is the dataset name. For GDALRasterBands it is actually a description (if supported) or "".</p>
<p>This method is the same as the C function <a class="el" href="gdal_8h.html#acf7272f513f436a95572116ca9fb8885" title="Fetch object description.">GDALGetDescription()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>non-null pointer to internal description string. </dd></dl>

</div>
</div>
<a id="a47a3cc550866eee1668bea2315f9df9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a3cc550866eee1668bea2315f9df9c">&#9670;&nbsp;</a></span>GetExtent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>Note to driver implementer: if you implement <a class="el" href="classOGRLayer.html#a47a3cc550866eee1668bea2315f9df9c" title="Fetch the extent of this layer, on the specified geometry field.">GetExtent(int,OGREnvelope*,int)</a>, you must also implement <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent(OGREnvelope*, int)</a> to make it call GetExtent(0,OGREnvelope*,int).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376" title="Fetch the extent of this layer, on the specified geometry field.">OGR_L_GetExtentEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#aa35416294aac0b338d5a2d881ff1fdee">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a3be658ddb5b33d1ed95c31286774bbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be658ddb5b33d1ed95c31286774bbd2">&#9670;&nbsp;</a></span>GetExtent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::GetExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a246b6f98cb4e51ea10514945ec505369">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="ad3c96b5540aaf8d5c2769430ed0e8be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c96b5540aaf8d5c2769430ed0e8be9">&#9670;&nbsp;</a></span>GetExtent3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::GetExtent3D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&#160;</td>
          <td class="paramname"><em>psExtent3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the 3D extent of this layer, on the specified geometry field. </p>
<p>Returns the 3D extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>(Contrarty to <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a> 2D), the returned extent will always take into account the attribute and spatial filters that may be installed.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>For layers that have no 3D geometries, the psExtent3D-&gt;MinZ and psExtent3D-&gt;MaxZ fields will be respectively set to +Infinity and -Infinity.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#aeed5833946cd34e49517eaedad17874d" title="Fetch the 3D extent of this layer, on the specified geometry field.">OGR_L_GetExtent3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>0-based index of the geometry field to consider. </td></tr>
    <tr><td class="paramname">psExtent3D</td><td>the computed 3D extent of the layer. </td></tr>
    <tr><td class="paramname">bForce</td><td>if TRUE, the extent will be computed even if all the layer features have to be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ace902dfb44335fb1a877aa035ecff209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace902dfb44335fb1a877aa035ecff209">&#9670;&nbsp;</a></span>GetFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * OGRLayer::GetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this method returns a non-NULL feature, it is guaranteed that its feature id (<a class="el" href="classOGRFeature.html#ae7254201e4d96e8429c2509194740d58" title="Get feature identifier.">OGRFeature::GetFID()</a>) will be the same as nFID.</p>
<p>Use OGRLayer::TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">GetFeature()</a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a>) are generally considered interrupted by a <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">GetFeature()</a> call.</p>
<p>The returned feature should be free with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a29d378c5092db944966398de8d1ac964" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nFID</td><td>the feature id of the feature to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a feature now owned by the caller, or NULL on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#ab321145e72ce0529719a8100d677efb0">OGRGNMWrappedResultLayer</a>.</p>

</div>
</div>
<a id="a2d0e1a43fd1a0a6d55d766384da7b6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0e1a43fd1a0a6d55d766384da7b6a5">&#9670;&nbsp;</a></span>GetFeatureCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGRLayer::GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em> = <code>TRUE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2" title="Fetch the feature count in this layer.">OGR_L_GetFeatureCount()</a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>feature count, -1 if count not known. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#acba3d4400f7b1c45a4ea3fe70019a196">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a3f73cdc43100a0443da3e5549a152490">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="af0cb9a05310d7b17d9dfec9e83a18e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cb9a05310d7b17d9dfec9e83a18e61">&#9670;&nbsp;</a></span>GetFIDColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetFIDColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the FID column, or "" if not supported. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5" title="This method returns the name of the underlying database column being used as the FID column,...">OGR_L_GetFIDColumn()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>fid column name. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a8b6ed9ccfbb3ca2e74cf1e53e539c71e">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a1153cc46ed17cb4ac1398d6ac6b0cc5d">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="af68036c23622c954ce3a91861f22b724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68036c23622c954ce3a91861f22b724">&#9670;&nbsp;</a></span>GetGeometryColumn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetGeometryColumn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the geometry column, or "" if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the name of the first geometry column. For other columns, use <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetNameRef().</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f" title="This method returns the name of the underlying database column being used as the geometry column,...">OGR_L_GetGeometryColumn()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>geometry column name. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#ae1481f5db82eff33e5c2125ff050b065">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#aab97b4895cc5831b0e927d70e8f44961">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a770e610904df8c3ebac47419e86ece69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770e610904df8c3ebac47419e86ece69">&#9670;&nbsp;</a></span>GetGeometryTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOGRGeometryTypeCounter.html">OGRGeometryTypeCounter</a> * OGRLayer::GetGeometryTypes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlagsGGT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nEntryCountOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get actual geometry types found in features. </p>
<p>This method iterates over features to retrieve their geometry types. This is mostly useful for layers that report a wkbUnknown geometry type with <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">GetGeomType()</a> or GetGeomFieldDefn(iGeomField)-&gt;GetType().</p>
<p>By default this method returns an array of nEntryCount entries with each geometry type (in <a class="el" href="structOGRGeometryTypeCounter.html#a7594541e979a98c83a72d80e10bfeeb5" title="Geometry type.">OGRGeometryTypeCounter::eGeomType</a>) and the corresponding number of features (in <a class="el" href="structOGRGeometryTypeCounter.html#a1bc2bc19fda12169023d9b91ecf6a2f2" title="Number of geometries of type eGeomType.">OGRGeometryTypeCounter::nCount</a>). Features without geometries are reported as eGeomType == wkbNone.</p>
<p>The nFlagsGGT parameter can be a combination (with binary or operator) of the following hints: </p><ul>
<li>
OGR_GGT_COUNT_NOT_NEEDED: to indicate that only the set of geometry types matter, not the number of features per geometry type. Consequently the value of <a class="el" href="structOGRGeometryTypeCounter.html#a1bc2bc19fda12169023d9b91ecf6a2f2" title="Number of geometries of type eGeomType.">OGRGeometryTypeCounter::nCount</a> should be ignored. </li>
<li>
OGR_GGT_STOP_IF_MIXED: to indicate that the implementation may stop iterating over features as soon as 2 different geometry types (not counting null geometries) are found. The value of <a class="el" href="structOGRGeometryTypeCounter.html#a1bc2bc19fda12169023d9b91ecf6a2f2" title="Number of geometries of type eGeomType.">OGRGeometryTypeCounter::nCount</a> should be ignored (zero might be systematically reported by some implementations). </li>
<li>
OGR_GGT_GEOMCOLLECTIONZ_TINZ: to indicate that if a geometry is of type wkbGeometryCollection25D and its first sub-geometry is of type wkbTINZ, wkbTINZ should be reported as geometry type. This is mostly useful for the ESRI Shapefile and (Open)FileGDB drivers regarding MultiPatch geometries. </li>
</ul>
<p>If the layer has no features, a non-NULL returned array with nEntryCount == 0 will be returned.</p>
<p>Spatial and/or attribute filters will be taken into account.</p>
<p>This method will error out on a layer without geometry fields (<a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">GetGeomType()</a> == wkbNone).</p>
<p>A cancellation callback may be provided. The progress percentage it is called with is not relevant. The callback should return TRUE if processing should go on, or FALSE if it should be interrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iGeomField</td><td>Geometry field index. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nFlagsGGT</td><td>Hint flags. 0, or combination of OGR_GGT_COUNT_NOT_NEEDED, OGR_GGT_STOP_IF_MIXED, OGR_GGT_GEOMCOLLECTIONZ_TINZ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nEntryCountOut</td><td>Number of entries in the returned array. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pfnProgress</td><td>Cancellation callback. May be NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pProgressData</td><td>User data for the cancellation callback. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of nEntryCount that must be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>, or NULL in case of error </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a818a25520ce08d5a681443348e930604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818a25520ce08d5a681443348e930604">&#9670;&nbsp;</a></span>GetGeomType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGRLayer::GetGeomType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the layer geometry type. </p>
<p>This returns the same result as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#acc3e3904d856b9c8b5b26204c68e916a" title="Fetch the geometry base type.">OGRFeatureDefn::GetGeomType()</a>, but for a few drivers, calling <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">GetGeomType()</a> directly can avoid lengthy layer definition initialization.</p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(i)-&gt;GetType(). For layers without any geometry field, this method returns wkbNone.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type.">OGR_L_GetGeomType()</a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#acc3e3904d856b9c8b5b26204c68e916a" title="Fetch the geometry base type.">OGRFeatureDefn::GetGeomType()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the geometry type </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a831c4f8baebf8167196106cb8de71e26">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="adb51b032a0de17336aaecf74571e80e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb51b032a0de17336aaecf74571e80e0">&#9670;&nbsp;</a></span>GetLastErrorArrowArrayStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetLastErrorArrowArrayStream </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the ArrowArrayStream::get_last_error() callback. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a80473bcfd11341e70dd35bebe94026cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80473bcfd11341e70dd35bebe94026cf">&#9670;&nbsp;</a></span>GetLayerDefn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeatureDefn.html">OGRFeatureDefn</a> * OGRLayer::GetLayerDefn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d" title="Fetch the schema information for this layer.">OGR_L_GetLayerDefn()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>feature definition. </dd></dl>

<p>Implemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a2b03e32b64d5dc5c8be95c815bc59c6a">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a1a51b83925df6eee668a3417ac9105c8">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a8ce3bf5795bbebfe9bc643e2152bb360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce3bf5795bbebfe9bc643e2152bb360">&#9670;&nbsp;</a></span>GetMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** GDALMajorObject::GetMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch metadata. </p>
<p>The returned string list is owned by the object, and may change at any time. It is formatted as a "Name=value" list with the last pointer value being NULL. Use the CPL StringList functions such as <a class="el" href="cpl__string_8h.html#a94ca3f1c515330277c31b06d2a061ccd" title="In a StringList of &quot;Name=Value&quot; pairs, look for the first value associated with the specified name.">CSLFetchNameValue()</a> to manipulate it.</p>
<p>Note that relatively few formats return any metadata at this time.</p>
<p>This method does the same thing as the C function <a class="el" href="gdal_8h.html#a25929a66e99d92c2788485ecf13e2e82" title="Fetch metadata.">GDALGetMetadata()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDomain</td><td>the domain of interest. Use "" or NULL for the default domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL or a string list. </dd></dl>

<p>Reimplemented in <a class="el" href="classGDALDataset.html#ac7e1eb677dcaf096d8f09034f47e1496">GDALDataset</a>, <a class="el" href="classGDALPamDataset.html#af96611a18cbb30f1568d1fa8d12125f2">GDALPamDataset</a>, and <a class="el" href="classGDALPluginDriverProxy.html#a29d3ea8d73361b5c90083fe16ca4a273">GDALPluginDriverProxy</a>.</p>

</div>
</div>
<a id="a83e2cebbfa60a5e3f5cb4aa2e9b80d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e2cebbfa60a5e3f5cb4aa2e9b80d12">&#9670;&nbsp;</a></span>GetMetadataDomainList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char ** GDALMajorObject::GetMetadataDomainList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch list of metadata domains. </p>
<p>The returned string list is the list of (non-empty) metadata domains.</p>
<p>This method does the same thing as the C function <a class="el" href="gdal_8h.html#a61cb7f834334fca47e72e9b096639f98" title="Fetch list of metadata domains.">GDALGetMetadataDomainList()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>NULL or a string list. Must be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented in <a class="el" href="classGDALDataset.html#a04aab087a4963089cca739a6920beac9">GDALDataset</a>.</p>

</div>
</div>
<a id="ad17f496c8b6d0c0be6f52437d3ba8a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17f496c8b6d0c0be6f52437d3ba8a6d">&#9670;&nbsp;</a></span>GetMetadataItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * GDALMajorObject::GetMetadataItem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch single metadata item. </p>
<p>The C function <a class="el" href="gdal_8h.html#ac24dd49918d985568fa2d97da1080215" title="Fetch single metadata item.">GDALGetMetadataItem()</a> does the same thing as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the key for the metadata item to fetch. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>the domain to fetch for, use NULL for the default domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure to find the key, or a pointer to an internal copy of the value string on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classGDALPluginDriverProxy.html#a02307e83ff9b9c09f58f6ed4ec82eba1">GDALPluginDriverProxy</a>, <a class="el" href="classGDALRasterBand.html#aca9ff0114b8d1b25d5243ef060e0e5de">GDALRasterBand</a>, and <a class="el" href="classGDALPamDataset.html#a81d9fe56161240bc8ab33ddc5e70fd12">GDALPamDataset</a>.</p>

</div>
</div>
<a id="aafb345b2a42f86842b520e09069526f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb345b2a42f86842b520e09069526f0">&#9670;&nbsp;</a></span>GetMOFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GDALMajorObject::GetMOFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GMO_ flags. </p>
<dl class="section return"><dt>Returns</dt><dd>flags </dd></dl>

</div>
</div>
<a id="a287f5ec7728cacc2f7d94882a9f1a22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287f5ec7728cacc2f7d94882a9f1a22e">&#9670;&nbsp;</a></span>GetName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGRLayer::GetName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the layer name. </p>
<p>This returns the same content as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#ab8fa2428efb085a0b5dd78342b535aeb" title="Get name of this OGRFeatureDefn.">OGRFeatureDefn::GetName()</a>, but for a few drivers, calling <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">GetName()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c" title="Return the layer name.">OGR_L_GetName()</a>.</p>
<p>If this method is derived in a driver, it must be done such that it returns the same content as <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#ab8fa2428efb085a0b5dd78342b535aeb" title="Get name of this OGRFeatureDefn.">OGRFeatureDefn::GetName()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the layer name (must not been freed) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a14fea999cd24d7eb5b11657c82d78b8d">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a66920f61837a2944468c8c9a434e5bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66920f61837a2944468c8c9a434e5bf6">&#9670;&nbsp;</a></span>GetNextArrowArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::GetNextArrowArray </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>out_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the ArrowArrayStream::get_next() callback. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a47d21ff33b32d14fa4e9885b9edecad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d21ff33b32d14fa4e9885b9edecad6">&#9670;&nbsp;</a></span>GetNextFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRFeature.html">OGRFeature</a> * OGRLayer::GetNextFeature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">SetSpatialFilter()</a>) will be returned.</p>
<p>This method implements sequential access to the features of a layer. The <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> method can be used to start at the beginning again.</p>
<p>Starting with GDAL 3.6, it is possible to retrieve them by batches, with a column-oriented memory layout, using the <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> method.</p>
<p>Features returned by <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> on layers where <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> might be needed.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a feature, or NULL if no more features are available. </dd></dl>

<p>Implemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a702689eaf04e4d3379a301bd582eb82d">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a9103cc8308203034828993fc1e0b23db">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="adf3cea24856572302ae11ed97ca33375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3cea24856572302ae11ed97ca33375">&#9670;&nbsp;</a></span>GetRefCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::GetRefCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch reference count. </p>
<p>This method is the same as the C function OGR_L_GetRefCount().</p>
<dl class="section return"><dt>Returns</dt><dd>the current reference count for the layer object itself. </dd></dl>

</div>
</div>
<a id="adc3735e444204d46f517eec251712f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3735e444204d46f517eec251712f4d">&#9670;&nbsp;</a></span>GetSpatialFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> * OGRLayer::GetSpatialFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a" title="This function returns the current spatial filter for this layer.">OGR_L_GetSpatialFilter()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>spatial filter geometry. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#aae3e82b584b59d94ec34e2c4ab8beced">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a75c06b4993f8eb76b569f37365cd19ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c06b4993f8eb76b569f37365cd19ab">&#9670;&nbsp;</a></span>GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> * OGRLayer::GetSpatialRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>Starting with OGR 1.11, several geometry fields can be associated to a feature definition. Each geometry field can have its own spatial reference system, which is returned by <a class="el" href="classOGRGeomFieldDefn.html#acdc7b11a77a8e3f838a2b33965e2971f" title="Fetch spatial reference system of this field.">OGRGeomFieldDefn::GetSpatialRef()</a>. <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a> is equivalent to <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(0)-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a></p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer.">OGR_L_GetSpatialRef()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#ad2c9ddba61367ddc95a28942378d101f">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a6da7edd25c416684f858cb4a81ab92b2">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="ac65f762d5b3c6fc4ca0f0cc4aafcdcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65f762d5b3c6fc4ca0f0cc4aafcdcbe">&#9670;&nbsp;</a></span>GetStyleTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> * OGRLayer::GetStyleTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns layer style table. </p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#aceae9ba8158efda9d1bd016022c627ca" title="Get style table.">OGR_L_GetStyleTable()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to a style table which should not be modified or freed by the caller. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a5d4c6c2d6fd1330851749eb87fc9143a">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a2c576ac25d6001967f55e8bae6b8ec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c576ac25d6001967f55e8bae6b8ec53">&#9670;&nbsp;</a></span>GetSupportedSRSList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOGRLayer.html#a6ffe33197f239fc68161f2e01daecff2">OGRLayer::GetSupportedSRSListRetType</a> &amp; OGRLayer::GetSupportedSRSList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of SRS supported. </p>
<p>The base implementation of this method will return an empty list. Some drivers (OAPIF, WFS) may return a non-empty list.</p>
<p>One of the SRS returned may be passed to <a class="el" href="classOGRLayer.html#a1c677104b157df424dbb7cba88757342" title="Change the active SRS.">SetActiveSRS()</a> to change the active SRS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>Geometry field index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of supported SRS. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a474993a66cecaa1443c2e82cc14ae615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474993a66cecaa1443c2e82cc14ae615">&#9670;&nbsp;</a></span>ICreateFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::ICreateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>This method is implemented by drivers and not called directly. User code should use <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> instead.</p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a17144c16c9b1d4d4bd82dbfc111dc363">OGRGNMWrappedResultLayer</a>.</p>

</div>
</div>
<a id="a385ff64cc8b070819da0a7e121ff07b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ff64cc8b070819da0a7e121ff07b3">&#9670;&nbsp;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the features of this layer with the ones from the identity layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer.  </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is YES, to add features with lower dimension geometry, but only if the result layer has an unknown geometry type.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9" title="Identify the features of this layer with the ones from the identity layer.">OGR_L_Identity()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a5202606175f7e7dcd76c3eb237ac8303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5202606175f7e7dcd76c3eb237ac8303">&#9670;&nbsp;</a></span>Intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersection of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are common between features in the input layer and in the method layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is: </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer.  </li>
<li>
PRETEST_CONTAINMENT=YES/NO. Set to YES to pretest the containment of features of method layer within the features of this layer. This will speed up the method significantly in some cases. Requires that the prepared geometries are in effect.  </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is YES, to add features with lower dimension geometry, but only if the result layer has an unknown geometry type.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524" title="Intersection of two layers.">OGR_L_Intersection()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="aad6238309c2ca47804da68096f838740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6238309c2ca47804da68096f838740">&#9670;&nbsp;</a></span>IsArrowSchemaSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRLayer::IsArrowSchemaSupported </td>
          <td>(</td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>osErrorMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the provided ArrowSchema is supported for writing. </p>
<p>This method exists since not all drivers may support all Arrow data types.</p>
<p>The ArrowSchema must be of type struct (format=+s)</p>
<p>It is recommended to call this method before calling <a class="el" href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c" title="Writes a batch of rows from an ArrowArray.">WriteArrowBatch()</a>.</p>
<p>This is the same as the C function <a class="el" href="ogr__api_8h.html#abe072d5f6595a0cddd1cddbeb38416fb" title="Returns whether the provided ArrowSchema is supported for writing.">OGR_L_IsArrowSchemaSupported()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">schema</td><td>Schema of type struct (format = '+s') </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">papszOptions</td><td>Options (none currently). Null terminated list, or nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">osErrorMsg</td><td>Reason of the failure, when this method returns false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ArrowSchema is supported for writing. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<a id="a604ff4dcb92b2ef184c106765c1ed600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604ff4dcb92b2ef184c106765c1ed600">&#9670;&nbsp;</a></span>ISetFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::ISetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite/replace an existing feature. </p>
<p>This method is implemented by drivers and not called directly. User code should use <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a> instead.</p>
<p>This method will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a1ee20a5cab1d1a35e5a3a19a5f8e15f3">OGRGNMWrappedResultLayer</a>.</p>

</div>
</div>
<a id="a3df7531259b276477a74c7f265a2fc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df7531259b276477a74c7f265a2fc62">&#9670;&nbsp;</a></span>IUpdateFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::IUpdateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUpdatedFieldsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panUpdatedFieldsIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUpdatedGeomFieldsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panUpdatedGeomFieldsIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUpdateStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update (part of) an existing feature. </p>
<p>This method is implemented by drivers and not called directly. User code should use <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to update.</td></tr>
    <tr><td class="paramname">nUpdatedFieldsCount</td><td>number of attribute fields to update. May be 0</td></tr>
    <tr><td class="paramname">panUpdatedFieldsIdx</td><td>array of nUpdatedFieldsCount values, each between 0 and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetFieldCount() - 1, indicating which fields of poFeature must be updated in the layer.</td></tr>
    <tr><td class="paramname">nUpdatedGeomFieldsCount</td><td>number of geometry fields to update. May be 0</td></tr>
    <tr><td class="paramname">panUpdatedGeomFieldsIdx</td><td>array of nUpdatedGeomFieldsCount values, each between 0 and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldCount() - 1, indicating which geometry fields of poFeature must be updated in the layer.</td></tr>
    <tr><td class="paramname">bUpdateStyleString</td><td>whether the feature style string in the layer should be updated with the one of poFeature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a> </dd></dl>

</div>
</div>
<a id="a3ebc7613af3d5324c7cb01e848d27c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc7613af3d5324c7cb01e848d27c09">&#9670;&nbsp;</a></span>IUpsertFeature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::IUpsertFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite/replace an existing feature or create a new feature within a layer. </p>
<p>This method is implemented by drivers and not called directly. User code should use <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">UpsertFeature()</a> instead.</p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>. If the feature id doesn't exist a new feature will be written. Otherwise, the existing feature will be rewritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="ab22d1c941fa9de205d3ea74e765d3978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22d1c941fa9de205d3ea74e765d3978">&#9670;&nbsp;</a></span>PostFilterArrowArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::PostFilterArrowArray </td>
          <td>(</td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove rows that aren't selected by the spatial or attribute filter. </p>
<p>Assumes that <a class="el" href="classOGRLayer.html#afb80dab3954bfa409520f132dd11e479" title="Whether the PostFilterArrowArray() can work on the schema to remove rows that aren&#39;t selected by the ...">CanPostFilterArrowArray()</a> has been called and returned true. </p>

</div>
</div>
<a id="ae783de2e9ee2629e6bf27fd3b8622fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae783de2e9ee2629e6bf27fd3b8622fb5">&#9670;&nbsp;</a></span>Reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::Reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment layer reference count. </p>
<p>This method is the same as the C function OGR_L_Reference().</p>
<dl class="section return"><dt>Returns</dt><dd>the reference count after incrementing. </dd></dl>

</div>
</div>
<a id="a7ab18ef0293fd0938a0a1ffd5ecd4a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab18ef0293fd0938a0a1ffd5ecd4a4d">&#9670;&nbsp;</a></span>ReleaseArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::ReleaseArray </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a ArrowArray. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Arrow array to release. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="ad0fa8ac39a35e5511bea40cf3acad354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fa8ac39a35e5511bea40cf3acad354">&#9670;&nbsp;</a></span>ReleaseSchema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::ReleaseSchema </td>
          <td>(</td>
          <td class="paramtype">struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a ArrowSchema. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>Schema to release. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a6637ccd2cf24eb39c50b9cadcafdf52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6637ccd2cf24eb39c50b9cadcafdf52e">&#9670;&nbsp;</a></span>ReleaseStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::ReleaseStream </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a ArrowArrayStream. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Arrow array stream to release. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="adcb9669950015866ae2460d9b26755df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb9669950015866ae2460d9b26755df">&#9670;&nbsp;</a></span>Rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename layer. </p>
<p>This operation is implemented only by layers that expose the OLCRename capability, and drivers that expose the GDAL_DCAP_RENAME_LAYERS capability</p>
<p>This operation will fail if a layer with the new name already exists.</p>
<p>On success, <a class="el" href="classGDALMajorObject.html#af769554a8632dda9f99db325664a37cf" title="Fetch object description.">GetDescription()</a> and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">GetName()</a> will return pszNewName.</p>
<p>Renaming the layer may interrupt current feature iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszNewName</td><td>New layer name. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="ab4c02b991bfa78552eeb0cbcdcf1aed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c02b991bfa78552eeb0cbcdcf1aed8">&#9670;&nbsp;</a></span>ReorderField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::ReorderField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iOldFieldPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNewFieldPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder an existing field on a layer. </p>
<p>This method is a convenience wrapper of <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">ReorderFields()</a> dedicated to move a single field. It is a non-virtual method, so drivers should implement <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">ReorderFields()</a> instead.</p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>The field definition that was at initial position iOldFieldPos will be moved at position iNewFieldPos, and elements between will be shuffled accordingly.</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderField(1, 3) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927" title="Reorder an existing field on a layer.">OGR_L_ReorderField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iOldFieldPos</td><td>previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. </td></tr>
    <tr><td class="paramname">iNewFieldPos</td><td>new position of the field to move. Must be in the range [0,GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="aebd364a150d91f8d65d967646e0f92d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd364a150d91f8d65d967646e0f92d3">&#9670;&nbsp;</a></span>ReorderFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::ReorderFields </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This method should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderFields([0,2,3,1,4]) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this method. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer.">OGR_L_ReorderFields()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">panMap</td><td>an array of <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature.">OGRFeatureDefn::GetFieldCount()</a> elements which is a permutation of [0, <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature.">OGRFeatureDefn::GetFieldCount()</a>-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a171a2be1c00ce80a9ba93139fd5149ed">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="aad0f2cd7f0587584b8f382c6a913583c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0f2cd7f0587584b8f382c6a913583c">&#9670;&nbsp;</a></span>ResetReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::ResetReading </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset feature reading to start on the first feature. </p>
<p>This affects <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> and <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a>.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a>. </p>

<p>Implemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#af7dde6c09cc4e2c51643433490f75958">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a479d90adb91ed34e34417e98caf787c2">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="ab046dbffc4fbd5bacc6ef75da0686d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab046dbffc4fbd5bacc6ef75da0686d82">&#9670;&nbsp;</a></span>RollbackTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::RollbackTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. </p>
<p>If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5" title="For datasources which support transactions, RollbackTransaction will roll back a datasource to its st...">OGR_L_RollbackTransaction()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a50dfbdab339aa69aca5aea6d454567e8">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a1c677104b157df424dbb7cba88757342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c677104b157df424dbb7cba88757342">&#9670;&nbsp;</a></span>SetActiveSRS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SetActiveSRS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOGRSpatialReference.html">OGRSpatialReference</a> *&#160;</td>
          <td class="paramname"><em>poSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the active SRS. </p>
<p>The passed SRS must be in the list returned by <a class="el" href="classOGRLayer.html#a2c576ac25d6001967f55e8bae6b8ec53" title="Get the list of SRS supported.">GetSupportedSRSList()</a> (the actual pointer may be different, but should be tested as identical with <a class="el" href="classOGRSpatialReference.html#afd86486cb2e7291c6d1647986a4bd318" title="Do these two spatial references describe the same system ?">OGRSpatialReference::IsSame()</a>).</p>
<p>Changing the active SRS affects: </p><ul>
<li>
the SRS in which geometries of returned features are expressed, </li>
<li>
the SRS in which geometries of passed features (<a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a>, <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a>) are expressed, </li>
<li>
the SRS returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a> and GetGeomFieldDefn()-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>, </li>
<li>
the SRS used to interpret <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">SetSpatialFilter()</a> values. </li>
</ul>
<p>This also resets feature reading and the spatial filter. Note however that this does not modify the storage SRS of the features of geometries. Said otherwise, this setting is volatile and has no persistent effects after dataset reopening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>Geometry field index. </td></tr>
    <tr><td class="paramname">poSRS</td><td>SRS to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success, or OGRERR_FAILURE if the passed SRS is not in <a class="el" href="classOGRLayer.html#a2c576ac25d6001967f55e8bae6b8ec53" title="Get the list of SRS supported.">GetSupportedSRSList()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="acb2c6cc5fa3577df5be538284c1b0dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2c6cc5fa3577df5be538284c1b0dde">&#9670;&nbsp;</a></span>SetAttributeFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SetAttributeFilter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszQuery</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new attribute query. </p>
<p>This method sets the attribute query string to be used when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance "population &gt; 1000000 and population &lt; 5000000" where population is an attribute in the layer. The query format is normally a SQL WHERE clause as described in the <a href="https://gdal.org/user/ogr_sql_dialect.html#where">"WHERE"</a> section of the OGR SQL dialect documentation. In some cases (RDBMS backed drivers, SQLite, GeoPackage) the native capabilities of the database may be used to to interpret the WHERE clause, in which case the capabilities will be broader than those of OGR SQL.</p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a>).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09" title="Set a new attribute query.">OGR_L_SetAttributeFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszQuery</td><td>query in restricted SQL WHERE format, or NULL to clear the current query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#aa900b33c9e5272514739266f70f57383">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="af334bc8d152f130a55783ea36938735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af334bc8d152f130a55783ea36938735b">&#9670;&nbsp;</a></span>SetDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GDALMajorObject::SetDescription </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewDesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set object description. </p>
<p>The semantics of the description are specific to the derived type. For GDALDatasets it is the dataset name. For GDALRasterBands it is actually a description (if supported) or "".</p>
<p>Normally application code should not set the "description" for GDALDatasets. It is handled internally.</p>
<p>This method is the same as the C function <a class="el" href="gdal_8h.html#a19c2fc1f303eec4df98fc2d9c5acd9cb" title="Set object description.">GDALSetDescription()</a>. </p>

<p>Reimplemented in <a class="el" href="classGDALPamRasterBand.html#ab86dcd179dc2cfdb6012eead4f0023a4">GDALPamRasterBand</a>.</p>

</div>
</div>
<a id="a681139bfd585b74d7218e51a32144283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681139bfd585b74d7218e51a32144283">&#9670;&nbsp;</a></span>SetFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite/replace an existing feature. </p>
<p>This method will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>.</p>
<p>Use OGRLayer::TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a>.</p>
<p>The way unset fields in the provided poFeature are processed is driver dependent: </p><ul>
<li>
SQL based drivers which implement <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a> through SQL UPDATE will skip unset fields, and thus the content of the existing feature will be preserved.  </li>
<li>
The shapefile driver will write a NULL value in the DBF file.  </li>
<li>
The GeoJSON driver will take into account unset fields to remove the corresponding JSON member.  </li>
</ul>
<p>Starting with GDAL 2.0, drivers should specialize the <a class="el" href="classOGRLayer.html#a604ff4dcb92b2ef184c106765c1ed600" title="Rewrite/replace an existing feature.">ISetFeature()</a> method, since <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a> is no longer virtual.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a>.</p>
<p>To set a feature, but create it if it doesn't exist see <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGRLayer::UpsertFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a>, <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="aaf3f2e7ee476337082cea814226be11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3f2e7ee476337082cea814226be11a">&#9670;&nbsp;</a></span>SetIgnoredFields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SetIgnoredFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszFields</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">GetFeature()</a> / <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: "OGR_GEOMETRY" to ignore geometry and "OGR_STYLE" to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>Note that fields that are used in an attribute filter should generally not be set as ignored fields, as most drivers (such as those relying on the OGR SQL engine) will be unable to correctly evaluate the attribute filter.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154" title="Set which fields can be omitted when retrieving features from the layer.">OGR_L_SetIgnoredFields()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszFields</td><td>an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a8a5fbe69544693ae4b015592ea838f7c">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a61ab7226d95b20e3e1f42461a1f62906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ab7226d95b20e3e1f42461a1f62906">&#9670;&nbsp;</a></span>SetMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALMajorObject::SetMetadata </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszMetadataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set metadata. </p>
<p>The C function <a class="el" href="gdal_8h.html#a8cb466200cb98e3313dc131de37cb0d6" title="Set metadata.">GDALSetMetadata()</a> does the same thing as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszMetadataIn</td><td>the metadata in name=value string list format to apply. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>the domain of interest. Use "" or NULL for the default domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success, CE_Failure on failure and CE_Warning if the metadata has been accepted, but is likely not maintained persistently by the underlying object between sessions. </dd></dl>

<p>Reimplemented in <a class="el" href="classGDALPamRasterBand.html#a4439aeeec6e92db4106328465a0b5ff8">GDALPamRasterBand</a>, <a class="el" href="classGDALPamDataset.html#a761e5d6e616c3c49aa6242fa394efa7d">GDALPamDataset</a>, <a class="el" href="classGDALRasterBand.html#a43153dd62ecb5f15db95e0cb5deb6493">GDALRasterBand</a>, and <a class="el" href="classGDALDataset.html#a6c748856779f5337e4c32a11875b28dd">GDALDataset</a>.</p>

</div>
</div>
<a id="a3e157735f6ff6e11935c2a2dbcc24c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e157735f6ff6e11935c2a2dbcc24c92">&#9670;&nbsp;</a></span>SetMetadataItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__error_8h.html#a463ba7c7202a505416ff95b1aeefa2de">CPLErr</a> GDALMajorObject::SetMetadataItem </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set single metadata item. </p>
<p>The C function <a class="el" href="gdal_8h.html#a55f0b4c5192d18deb4dcf1a89ed59bbe" title="Set single metadata item.">GDALSetMetadataItem()</a> does the same thing as this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the key for the metadata item to fetch. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value to assign to the key. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>the domain to set within, use NULL for the default domain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CE_None on success, or an error code on failure. </dd></dl>

<p>Reimplemented in <a class="el" href="classGDALPluginDriverProxy.html#aee22c1455807bf502ffffc7e742153e6">GDALPluginDriverProxy</a>, <a class="el" href="classGDALDriver.html#a65130ea5fe7ea188b9c666080ea4ad30">GDALDriver</a>, <a class="el" href="classGDALPamRasterBand.html#a469ae318d361a0fa4666c5d085d5b1fb">GDALPamRasterBand</a>, <a class="el" href="classGDALPamDataset.html#ae9713b012bf3918966f8c12d5769e602">GDALPamDataset</a>, <a class="el" href="classGDALRasterBand.html#ad630899f792549b9c4c89d547c19583e">GDALRasterBand</a>, and <a class="el" href="classGDALDataset.html#ab49ab9b272c8aa6ce076a49a0f01df46">GDALDataset</a>.</p>

</div>
</div>
<a id="ae1af15d780eba6cc9937160d8cc6b2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1af15d780eba6cc9937160d8cc6b2b7">&#9670;&nbsp;</a></span>SetMOFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GDALMajorObject::SetMOFlags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign GMO_flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nNewFlags</td><td>new flags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b0869ff6fcadda35cbac1f3edf8eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b0869ff6fcadda35cbac1f3edf8eae">&#9670;&nbsp;</a></span>SetNextByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SetNextByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is <a class="el" href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">SetNextByIndex()</a> efficiently implemented. In all other cases the default implementation which calls <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> and then calls <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> nIndex times is used. To determine if fast seeking is available on the current layer use the <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability.">TestCapability()</a> method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a8b4427a82ea3de3bed7acff19b6e8e33" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">OGR_L_SetNextByIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nIndex</td><td>the index indicating how many steps into the result set to seek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

<p>Reimplemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#a1497ecb886f6cf53978d0897729ddf89">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a67cd391cf8015675b45c7553cd02906e">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="aebac60fb86ee178be016655532070ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac60fb86ee178be016655532070ee3">&#9670;&nbsp;</a></span>SetSpatialFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>Note to driver implementer: if you implement <a class="el" href="classOGRLayer.html#aebac60fb86ee178be016655532070ee3" title="Set a new spatial filter.">SetSpatialFilter(int,OGRGeometry*)</a>, you must also implement <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">SetSpatialFilter(OGRGeometry*)</a> to make it call SetSpatialFilter(0,OGRGeometry*).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823" title="Set a new spatial filter.">OGR_L_SetSpatialFilterEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">poFilter</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a7dd9f62ec3a5e334a6a8ae5b32f2cbda">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a0b4ab45cf97cbc470f0d60474d3e4169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4ab45cf97cbc470f0d60474d3e4169">&#9670;&nbsp;</a></span>SetSpatialFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRGeometry.html">OGRGeometry</a> *&#160;</td>
          <td class="paramname"><em>poFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This method set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGRGeometry::getEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>Starting with GDAL 2.3, features with null or empty geometries will never be considered as matching a spatial filter.</p>
<p>This method makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c" title="Set a new spatial filter.">OGR_L_SetSpatialFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFilter</td><td>the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a605821b486c96a1691ba3701f9946299">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="acd16bcdb3e8f720003fb24cd68f25460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd16bcdb3e8f720003fb24cd68f25460">&#9670;&nbsp;</a></span>SetSpatialFilterRect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13" title="Set a new rectangular spatial filter.">OGR_L_SetSpatialFilterRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a81c7e3b89822cbd078b5fb3118471d98">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a5cd4ceb8f4ec20594be63280c8e4498a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd4ceb8f4ec20594be63280c8e4498a">&#9670;&nbsp;</a></span>SetSpatialFilterRect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;<a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5" title="Set a new rectangular spatial filter.">OGR_L_SetSpatialFilterRectEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#abde8cd58988f17b2f7d6c6e997f22293">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a33fa0802c0686fb0e6ca6337e11cd7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fa0802c0686fb0e6ca6337e11cd7d5">&#9670;&nbsp;</a></span>SetStyleTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&#160;</td>
          <td class="paramname"><em>poStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set layer style table. </p>
<p>This method operate exactly as <a class="el" href="classOGRLayer.html#a2687d4312c044bb3a20bd13974ba8905" title="Set layer style table.">OGRLayer::SetStyleTableDirectly()</a> except that it does not assume ownership of the passed table.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9c5965608098528549e585895cb62e92" title="Set style table.">OGR_L_SetStyleTable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poStyleTable</td><td>pointer to style table to set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a22b8c67af40323b91e191f05a0086eb2">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a2687d4312c044bb3a20bd13974ba8905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2687d4312c044bb3a20bd13974ba8905">&#9670;&nbsp;</a></span>SetStyleTableDirectly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OGRLayer::SetStyleTableDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRStyleTable.html">OGRStyleTable</a> *&#160;</td>
          <td class="paramname"><em>poStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set layer style table. </p>
<p>This method operate exactly as <a class="el" href="classOGRLayer.html#a33fa0802c0686fb0e6ca6337e11cd7d5" title="Set layer style table.">OGRLayer::SetStyleTable()</a> except that it assumes ownership of the passed table.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ab6b700a54fb41ade2b3b090b2e0ef4be" title="Set style table (and take ownership)">OGR_L_SetStyleTableDirectly()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poStyleTable</td><td>pointer to style table to set </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#ad3bd0cdf55e1249cdbe9b222e6100209">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a2855f6fae6f97fa1cebcc2f57a0f974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2855f6fae6f97fa1cebcc2f57a0f974f">&#9670;&nbsp;</a></span>StartTransaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::StartTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>Note: as of GDAL 2.0, use of this API is discouraged when the dataset offers dataset level transaction with <a class="el" href="classGDALDataset.html#a3e4161f148fac57dac5cfe4900421348" title="For datasources which support transactions, StartTransaction creates a `transaction.">GDALDataset::StartTransaction()</a>. The reason is that most drivers can only offer transactions at dataset level, and not layer level. Very few drivers really support transactions at layer scope.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#a8180ea56ca7f677eb5da05c8cfcb77be" title="For datasources which support transactions, StartTransaction creates a transaction.">OGR_L_StartTransaction()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#aa51170039be88e1cafa99c9483408127">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="aced5ebed9bab6fcda662e211954f5437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced5ebed9bab6fcda662e211954f5437">&#9670;&nbsp;</a></span>StaticGetArrowSchema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::StaticGetArrowSchema </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>out_schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the ArrowArrayStream::get_schema() callback. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="aee0a2c772c12364df27789a54fd03403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0a2c772c12364df27789a54fd03403">&#9670;&nbsp;</a></span>StaticGetNextArrowArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::StaticGetNextArrowArray </td>
          <td>(</td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>out_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default implementation of the ArrowArrayStream::get_next() callback. </p>
<p>To be used by driver implementations that have a custom <a class="el" href="classOGRLayer.html#a3ffa8511632cbb7cff06a908e6668f55" title="Get a Arrow C stream.">GetArrowStream()</a> implementation.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a781aa76c6b44b19de09f61816e32245b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781aa76c6b44b19de09f61816e32245b">&#9670;&nbsp;</a></span>SymDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SymDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrical difference of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer but not in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set it to YES to convert Polygons into MultiPolygons, or LineStrings to MultiLineStrings.  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549" title="Symmetrical difference of two layers.">OGR_L_SymDifference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="aebb07284c734e485d8611b7c8599254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb07284c734e485d8611b7c8599254f">&#9670;&nbsp;</a></span>SyncToDisk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::SyncToDisk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with OGRDataSource::DestroyDataSource() that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a" title="Flush pending changes to disk.">OGR_L_SyncToDisk()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

<p>Reimplemented in <a class="el" href="classGNMGenericLayer.html#a2c5b4e4b8e3d7a132d6a3d40c2a2dea7">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="aeedbda1a62f9b89b8e5f24332cf22286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedbda1a62f9b89b8e5f24332cf22286">&#9670;&nbsp;</a></span>TestCapability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OGRLayer::TestCapability </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">GetFeature()</a> method is implemented in an optimized way for this layer, as opposed to the default implementation using <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">ResetReading()</a> and <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">GetNextFeature()</a> to find the requested feature id.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCUpsertFeature</b> / "UpsertFeature": TRUE if the <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">UpsertFeature()</a> method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="classOGRLayer.html#a2d0e1a43fd1a0a6d55d766384da7b6a5" title="Fetch the feature count in this layer.">GetFeatureCount()</a>) efficiently. i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">GetExtent()</a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the <a class="el" href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">SetNextByIndex()</a> call efficiently, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using <a class="el" href="classOGRLayer.html#a69ece498332c3054281f17939dceeab4" title="Create a new field on a layer.">CreateField()</a>, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using <a class="el" href="classOGRLayer.html#a87a4b0693ff9490881d213484b0bfe5d" title="Create a new geometry field on a layer.">CreateGeomField()</a>, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using <a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a" title="Delete an existing field on a layer.">DeleteField()</a>, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer.">ReorderField()</a> or <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">ReorderFields()</a>, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">AlterFieldDefn()</a>, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterGeomFieldDefn</b> / "AlterGeomFieldDefn": TRUE if this layer can alter the definition of an existing geometry field on the current layer using <a class="el" href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b" title="Alter the definition of an existing geometry field on a layer.">AlterGeomFieldDefn()</a>, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the <a class="el" href="classOGRLayer.html#a2342e79e0248076c2205047e1928f296" title="Delete feature from layer.">DeleteFeature()</a> method is supported on this layer, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the <a class="el" href="classOGRLayer.html#a2855f6fae6f97fa1cebcc2f57a0f974f" title="For datasources which support transactions, StartTransaction creates a transaction.">StartTransaction()</a>, <a class="el" href="classOGRLayer.html#a6cafa399e8f3027158787c87c3d1b97e" title="For datasources which support transactions, CommitTransaction commits a transaction.">CommitTransaction()</a> and <a class="el" href="classOGRLayer.html#ab046dbffc4fbd5bacc6ef75da0686d82" title="For datasources which support transactions, RollbackTransaction will roll back a datasource to its st...">RollbackTransaction()</a> methods work in a meaningful way, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCIgnoreFields</b> / "IgnoreFields": TRUE if fields, geometry and style will be omitted when fetching features as set by <a class="el" href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a" title="Set which fields can be omitted when retrieving features from the layer.">SetIgnoredFields()</a> method.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCurveGeometries</b> / "CurveGeometries": TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p class="interli"></p>
<p class="interli"></p>
<p class="endli"></p>
</li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability.">OGR_L_TestCapability()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszCap</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</dd></dl>

<p>Implemented in <a class="el" href="classOGRGNMWrappedResultLayer.html#af24de6270f5b356e908d66f24cd097da">OGRGNMWrappedResultLayer</a>, and <a class="el" href="classGNMGenericLayer.html#a6756f1d50d6aa06a66a5bb3483bdacfd">GNMGenericLayer</a>.</p>

</div>
</div>
<a id="a341ee268785b7e54714f789de59f23fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341ee268785b7e54714f789de59f23fe">&#9670;&nbsp;</a></span>ToHandle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="gdal_8h.html#ace297748fac88851533c56ddec20084f">GDALMajorObjectH</a> GDALMajorObject::ToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGDALMajorObject.html">GDALMajorObject</a> *&#160;</td>
          <td class="paramname"><em>poMajorObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a GDALMajorObject* to a GDALMajorObjectH. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6f202957750f4477a94a1a76c3ae91f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f202957750f4477a94a1a76c3ae91f3">&#9670;&nbsp;</a></span>ToHandle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGRLayer::ToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>poLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a OGRLayer* to a OGRLayerH. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="adf0598c7dab1f4dbe3e2735e27450c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0598c7dab1f4dbe3e2735e27450c9c">&#9670;&nbsp;</a></span>Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer, in the method layer, or in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer.  </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is YES, to add features with lower dimension geometry, but only if the result layer has an unknown geometry type.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7" title="Union of two layers.">OGR_L_Union()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a6b86f3a070fe99e39631c994be4fce08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b86f3a070fe99e39631c994be4fce08">&#9670;&nbsp;</a></span>Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update this layer with features from the update layer. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer or in the method layer. The features in the result layer have areas of the features of the method layer or those ares of the features of the input layer that are not covered by the method layer. The features of the result layer get their attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in the method layer, then the attribute in the result feature the originates from the method layer will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702" title="Update this layer with features from the update layer.">OGR_L_Update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="ad4ff65e1809eefacfa1d8f56deb1b39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ff65e1809eefacfa1d8f56deb1b39d">&#9670;&nbsp;</a></span>UpdateFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::UpdateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUpdatedFieldsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panUpdatedFieldsIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUpdatedGeomFieldsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panUpdatedGeomFieldsIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUpdateStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update (part of) an existing feature. </p>
<p>This method will update the specified attribute and geometry fields of a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>.</p>
<p>Use OGRLayer::TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a>. And to know if the driver supports a dedicated/efficient <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a> method, test for the OLCUpdateFeature capability.</p>
<p>The way unset fields in the provided poFeature are processed is driver dependent: </p><ul>
<li>
SQL based drivers which implement <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a> through SQL UPDATE will skip unset fields, and thus the content of the existing feature will be preserved.  </li>
<li>
The shapefile driver will write a NULL value in the DBF file.  </li>
<li>
The GeoJSON driver will take into account unset fields to remove the corresponding JSON member.  </li>
</ul>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2" title="Update (part of) an existing feature.">OGR_L_UpdateFeature()</a>.</p>
<p>To fully replace a feature, see <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">OGRLayer::SetFeature()</a>.</p>
<p>Note that after this call the content of hFeat might have changed, and will not* reflect the content you would get with <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">GetFeature()</a>. In particular for performance reasons, passed geometries might have been "stolen", in particular for the default implementation of <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a> which relies on <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">GetFeature()</a> + <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to update.</td></tr>
    <tr><td class="paramname">nUpdatedFieldsCount</td><td>number of attribute fields to update. May be 0</td></tr>
    <tr><td class="paramname">panUpdatedFieldsIdx</td><td>array of nUpdatedFieldsCount values, each between 0 and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetFieldCount() - 1, indicating which fields of poFeature must be updated in the layer.</td></tr>
    <tr><td class="paramname">nUpdatedGeomFieldsCount</td><td>number of geometry fields to update. May be 0</td></tr>
    <tr><td class="paramname">panUpdatedGeomFieldsIdx</td><td>array of nUpdatedGeomFieldsCount values, each between 0 and <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">GetLayerDefn()</a>-&gt;GetGeomFieldCount() - 1, indicating which geometry fields of poFeature must be updated in the layer.</td></tr>
    <tr><td class="paramname">bUpdateStyleString</td><td>whether the feature style string in the layer should be updated with the one of poFeature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a>, <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="a0fde458509b0cccc23d2ce89c1fd9dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fde458509b0cccc23d2ce89c1fd9dfb">&#9670;&nbsp;</a></span>UpsertFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRLayer::UpsertFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRFeature.html">OGRFeature</a> *&#160;</td>
          <td class="paramname"><em>poFeature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite/replace an existing feature or create a new feature within a layer. </p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>. If the feature id doesn't exist a new feature will be written. Otherwise, the existing feature will be rewritten.</p>
<p>Use OGRLayer::TestCapability(OLCUpsertFeature) to establish if this layer supports upsert writing.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGR_L_UpsertFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poFeature</td><td>the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">SetFeature()</a>, <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a>, <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">UpdateFeature()</a> </dd></dl>

</div>
</div>
<a id="adaaae8cb73e0e45d6eb8a06a44b4836c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaae8cb73e0e45d6eb8a06a44b4836c">&#9670;&nbsp;</a></span>WriteArrowBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRLayer::WriteArrowBatch </td>
          <td>(</td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a batch of rows from an ArrowArray. </p>
<p>This is semantically close to calling <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> with multiple features at once.</p>
<p>The ArrowArray must be of type struct (format=+s), and its children generally map to a OGR attribute or geometry field (unless they are struct themselves).</p>
<p>Method <a class="el" href="classOGRLayer.html#aad6238309c2ca47804da68096f838740" title="Returns whether the provided ArrowSchema is supported for writing.">IsArrowSchemaSupported()</a> can be called to determine if the schema will be supported by <a class="el" href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c" title="Writes a batch of rows from an ArrowArray.">WriteArrowBatch()</a>.</p>
<p>OGR fields for the corresponding children arrays must exist and be of a compatible type. For attribute fields, they should generally be created with <a class="el" href="classOGRLayer.html#a931c8aac9aa389fa58cacdecbf731579" title="Creates a field from an ArrowSchema.">CreateFieldFromArrowSchema()</a>. This is strictly required for output drivers Arrow or Parquet, and strongly recommended otherwise. For geometry fields, they should be created either implicitly at CreateLayer() type (if geom_type != wkbNone), or explicitly with <a class="el" href="classOGRLayer.html#a87a4b0693ff9490881d213484b0bfe5d" title="Create a new geometry field on a layer.">CreateGeomField()</a>.</p>
<p>Starting with GDAL 3.9, some tolerance has been introduced in the base implementation of <a class="el" href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c" title="Writes a batch of rows from an ArrowArray.">WriteArrowBatch()</a> for scenarios that involve appending to an already existing output layer when the input Arrow field type and the OGR layer field type are 32/64-bi integers or real number, but do not match exactly, which may cause lossy conversions. The IF_FIELD_NOT_PRESERVED option can be used to control the behavior in case of lossy conversion.</p>
<p>Arrays for geometry columns should be of binary or large binary type and contain WKB geometry.</p>
<p>Note that the passed array may be set to a released state (array-&gt;release==NULL) after this call (not by the base implementation, but in specialized ones such as Parquet or Arrow for example)</p>
<p>Supported options of the base implementation are: </p><ul>
<li>
FID=name. Name of the FID column in the array. If not provided, <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61" title="This method returns the name of the underlying database column being used as the FID column,...">GetFIDColumn()</a> is used to determine it. The special name <a class="el" href="classOGRLayer.html#aeaa832ad40d9bf5e4a23e43c8c92c2ce" title="Field name used by GetArrowSchema() for a FID column when GetFIDColumn() is not set.">OGRLayer::DEFAULT_ARROW_FID_NAME</a> is also recognized if neither FID nor <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61" title="This method returns the name of the underlying database column being used as the FID column,...">GetFIDColumn()</a> are set. The corresponding ArrowArray must be of type int32 (i) or int64 (l). On input, values of the FID column are used to create the feature. On output, the values of the FID column may be set with the FID of the created feature (if the array is not released).  </li>
<li>
IF_FID_NOT_PRESERVED=NOTHING/ERROR/WARNING. Action to perform when the input FID is not preserved in the output layer. The default is NOTHING. Setting it to ERROR will cause the function to error out. Setting it to WARNING will cause the function to emit a warning but continue its processing.  </li>
<li>
IF_FIELD_NOT_PRESERVED=ERROR/WARNING. (since GDAL 3.9) Action to perform when the input field value is not preserved in the output layer. The default is WARNING, which will cause the function to emit a warning but continue its processing. Setting it to ERROR will cause the function to error out if a lossy conversion is detected.  </li>
<li>
GEOMETRY_NAME=name. Name of the geometry column. If not provided, <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column,...">GetGeometryColumn()</a> is used. The special name <a class="el" href="classOGRLayer.html#ae079dc0eac54cc4ad068c7bdfb295acd" title="Field name used by GetArrowSchema() for the name of the (single) geometry column (returned by GetGeom...">OGRLayer::DEFAULT_ARROW_GEOMETRY_NAME</a> is also recognized if neither GEOMETRY_NAME nor <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column,...">GetGeometryColumn()</a> are set. Geometry columns are also identified if they have ARROW:extension:name=ogc.wkb as a field metadata. The corresponding ArrowArray must be of type binary (w) or large binary (W).  </li>
</ul>
<p>The following example demonstrates how to copy a layer from one format to another one (assuming it has at most a single geometry column): </p><div class="fragment"><div class="line"><span class="keyword">def </span>copy_layer(src_lyr, out_filename, out_format, lcos = {}):</div>
<div class="line">    stream = src_lyr.GetArrowStream()</div>
<div class="line">    schema = stream.GetSchema()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># If the source layer has a FID column and the output driver supports</span></div>
<div class="line">    <span class="comment"># a FID layer creation option, set it to the source FID column name.</span></div>
<div class="line">    <span class="keywordflow">if</span> src_lyr.GetFIDColumn():</div>
<div class="line">        creationOptions = gdal.GetDriverByName(out_format).GetMetadataItem(</div>
<div class="line">            <span class="stringliteral">&quot;DS_LAYER_CREATIONOPTIONLIST&quot;</span></div>
<div class="line">        )</div>
<div class="line">        <span class="keywordflow">if</span> creationOptions <span class="keywordflow">and</span> <span class="stringliteral">&#39;&quot;FID&quot;&#39;</span> <span class="keywordflow">in</span> creationOptions:</div>
<div class="line">            lcos[<span class="stringliteral">&quot;FID&quot;</span>] = src_lyr.GetFIDColumn()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">with</span> ogr.GetDriverByName(out_format).CreateDataSource(out_filename) <span class="keyword">as</span> out_ds:</div>
<div class="line">        <span class="keywordflow">if</span> src_lyr.GetLayerDefn().GetGeomFieldCount() &gt; 1:</div>
<div class="line">            out_lyr = out_ds.CreateLayer(</div>
<div class="line">                src_lyr.GetName(), geom_type=ogr.wkbNone, options=lcos</div>
<div class="line">            )</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(src_lyr.GetLayerDefn().GetGeomFieldCount()):</div>
<div class="line">                out_lyr.CreateGeomField(src_lyr.GetLayerDefn().GetGeomFieldDefn(i))</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            out_lyr = out_ds.CreateLayer(</div>
<div class="line">                src_lyr.GetName(),</div>
<div class="line">                geom_type=src_lyr.GetGeomType(),</div>
<div class="line">                srs=src_lyr.GetSpatialRef(),</div>
<div class="line">                options=lcos,</div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line">        success, error_msg = out_lyr.IsArrowSchemaSupported(schema)</div>
<div class="line">        <span class="keyword">assert</span> success, error_msg</div>
<div class="line"> </div>
<div class="line">        src_geom_field_names = [</div>
<div class="line">            src_lyr.GetLayerDefn().GetGeomFieldDefn(i).GetName()</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(src_lyr.GetLayerDefn().GetGeomFieldCount())</div>
<div class="line">        ]</div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(schema.GetChildrenCount()):</div>
<div class="line">            <span class="comment"># GetArrowStream() may return &quot;OGC_FID&quot; for a unnamed source FID</span></div>
<div class="line">            <span class="comment"># column and &quot;wkb_geometry&quot; for a unnamed source geometry column.</span></div>
<div class="line">            <span class="comment"># Also test GetFIDColumn() and src_geom_field_names if they are</span></div>
<div class="line">            <span class="comment"># named.</span></div>
<div class="line">            <span class="keywordflow">if</span> (</div>
<div class="line">                schema.GetChild(i).GetName()</div>
<div class="line">                <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&quot;OGC_FID&quot;</span>, <span class="stringliteral">&quot;wkb_geometry&quot;</span>, src_lyr.GetFIDColumn())</div>
<div class="line">                <span class="keywordflow">and</span> schema.GetChild(i).GetName() <span class="keywordflow">not</span> <span class="keywordflow">in</span> src_geom_field_names</div>
<div class="line">            ):</div>
<div class="line">                out_lyr.CreateFieldFromArrowSchema(schema.GetChild(i))</div>
<div class="line"> </div>
<div class="line">        write_options = []</div>
<div class="line">        <span class="keywordflow">if</span> src_lyr.GetFIDColumn():</div>
<div class="line">            write_options.append(<span class="stringliteral">&quot;FID=&quot;</span> + src_lyr.GetFIDColumn())</div>
<div class="line">        <span class="keywordflow">if</span> (</div>
<div class="line">            src_lyr.GetLayerDefn().GetGeomFieldCount() == 1</div>
<div class="line">            <span class="keywordflow">and</span> src_lyr.GetGeometryColumn()</div>
<div class="line">        ):</div>
<div class="line">            write_options.append(<span class="stringliteral">&quot;GEOMETRY_NAME=&quot;</span> + src_lyr.GetGeometryColumn())</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            array = stream.GetNextRecordBatch()</div>
<div class="line">            <span class="keywordflow">if</span> array <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">                <span class="keywordflow">break</span></div>
<div class="line">            out_lyr.WriteArrowBatch(schema, array, write_options)</div>
</div><!-- fragment --><p>This method and <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">CreateFeature()</a> are mutually exclusive in the same session.</p>
<p>This method is the same as the C function <a class="el" href="ogr__api_8h.html#afd53afc03673f67f4023108147d44989" title="Writes a batch of rows from an ArrowArray.">OGR_L_WriteArrowBatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>Schema of array </td></tr>
    <tr><td class="paramname">array</td><td>Array of type struct. It may be released (array-&gt;release==NULL) after calling this method. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options. Null terminated list, or nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1a85da9cbdc9d5a32f6479415f4d2d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85da9cbdc9d5a32f6479415f4d2d57">&#9670;&nbsp;</a></span>begin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FeatureIterator begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>poLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return begin of feature iterator. </p>
<p>Using this iterator for standard range-based loops is safe, but due to implementation limitations, you shouldn't try to access (dereference) more than one iterator step at a time, since the std::unique_ptr&lt;<a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>&gt; reference is reused.</p>
<p>Only one iterator per layer can be active at a time. </p><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#a95f19fa71f244c4408ceb92d5fe6b308" title="Return begin of feature iterator.">OGRLayer::begin()</a> </dd></dl>

</div>
</div>
<a id="a772fc157e7edff5deb096e7aedf7ece6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772fc157e7edff5deb096e7aedf7ece6">&#9670;&nbsp;</a></span>end</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FeatureIterator end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOGRLayer.html">OGRLayer</a> *&#160;</td>
          <td class="paramname"><em>poLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return end of feature iterator. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOGRLayer.html#a8cd93204c89e3cafa062507c60f41cb9" title="Return end of feature iterator.">OGRLayer::end()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ogrsf__frmts_8h_source.html">ogrsf_frmts.h</a></li>
<li>ogrsf_frmts.dox</li>
<li>ogrlayer.cpp</li>
<li>ogrlayerarrow.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
