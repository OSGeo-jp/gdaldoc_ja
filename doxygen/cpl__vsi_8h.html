<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: cpl_vsi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_651562d8bf6cfd3e81eff5b570d7df50.html">port</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cpl_vsi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Standard C Covers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cpl__port_8h_source.html">cpl_port.h</a>&quot;</code><br />
<code>#include &quot;cpl_progress.h&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
</div>
<p><a href="cpl__vsi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVSIDIREntry.html">VSIDIREntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directory entry.  <a href="structVSIDIREntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct containing callbacks to used by the handler.  <a href="structVSIFilesystemPluginCallbacksStruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7e5cdfef2e52acfa6c2d723934e0d796"><td class="memItemLeft" align="right" valign="top"><a id="a7e5cdfef2e52acfa6c2d723934e0d796"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7e5cdfef2e52acfa6c2d723934e0d796">VSI_ISLNK</a>(x)&#160;&#160;&#160;S_ISLNK(x)</td></tr>
<tr class="memdesc:a7e5cdfef2e52acfa6c2d723934e0d796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the file is a symbolic link. <br /></td></tr>
<tr class="separator:a7e5cdfef2e52acfa6c2d723934e0d796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c4561cb89d1e6d0273c5be2a374777"><td class="memItemLeft" align="right" valign="top"><a id="a57c4561cb89d1e6d0273c5be2a374777"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a57c4561cb89d1e6d0273c5be2a374777">VSI_ISREG</a>(x)&#160;&#160;&#160;S_ISREG(x)</td></tr>
<tr class="memdesc:a57c4561cb89d1e6d0273c5be2a374777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the file is a regular file. <br /></td></tr>
<tr class="separator:a57c4561cb89d1e6d0273c5be2a374777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9ada3d2bb3df2eae358b1037f9a1b"><td class="memItemLeft" align="right" valign="top"><a id="a13e9ada3d2bb3df2eae358b1037f9a1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a13e9ada3d2bb3df2eae358b1037f9a1b">VSI_ISDIR</a>(x)&#160;&#160;&#160;S_ISDIR(x)</td></tr>
<tr class="memdesc:a13e9ada3d2bb3df2eae358b1037f9a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the file is a directory. <br /></td></tr>
<tr class="separator:a13e9ada3d2bb3df2eae358b1037f9a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bb0e8c2fc561600efe533babb577aa"><td class="memItemLeft" align="right" valign="top"><a id="a20bb0e8c2fc561600efe533babb577aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a20bb0e8c2fc561600efe533babb577aa">VSI_L_OFFSET_MAX</a>&#160;&#160;&#160;<a class="el" href="cpl__port_8h.html#a82bd4992c0362d8addec634ec7d213b8">GUINTBIG_MAX</a></td></tr>
<tr class="memdesc:a20bb0e8c2fc561600efe533babb577aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for a file offset. <br /></td></tr>
<tr class="separator:a20bb0e8c2fc561600efe533babb577aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a9e6a14285f31ad3d34390a3d7ac23"><td class="memItemLeft" align="right" valign="top"><a id="a05a9e6a14285f31ad3d34390a3d7ac23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a>&#160;&#160;&#160;VSIStatBuf</td></tr>
<tr class="memdesc:a05a9e6a14285f31ad3d34390a3d7ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for <a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> <br /></td></tr>
<tr class="separator:a05a9e6a14285f31ad3d34390a3d7ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3fb3d4a5abff8b360d7b7941397503"><td class="memItemLeft" align="right" valign="top"><a id="a3e3fb3d4a5abff8b360d7b7941397503"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3e3fb3d4a5abff8b360d7b7941397503">VSI_STAT_EXISTS_FLAG</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a3e3fb3d4a5abff8b360d7b7941397503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6" title="Get filesystem object info.">VSIStatExL()</a> to test if the file exists. <br /></td></tr>
<tr class="separator:a3e3fb3d4a5abff8b360d7b7941397503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c44d6a3cae38b33d4b4b6bfb02131"><td class="memItemLeft" align="right" valign="top"><a id="ae67c44d6a3cae38b33d4b4b6bfb02131"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae67c44d6a3cae38b33d4b4b6bfb02131">VSI_STAT_NATURE_FLAG</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:ae67c44d6a3cae38b33d4b4b6bfb02131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6" title="Get filesystem object info.">VSIStatExL()</a> to query the nature (file/dir) of the file. <br /></td></tr>
<tr class="separator:ae67c44d6a3cae38b33d4b4b6bfb02131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4465858df54d216dbade556b08a5d4d"><td class="memItemLeft" align="right" valign="top"><a id="ac4465858df54d216dbade556b08a5d4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac4465858df54d216dbade556b08a5d4d">VSI_STAT_SIZE_FLAG</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:ac4465858df54d216dbade556b08a5d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6" title="Get filesystem object info.">VSIStatExL()</a> to query the file size. <br /></td></tr>
<tr class="separator:ac4465858df54d216dbade556b08a5d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c624636d6673f91667e8460417495e0"><td class="memItemLeft" align="right" valign="top"><a id="a0c624636d6673f91667e8460417495e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0c624636d6673f91667e8460417495e0">VSI_STAT_SET_ERROR_FLAG</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:a0c624636d6673f91667e8460417495e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6" title="Get filesystem object info.">VSIStatExL()</a> to issue a VSIError in case of failure. <br /></td></tr>
<tr class="separator:a0c624636d6673f91667e8460417495e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fee943d92d35104c3ccbdc96985fd8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7fee943d92d35104c3ccbdc96985fd8a">VSI_STAT_CACHE_ONLY</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a7fee943d92d35104c3ccbdc96985fd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag provided to <a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6" title="Get filesystem object info.">VSIStatExL()</a> to only use already cached results.  <a href="cpl__vsi_8h.html#a7fee943d92d35104c3ccbdc96985fd8a">More...</a><br /></td></tr>
<tr class="separator:a7fee943d92d35104c3ccbdc96985fd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab86f661220e57cd07d7bc6818183e1"><td class="memItemLeft" align="right" valign="top"><a id="a7ab86f661220e57cd07d7bc6818183e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7ab86f661220e57cd07d7bc6818183e1">VSI_MALLOC_ALIGNED_AUTO_VERBOSE</a>(size)&#160;&#160;&#160;    <a class="el" href="cpl__vsi_8h.html#a87268505f01af75052ab4cb58454c70f">VSIMallocAlignedAutoVerbose</a>(size, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:a7ab86f661220e57cd07d7bc6818183e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="cpl__vsi_8h.html#a87268505f01af75052ab4cb58454c70f" title="See VSIMallocAlignedAuto()">VSIMallocAlignedAutoVerbose()</a> with FILE and LINE reporting. <br /></td></tr>
<tr class="separator:a7ab86f661220e57cd07d7bc6818183e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade5a8741eb3362f68b2c3ee2d1b3676"><td class="memItemLeft" align="right" valign="top"><a id="aade5a8741eb3362f68b2c3ee2d1b3676"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aade5a8741eb3362f68b2c3ee2d1b3676">VSI_MALLOC_VERBOSE</a>(size)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a5534b6b1c687f387430dd6c4ea6ace56">VSIMallocVerbose</a>(size, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:aade5a8741eb3362f68b2c3ee2d1b3676"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_MALLOC_VERBOSE. <br /></td></tr>
<tr class="separator:aade5a8741eb3362f68b2c3ee2d1b3676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b87a2d19d51f10ecce10d4ba53570"><td class="memItemLeft" align="right" valign="top"><a id="ac85b87a2d19d51f10ecce10d4ba53570"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac85b87a2d19d51f10ecce10d4ba53570">VSI_MALLOC2_VERBOSE</a>(nSize1,  nSize2)&#160;&#160;&#160;    <a class="el" href="cpl__vsi_8h.html#a2f5e7a43a73fb746af86f6e8fe839078">VSIMalloc2Verbose</a>(nSize1, nSize2, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:ac85b87a2d19d51f10ecce10d4ba53570"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_MALLOC2_VERBOSE. <br /></td></tr>
<tr class="separator:ac85b87a2d19d51f10ecce10d4ba53570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7325cdd9f33067256f91301e84b96fa1"><td class="memItemLeft" align="right" valign="top"><a id="a7325cdd9f33067256f91301e84b96fa1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7325cdd9f33067256f91301e84b96fa1">VSI_MALLOC3_VERBOSE</a>(nSize1,  nSize2,  nSize3)&#160;&#160;&#160;    <a class="el" href="cpl__vsi_8h.html#ad539fca421bb7ddeb19e0c6b0de36db2">VSIMalloc3Verbose</a>(nSize1, nSize2, nSize3, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:a7325cdd9f33067256f91301e84b96fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_MALLOC3_VERBOSE. <br /></td></tr>
<tr class="separator:a7325cdd9f33067256f91301e84b96fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef6b56ece448880c45976dab915c89c"><td class="memItemLeft" align="right" valign="top"><a id="a0ef6b56ece448880c45976dab915c89c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0ef6b56ece448880c45976dab915c89c">VSI_CALLOC_VERBOSE</a>(nCount,  nSize)&#160;&#160;&#160;    <a class="el" href="cpl__vsi_8h.html#aafe65868a3cb7045836455de3856dcc3">VSICallocVerbose</a>(nCount, nSize, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:a0ef6b56ece448880c45976dab915c89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_CALLOC_VERBOSE. <br /></td></tr>
<tr class="separator:a0ef6b56ece448880c45976dab915c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f5ad7c5273fadcb66a4410f18fe0b4"><td class="memItemLeft" align="right" valign="top"><a id="a17f5ad7c5273fadcb66a4410f18fe0b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a17f5ad7c5273fadcb66a4410f18fe0b4">VSI_REALLOC_VERBOSE</a>(pOldPtr,  nNewSize)&#160;&#160;&#160;    <a class="el" href="cpl__vsi_8h.html#a21799ba8e93755fb048a31a20c47ac04">VSIReallocVerbose</a>(pOldPtr, nNewSize, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:a17f5ad7c5273fadcb66a4410f18fe0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_REALLOC_VERBOSE. <br /></td></tr>
<tr class="separator:a17f5ad7c5273fadcb66a4410f18fe0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5909c421c6d6bd385f6b702a9e7c693"><td class="memItemLeft" align="right" valign="top"><a id="ad5909c421c6d6bd385f6b702a9e7c693"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad5909c421c6d6bd385f6b702a9e7c693">VSI_STRDUP_VERBOSE</a>(pszStr)&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#af6c732e6825a16d87905d99edbcbb305">VSIStrdupVerbose</a>(pszStr, __FILE__, __LINE__)</td></tr>
<tr class="memdesc:ad5909c421c6d6bd385f6b702a9e7c693"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSI_STRDUP_VERBOSE. <br /></td></tr>
<tr class="separator:ad5909c421c6d6bd385f6b702a9e7c693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc1dc07ba4fe31933c9b522de783692"><td class="memItemLeft" align="right" valign="top"><a id="afdc1dc07ba4fe31933c9b522de783692"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#afdc1dc07ba4fe31933c9b522de783692">CPLReadDir</a>&#160;&#160;&#160;<a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3">VSIReadDir</a></td></tr>
<tr class="memdesc:afdc1dc07ba4fe31933c9b522de783692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3" title="Read names in a directory.">VSIReadDir()</a> <br /></td></tr>
<tr class="separator:afdc1dc07ba4fe31933c9b522de783692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af56f9ebab1994e4c2ed3f0a50af787b2"><td class="memItemLeft" align="right" valign="top"><a id="af56f9ebab1994e4c2ed3f0a50af787b2"></a>
typedef <a class="el" href="cpl__port_8h.html#a4f0794a0fb78d55ba284a414191dbc93">GUIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a></td></tr>
<tr class="memdesc:af56f9ebab1994e4c2ed3f0a50af787b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a file offset. <br /></td></tr>
<tr class="separator:af56f9ebab1994e4c2ed3f0a50af787b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4f822e1cc1e28bdf631f1baa835b7b"><td class="memItemLeft" align="right" valign="top"><a id="a1d4f822e1cc1e28bdf631f1baa835b7b"></a>
typedef struct <a class="el" href="structVSIVirtualHandle.html">VSIVirtualHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a></td></tr>
<tr class="memdesc:a1d4f822e1cc1e28bdf631f1baa835b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a FILE that implements the <a class="el" href="structVSIVirtualHandle.html" title="Virtual file handle.">VSIVirtualHandle</a> API. <br /></td></tr>
<tr class="separator:a1d4f822e1cc1e28bdf631f1baa835b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abfa965a6cceea416b192b38c90f9ad"><td class="memItemLeft" align="right" valign="top"><a id="a6abfa965a6cceea416b192b38c90f9ad"></a>
typedef struct <a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a></td></tr>
<tr class="memdesc:a6abfa965a6cceea416b192b38c90f9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a directory iterator. <br /></td></tr>
<tr class="separator:a6abfa965a6cceea416b192b38c90f9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ccf7fcbd054704350f72be08adec8"><td class="memItemLeft" align="right" valign="top"><a id="a121ccf7fcbd054704350f72be08adec8"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a121ccf7fcbd054704350f72be08adec8">VSIWriteFunction</a>) (const void *ptr, size_t size, size_t nmemb, FILE *stream)</td></tr>
<tr class="memdesc:a121ccf7fcbd054704350f72be08adec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used by <a class="el" href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79" title="Set an alternative write function and output file handle instead of fwrite() / stdout.">VSIStdoutSetRedirection()</a> <br /></td></tr>
<tr class="separator:a121ccf7fcbd054704350f72be08adec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d3d7c93b141ad3947a696dd298781a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a94d3d7c93b141ad3947a696dd298781a">VSIFilesystemPluginStatCallback</a>) (void *pUserData, const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *pStatBuf, int nFlags)</td></tr>
<tr class="memdesc:a94d3d7c93b141ad3947a696dd298781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about a handle.  <a href="cpl__vsi_8h.html#a94d3d7c93b141ad3947a696dd298781a">More...</a><br /></td></tr>
<tr class="separator:a94d3d7c93b141ad3947a696dd298781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfad10f0726010c7b046b2a9153e496b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abfad10f0726010c7b046b2a9153e496b">VSIFilesystemPluginUnlinkCallback</a>) (void *pUserData, const char *pszFilename)</td></tr>
<tr class="memdesc:abfad10f0726010c7b046b2a9153e496b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove handle by name.  <a href="cpl__vsi_8h.html#abfad10f0726010c7b046b2a9153e496b">More...</a><br /></td></tr>
<tr class="separator:abfad10f0726010c7b046b2a9153e496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d7066fe0aadaab4d2be154c100a1b2"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a46d7066fe0aadaab4d2be154c100a1b2">VSIFilesystemPluginRenameCallback</a>) (void *pUserData, const char *oldpath, const char *newpath)</td></tr>
<tr class="memdesc:a46d7066fe0aadaab4d2be154c100a1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename handle.  <a href="cpl__vsi_8h.html#a46d7066fe0aadaab4d2be154c100a1b2">More...</a><br /></td></tr>
<tr class="separator:a46d7066fe0aadaab4d2be154c100a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f54d817dbcfce03ce9610f3bc76185b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6f54d817dbcfce03ce9610f3bc76185b">VSIFilesystemPluginMkdirCallback</a>) (void *pUserData, const char *pszDirname, long nMode)</td></tr>
<tr class="memdesc:a6f54d817dbcfce03ce9610f3bc76185b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Directory.  <a href="cpl__vsi_8h.html#a6f54d817dbcfce03ce9610f3bc76185b">More...</a><br /></td></tr>
<tr class="separator:a6f54d817dbcfce03ce9610f3bc76185b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdedd1069c545b7fe216a209fd6767a3"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#afdedd1069c545b7fe216a209fd6767a3">VSIFilesystemPluginRmdirCallback</a>) (void *pUserData, const char *pszDirname)</td></tr>
<tr class="memdesc:afdedd1069c545b7fe216a209fd6767a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete Directory.  <a href="cpl__vsi_8h.html#afdedd1069c545b7fe216a209fd6767a3">More...</a><br /></td></tr>
<tr class="separator:afdedd1069c545b7fe216a209fd6767a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5375b18a338bd51e92e3496d23e7c491"><td class="memItemLeft" align="right" valign="top">typedef char **(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5375b18a338bd51e92e3496d23e7c491">VSIFilesystemPluginReadDirCallback</a>) (void *pUserData, const char *pszDirname, int nMaxFiles)</td></tr>
<tr class="memdesc:a5375b18a338bd51e92e3496d23e7c491"><td class="mdescLeft">&#160;</td><td class="mdescRight">List directory content.  <a href="cpl__vsi_8h.html#a5375b18a338bd51e92e3496d23e7c491">More...</a><br /></td></tr>
<tr class="separator:a5375b18a338bd51e92e3496d23e7c491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f067064f3f728ae2404e1c5eab5004"><td class="memItemLeft" align="right" valign="top">typedef char **(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad4f067064f3f728ae2404e1c5eab5004">VSIFilesystemPluginSiblingFilesCallback</a>) (void *pUserData, const char *pszDirname)</td></tr>
<tr class="memdesc:ad4f067064f3f728ae2404e1c5eab5004"><td class="mdescLeft">&#160;</td><td class="mdescRight">List related files.  <a href="cpl__vsi_8h.html#ad4f067064f3f728ae2404e1c5eab5004">More...</a><br /></td></tr>
<tr class="separator:ad4f067064f3f728ae2404e1c5eab5004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb10302b47889ece6b19479a81f05bc"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5fb10302b47889ece6b19479a81f05bc">VSIFilesystemPluginOpenCallback</a>) (void *pUserData, const char *pszFilename, const char *pszAccess)</td></tr>
<tr class="memdesc:a5fb10302b47889ece6b19479a81f05bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a handle.  <a href="cpl__vsi_8h.html#a5fb10302b47889ece6b19479a81f05bc">More...</a><br /></td></tr>
<tr class="separator:a5fb10302b47889ece6b19479a81f05bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3522495c9dd6b480828847e06f573781"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3522495c9dd6b480828847e06f573781">VSIFilesystemPluginTellCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:a3522495c9dd6b480828847e06f573781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current position in handle.  <a href="cpl__vsi_8h.html#a3522495c9dd6b480828847e06f573781">More...</a><br /></td></tr>
<tr class="separator:a3522495c9dd6b480828847e06f573781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93db78968a0bc9d5b859a5f1ab9d579d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a93db78968a0bc9d5b859a5f1ab9d579d">VSIFilesystemPluginSeekCallback</a>) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, int nWhence)</td></tr>
<tr class="memdesc:a93db78968a0bc9d5b859a5f1ab9d579d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to position in handle.  <a href="cpl__vsi_8h.html#a93db78968a0bc9d5b859a5f1ab9d579d">More...</a><br /></td></tr>
<tr class="separator:a93db78968a0bc9d5b859a5f1ab9d579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb9bc1c9e4faa76fe1395c5a2ecfc13"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2bb9bc1c9e4faa76fe1395c5a2ecfc13">VSIFilesystemPluginReadCallback</a>) (void *pFile, void *pBuffer, size_t nSize, size_t nCount)</td></tr>
<tr class="memdesc:a2bb9bc1c9e4faa76fe1395c5a2ecfc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from current position, returns the number of blocks correctly read.  <a href="cpl__vsi_8h.html#a2bb9bc1c9e4faa76fe1395c5a2ecfc13">More...</a><br /></td></tr>
<tr class="separator:a2bb9bc1c9e4faa76fe1395c5a2ecfc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2253223aadc64bea6904fd485eede527"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2253223aadc64bea6904fd485eede527">VSIFilesystemPluginReadMultiRangeCallback</a>) (void *pFile, int nRanges, void **ppData, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes)</td></tr>
<tr class="memdesc:a2253223aadc64bea6904fd485eede527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from multiple offsets.  <a href="cpl__vsi_8h.html#a2253223aadc64bea6904fd485eede527">More...</a><br /></td></tr>
<tr class="separator:a2253223aadc64bea6904fd485eede527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adeb34e38b0bd646643e18d016fe47d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a8adeb34e38b0bd646643e18d016fe47d">VSIFilesystemPluginGetRangeStatusCallback</a>) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength)</td></tr>
<tr class="memdesc:a8adeb34e38b0bd646643e18d016fe47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get empty ranges.  <a href="cpl__vsi_8h.html#a8adeb34e38b0bd646643e18d016fe47d">More...</a><br /></td></tr>
<tr class="separator:a8adeb34e38b0bd646643e18d016fe47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff9cabb436bd411346471369bee545d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#acff9cabb436bd411346471369bee545d">VSIFilesystemPluginEofCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:acff9cabb436bd411346471369bee545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has end of file been reached.  <a href="cpl__vsi_8h.html#acff9cabb436bd411346471369bee545d">More...</a><br /></td></tr>
<tr class="separator:acff9cabb436bd411346471369bee545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb9cabc545c740a05dfe0dc2c237834"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7bb9cabc545c740a05dfe0dc2c237834">VSIFilesystemPluginWriteCallback</a>) (void *pFile, const void *pBuffer, size_t nSize, size_t nCount)</td></tr>
<tr class="memdesc:a7bb9cabc545c740a05dfe0dc2c237834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes at current offset.  <a href="cpl__vsi_8h.html#a7bb9cabc545c740a05dfe0dc2c237834">More...</a><br /></td></tr>
<tr class="separator:a7bb9cabc545c740a05dfe0dc2c237834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed880694c27b9f94fd619c6ba81bf3fe"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aed880694c27b9f94fd619c6ba81bf3fe">VSIFilesystemPluginFlushCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:aed880694c27b9f94fd619c6ba81bf3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync written bytes.  <a href="cpl__vsi_8h.html#aed880694c27b9f94fd619c6ba81bf3fe">More...</a><br /></td></tr>
<tr class="separator:aed880694c27b9f94fd619c6ba81bf3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700c550a3f060ef72be35a639fa67775"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a700c550a3f060ef72be35a639fa67775">VSIFilesystemPluginTruncateCallback</a>) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nNewSize)</td></tr>
<tr class="memdesc:a700c550a3f060ef72be35a639fa67775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate handle.  <a href="cpl__vsi_8h.html#a700c550a3f060ef72be35a639fa67775">More...</a><br /></td></tr>
<tr class="separator:a700c550a3f060ef72be35a639fa67775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9c46d54ad75e6914322a84ced153f5"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6a9c46d54ad75e6914322a84ced153f5">VSIFilesystemPluginCloseCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:a6a9c46d54ad75e6914322a84ced153f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close file handle.  <a href="cpl__vsi_8h.html#a6a9c46d54ad75e6914322a84ced153f5">More...</a><br /></td></tr>
<tr class="separator:a6a9c46d54ad75e6914322a84ced153f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e8ffa000d76320d8d4b5c99d0cdfc5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a42e8ffa000d76320d8d4b5c99d0cdfc5">VSIFilesystemPluginAdviseReadCallback</a>) (void *pFile, int nRanges, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes)</td></tr>
<tr class="memdesc:a42e8ffa000d76320d8d4b5c99d0cdfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This optional method is called when code plans to access soon one or several ranges in a file.  <a href="cpl__vsi_8h.html#a42e8ffa000d76320d8d4b5c99d0cdfc5">More...</a><br /></td></tr>
<tr class="separator:a42e8ffa000d76320d8d4b5c99d0cdfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90944c54a489fa5778863d5d1c26c61"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af90944c54a489fa5778863d5d1c26c61">VSIFilesystemPluginErrorCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:af90944c54a489fa5778863d5d1c26c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has a read error (non end-of-file related) has occurred?  <a href="cpl__vsi_8h.html#af90944c54a489fa5778863d5d1c26c61">More...</a><br /></td></tr>
<tr class="separator:af90944c54a489fa5778863d5d1c26c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6c073bbfa87f66db171a363c9e69db"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9e6c073bbfa87f66db171a363c9e69db">VSIFilesystemPluginClearErrCallback</a>) (void *pFile)</td></tr>
<tr class="memdesc:a9e6c073bbfa87f66db171a363c9e69db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear error and end-of-file flags.  <a href="cpl__vsi_8h.html#a9e6c073bbfa87f66db171a363c9e69db">More...</a><br /></td></tr>
<tr class="separator:a9e6c073bbfa87f66db171a363c9e69db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2aa5b80209e71d81a118d647c6a9be66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a> { <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66a68ea00493f4c073e19da9613d1d3d630">VSI_RANGE_STATUS_UNKNOWN</a>
, <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66a20f1d70259ba20c9c8767fed7b0a7119">VSI_RANGE_STATUS_DATA</a>
, <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66a4518228a517000ca00f132bc67ac6dc7">VSI_RANGE_STATUS_HOLE</a>
 }</td></tr>
<tr class="memdesc:a2aa5b80209e71d81a118d647c6a9be66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range status.  <a href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">More...</a><br /></td></tr>
<tr class="separator:a2aa5b80209e71d81a118d647c6a9be66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad487ad46f2841815f331292051192d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f">VSIFOpenL</a> (const char *, const char *)</td></tr>
<tr class="memdesc:ad487ad46f2841815f331292051192d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file.  <a href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f">More...</a><br /></td></tr>
<tr class="separator:ad487ad46f2841815f331292051192d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae516076358c7d9af4e84340433a4f4da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae516076358c7d9af4e84340433a4f4da">VSIFOpenExL</a> (const char *, const char *, int)</td></tr>
<tr class="memdesc:ae516076358c7d9af4e84340433a4f4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open/create file.  <a href="cpl__vsi_8h.html#ae516076358c7d9af4e84340433a4f4da">More...</a><br /></td></tr>
<tr class="separator:ae516076358c7d9af4e84340433a4f4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae178578975a632abe5e4d598e0b5fb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ae178578975a632abe5e4d598e0b5fb79">VSIFOpenEx2L</a> (const char *, const char *, int, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:ae178578975a632abe5e4d598e0b5fb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open/create file.  <a href="cpl__vsi_8h.html#ae178578975a632abe5e4d598e0b5fb79">More...</a><br /></td></tr>
<tr class="separator:ae178578975a632abe5e4d598e0b5fb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fe6612261c1948eee388e75b7d6db7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7">VSIFCloseL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a82fe6612261c1948eee388e75b7d6db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close file.  <a href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7">More...</a><br /></td></tr>
<tr class="separator:a82fe6612261c1948eee388e75b7d6db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac1c2bc2d4dac71e504f62be5c564f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aeac1c2bc2d4dac71e504f62be5c564f3">VSIFSeekL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>, int)</td></tr>
<tr class="memdesc:aeac1c2bc2d4dac71e504f62be5c564f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to requested offset.  <a href="cpl__vsi_8h.html#aeac1c2bc2d4dac71e504f62be5c564f3">More...</a><br /></td></tr>
<tr class="separator:aeac1c2bc2d4dac71e504f62be5c564f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fe184bb565bbda49965102dbe0ca15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a25fe184bb565bbda49965102dbe0ca15">VSIFTellL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a25fe184bb565bbda49965102dbe0ca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell current file offset.  <a href="cpl__vsi_8h.html#a25fe184bb565bbda49965102dbe0ca15">More...</a><br /></td></tr>
<tr class="separator:a25fe184bb565bbda49965102dbe0ca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc227f7c966e95ece4691c3cc1c562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abbbc227f7c966e95ece4691c3cc1c562">VSIRewindL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:abbbc227f7c966e95ece4691c3cc1c562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the file pointer to the beginning of the file.  <a href="cpl__vsi_8h.html#abbbc227f7c966e95ece4691c3cc1c562">More...</a><br /></td></tr>
<tr class="separator:abbbc227f7c966e95ece4691c3cc1c562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb197f5fb0d431a565b89281d42d93"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aaddb197f5fb0d431a565b89281d42d93">VSIFReadL</a> (void *, size_t, size_t, <a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:aaddb197f5fb0d431a565b89281d42d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from file.  <a href="cpl__vsi_8h.html#aaddb197f5fb0d431a565b89281d42d93">More...</a><br /></td></tr>
<tr class="separator:aaddb197f5fb0d431a565b89281d42d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb325d9dcb43c16a3fa1592ed7c1d2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aaeb325d9dcb43c16a3fa1592ed7c1d2b">VSIFReadMultiRangeL</a> (int nRanges, void **ppData, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes, <a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:aaeb325d9dcb43c16a3fa1592ed7c1d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read several ranges of bytes from file.  <a href="cpl__vsi_8h.html#aaeb325d9dcb43c16a3fa1592ed7c1d2b">More...</a><br /></td></tr>
<tr class="separator:aaeb325d9dcb43c16a3fa1592ed7c1d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a382b55d461f4979f523e8c6e257ada"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2a382b55d461f4979f523e8c6e257ada">VSIFWriteL</a> (const void *, size_t, size_t, <a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a2a382b55d461f4979f523e8c6e257ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to file.  <a href="cpl__vsi_8h.html#a2a382b55d461f4979f523e8c6e257ada">More...</a><br /></td></tr>
<tr class="separator:a2a382b55d461f4979f523e8c6e257ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401e381ab9b3c6019876e9305151b00d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a401e381ab9b3c6019876e9305151b00d">VSIFClearErrL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a401e381ab9b3c6019876e9305151b00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the error and end-of-file indicators.  <a href="cpl__vsi_8h.html#a401e381ab9b3c6019876e9305151b00d">More...</a><br /></td></tr>
<tr class="separator:a401e381ab9b3c6019876e9305151b00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b7a7ffb058c8fab7525b604b5df577"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a55b7a7ffb058c8fab7525b604b5df577">VSIFErrorL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a55b7a7ffb058c8fab7525b604b5df577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the error indicator.  <a href="cpl__vsi_8h.html#a55b7a7ffb058c8fab7525b604b5df577">More...</a><br /></td></tr>
<tr class="separator:a55b7a7ffb058c8fab7525b604b5df577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72b69150d9dd7adb6e756196867a9b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab72b69150d9dd7adb6e756196867a9b2">VSIFEofL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:ab72b69150d9dd7adb6e756196867a9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for end of file.  <a href="cpl__vsi_8h.html#ab72b69150d9dd7adb6e756196867a9b2">More...</a><br /></td></tr>
<tr class="separator:ab72b69150d9dd7adb6e756196867a9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3363cbf28c47b5dcadaf0812dd50e6b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3363cbf28c47b5dcadaf0812dd50e6b9">VSIFTruncateL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>)</td></tr>
<tr class="memdesc:a3363cbf28c47b5dcadaf0812dd50e6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate/expand the file to the specified size.  <a href="cpl__vsi_8h.html#a3363cbf28c47b5dcadaf0812dd50e6b9">More...</a><br /></td></tr>
<tr class="separator:a3363cbf28c47b5dcadaf0812dd50e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224b7e3c50275ae1924e89185df5494d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a224b7e3c50275ae1924e89185df5494d">VSIFFlushL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a224b7e3c50275ae1924e89185df5494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending writes to disk.  <a href="cpl__vsi_8h.html#a224b7e3c50275ae1924e89185df5494d">More...</a><br /></td></tr>
<tr class="separator:a224b7e3c50275ae1924e89185df5494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19d593846fa567ada334b12a7bf8a3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad19d593846fa567ada334b12a7bf8a3b">VSIFPrintfL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *, const char *,...)</td></tr>
<tr class="memdesc:ad19d593846fa567ada334b12a7bf8a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatted write to file.  <a href="cpl__vsi_8h.html#ad19d593846fa567ada334b12a7bf8a3b">More...</a><br /></td></tr>
<tr class="separator:ad19d593846fa567ada334b12a7bf8a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6765447625c67466595e410519586fb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6765447625c67466595e410519586fb7">VSIFPutcL</a> (int, <a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a6765447625c67466595e410519586fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single byte to the file.  <a href="cpl__vsi_8h.html#a6765447625c67466595e410519586fb7">More...</a><br /></td></tr>
<tr class="separator:a6765447625c67466595e410519586fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e748fc4b8a074da08095bd91fff8fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0e748fc4b8a074da08095bd91fff8fed">VSIFGetRangeStatusL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *fp, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nStart, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength)</td></tr>
<tr class="memdesc:a0e748fc4b8a074da08095bd91fff8fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if a given file range contains data or holes filled with zeroes.  <a href="cpl__vsi_8h.html#a0e748fc4b8a074da08095bd91fff8fed">More...</a><br /></td></tr>
<tr class="separator:a0e748fc4b8a074da08095bd91fff8fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5ab5def482f0efc439162b2896b4ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6c5ab5def482f0efc439162b2896b4ea">VSIIngestFile</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *fp, const char *pszFilename, <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> **ppabyRet, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *pnSize, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> nMaxSize)</td></tr>
<tr class="memdesc:a6c5ab5def482f0efc439162b2896b4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ingest a file into memory.  <a href="cpl__vsi_8h.html#a6c5ab5def482f0efc439162b2896b4ea">More...</a><br /></td></tr>
<tr class="separator:a6c5ab5def482f0efc439162b2896b4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610595be39b84ad87d077f0499fa4460"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a610595be39b84ad87d077f0499fa4460">VSIOverwriteFile</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *fpTarget, const char *pszSourceFilename)</td></tr>
<tr class="memdesc:a610595be39b84ad87d077f0499fa4460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite an existing file with content from another one.  <a href="cpl__vsi_8h.html#a610595be39b84ad87d077f0499fa4460">More...</a><br /></td></tr>
<tr class="separator:a610595be39b84ad87d077f0499fa4460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92fbd5e6fc143b026001b32c4c19ed1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1">VSIStatL</a> (const char *, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *)</td></tr>
<tr class="memdesc:ac92fbd5e6fc143b026001b32c4c19ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filesystem object info.  <a href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1">More...</a><br /></td></tr>
<tr class="separator:ac92fbd5e6fc143b026001b32c4c19ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a691db1ba2f43add25a5c0d6498da6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6">VSIStatExL</a> (const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *psStatBuf, int nFlags)</td></tr>
<tr class="memdesc:ad1a691db1ba2f43add25a5c0d6498da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filesystem object info.  <a href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6">More...</a><br /></td></tr>
<tr class="separator:ad1a691db1ba2f43add25a5c0d6498da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36737f0cb2949ba2f7bbf23cc6592a04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a36737f0cb2949ba2f7bbf23cc6592a04">VSIIsCaseSensitiveFS</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a36737f0cb2949ba2f7bbf23cc6592a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filenames of the filesystem are case sensitive.  <a href="cpl__vsi_8h.html#a36737f0cb2949ba2f7bbf23cc6592a04">More...</a><br /></td></tr>
<tr class="separator:a36737f0cb2949ba2f7bbf23cc6592a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1bc0831510b6d134fa4d865b2f1328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6d1bc0831510b6d134fa4d865b2f1328">VSISupportsSparseFiles</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a6d1bc0831510b6d134fa4d865b2f1328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filesystem supports sparse files.  <a href="cpl__vsi_8h.html#a6d1bc0831510b6d134fa4d865b2f1328">More...</a><br /></td></tr>
<tr class="separator:a6d1bc0831510b6d134fa4d865b2f1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3fe30982dfd3591bd4dee6eeb50bc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aef3fe30982dfd3591bd4dee6eeb50bc1">VSIIsLocal</a> (const char *pszPath)</td></tr>
<tr class="memdesc:aef3fe30982dfd3591bd4dee6eeb50bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the file/filesystem is "local".  <a href="cpl__vsi_8h.html#aef3fe30982dfd3591bd4dee6eeb50bc1">More...</a><br /></td></tr>
<tr class="separator:aef3fe30982dfd3591bd4dee6eeb50bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cdb6f0c3f542c94201484008d70a2a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a76cdb6f0c3f542c94201484008d70a2a">VSIGetCanonicalFilename</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a76cdb6f0c3f542c94201484008d70a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical filename.  <a href="cpl__vsi_8h.html#a76cdb6f0c3f542c94201484008d70a2a">More...</a><br /></td></tr>
<tr class="separator:a76cdb6f0c3f542c94201484008d70a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5450ce943465f873c4b7039e3388fb97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5450ce943465f873c4b7039e3388fb97">VSISupportsSequentialWrite</a> (const char *pszPath, bool bAllowLocalTempFile)</td></tr>
<tr class="memdesc:a5450ce943465f873c4b7039e3388fb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filesystem supports sequential write.  <a href="cpl__vsi_8h.html#a5450ce943465f873c4b7039e3388fb97">More...</a><br /></td></tr>
<tr class="separator:a5450ce943465f873c4b7039e3388fb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4e6b2f84be8402bb0bffc23717cb97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2e4e6b2f84be8402bb0bffc23717cb97">VSISupportsRandomWrite</a> (const char *pszPath, bool bAllowLocalTempFile)</td></tr>
<tr class="memdesc:a2e4e6b2f84be8402bb0bffc23717cb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filesystem supports random write.  <a href="cpl__vsi_8h.html#a2e4e6b2f84be8402bb0bffc23717cb97">More...</a><br /></td></tr>
<tr class="separator:a2e4e6b2f84be8402bb0bffc23717cb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f2fd6f6c0676f27eb1bfdec56753a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a40f2fd6f6c0676f27eb1bfdec56753a9">VSIHasOptimizedReadMultiRange</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a40f2fd6f6c0676f27eb1bfdec56753a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the filesystem supports efficient multi-range reading.  <a href="cpl__vsi_8h.html#a40f2fd6f6c0676f27eb1bfdec56753a9">More...</a><br /></td></tr>
<tr class="separator:a40f2fd6f6c0676f27eb1bfdec56753a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc60b3e3bf1e892313f2abf0bcfaffd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0cc60b3e3bf1e892313f2abf0bcfaffd">VSIGetActualURL</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a0cc60b3e3bf1e892313f2abf0bcfaffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual URL of a supplied filename.  <a href="cpl__vsi_8h.html#a0cc60b3e3bf1e892313f2abf0bcfaffd">More...</a><br /></td></tr>
<tr class="separator:a0cc60b3e3bf1e892313f2abf0bcfaffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7d8fe76bc6c58fce962424574f0325"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9b7d8fe76bc6c58fce962424574f0325">VSIGetSignedURL</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a9b7d8fe76bc6c58fce962424574f0325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a signed URL of a supplied filename.  <a href="cpl__vsi_8h.html#a9b7d8fe76bc6c58fce962424574f0325">More...</a><br /></td></tr>
<tr class="separator:a9b7d8fe76bc6c58fce962424574f0325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ca54aa40490c9237e9dd2905d9daac"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a85ca54aa40490c9237e9dd2905d9daac">VSIGetFileSystemOptions</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a85ca54aa40490c9237e9dd2905d9daac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of options associated with a virtual file system handler as a serialized XML string.  <a href="cpl__vsi_8h.html#a85ca54aa40490c9237e9dd2905d9daac">More...</a><br /></td></tr>
<tr class="separator:a85ca54aa40490c9237e9dd2905d9daac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb3d5eb0effa7326ca6d3130b60bc94"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#adfb3d5eb0effa7326ca6d3130b60bc94">VSIGetFileSystemsPrefixes</a> (void)</td></tr>
<tr class="memdesc:adfb3d5eb0effa7326ca6d3130b60bc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of prefixes for virtual file system handlers currently registered.  <a href="cpl__vsi_8h.html#adfb3d5eb0effa7326ca6d3130b60bc94">More...</a><br /></td></tr>
<tr class="separator:adfb3d5eb0effa7326ca6d3130b60bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fd7388a7491b3430d0abe961dada82"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a41fd7388a7491b3430d0abe961dada82">VSIFGetNativeFileDescriptorL</a> (<a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *)</td></tr>
<tr class="memdesc:a41fd7388a7491b3430d0abe961dada82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the "native" file descriptor for the virtual handle.  <a href="cpl__vsi_8h.html#a41fd7388a7491b3430d0abe961dada82">More...</a><br /></td></tr>
<tr class="separator:a41fd7388a7491b3430d0abe961dada82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabfff0f98787365472b7351b8e34907"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#acabfff0f98787365472b7351b8e34907">VSIGetFileMetadata</a> (const char *pszFilename, const char *pszDomain, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:acabfff0f98787365472b7351b8e34907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get metadata on files.  <a href="cpl__vsi_8h.html#acabfff0f98787365472b7351b8e34907">More...</a><br /></td></tr>
<tr class="separator:acabfff0f98787365472b7351b8e34907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1c8d0014e7c76fbef98d24b9233a89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0a1c8d0014e7c76fbef98d24b9233a89">VSISetFileMetadata</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszMetadata, const char *pszDomain, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a0a1c8d0014e7c76fbef98d24b9233a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata on files.  <a href="cpl__vsi_8h.html#a0a1c8d0014e7c76fbef98d24b9233a89">More...</a><br /></td></tr>
<tr class="separator:a0a1c8d0014e7c76fbef98d24b9233a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4808a875c09ec946a9df0147ced8655f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f">VSISetPathSpecificOption</a> (const char *pszPathPrefix, const char *pszKey, const char *pszValue)</td></tr>
<tr class="memdesc:a4808a875c09ec946a9df0147ced8655f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a path specific option for a given path prefix.  <a href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f">More...</a><br /></td></tr>
<tr class="separator:a4808a875c09ec946a9df0147ced8655f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52959eb86a4f6f6f4034da55b82d480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af52959eb86a4f6f6f4034da55b82d480">VSIClearPathSpecificOptions</a> (const char *pszPathPrefix)</td></tr>
<tr class="memdesc:af52959eb86a4f6f6f4034da55b82d480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear path specific options set with <a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a>  <a href="cpl__vsi_8h.html#af52959eb86a4f6f6f4034da55b82d480">More...</a><br /></td></tr>
<tr class="separator:af52959eb86a4f6f6f4034da55b82d480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40db650bf590c736876183095cef983"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af40db650bf590c736876183095cef983">VSIGetPathSpecificOption</a> (const char *pszPath, const char *pszKey, const char *pszDefault)</td></tr>
<tr class="memdesc:af40db650bf590c736876183095cef983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value a path specific option.  <a href="cpl__vsi_8h.html#af40db650bf590c736876183095cef983">More...</a><br /></td></tr>
<tr class="separator:af40db650bf590c736876183095cef983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28296bd513f263acec28a02e12876664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a28296bd513f263acec28a02e12876664">VSISetCredential</a> (const char *pszPathPrefix, const char *pszKey, const char *pszValue)</td></tr>
<tr class="memdesc:a28296bd513f263acec28a02e12876664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a credential (or more generally an option related to a virtual file system) for a given path prefix.  <a href="cpl__vsi_8h.html#a28296bd513f263acec28a02e12876664">More...</a><br /></td></tr>
<tr class="separator:a28296bd513f263acec28a02e12876664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949779115e8e9d865a5bfe4acf2b8aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a949779115e8e9d865a5bfe4acf2b8aad">VSIClearCredentials</a> (const char *pszPathPrefix)</td></tr>
<tr class="memdesc:a949779115e8e9d865a5bfe4acf2b8aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear path specific options set with <a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a>  <a href="cpl__vsi_8h.html#a949779115e8e9d865a5bfe4acf2b8aad">More...</a><br /></td></tr>
<tr class="separator:a949779115e8e9d865a5bfe4acf2b8aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8958a8fbb353910a75e082efd26e1ce7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a8958a8fbb353910a75e082efd26e1ce7">VSIGetCredential</a> (const char *pszPath, const char *pszKey, const char *pszDefault)</td></tr>
<tr class="memdesc:a8958a8fbb353910a75e082efd26e1ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of a credential (or more generally an option related to a virtual file system) for a given path.  <a href="cpl__vsi_8h.html#a8958a8fbb353910a75e082efd26e1ce7">More...</a><br /></td></tr>
<tr class="separator:a8958a8fbb353910a75e082efd26e1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d73f4aa771b0c6299fea4ab41959a3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a35d73f4aa771b0c6299fea4ab41959a3">VSICalloc</a> (size_t, size_t)</td></tr>
<tr class="memdesc:a35d73f4aa771b0c6299fea4ab41959a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of calloc().  <a href="cpl__vsi_8h.html#a35d73f4aa771b0c6299fea4ab41959a3">More...</a><br /></td></tr>
<tr class="separator:a35d73f4aa771b0c6299fea4ab41959a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff69294658f2e1d02129bf69207c122"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5ff69294658f2e1d02129bf69207c122">VSIMalloc</a> (size_t)</td></tr>
<tr class="memdesc:a5ff69294658f2e1d02129bf69207c122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of malloc().  <a href="cpl__vsi_8h.html#a5ff69294658f2e1d02129bf69207c122">More...</a><br /></td></tr>
<tr class="separator:a5ff69294658f2e1d02129bf69207c122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26e15498e19c2a8169db924415ff7ab"><td class="memItemLeft" align="right" valign="top"><a id="af26e15498e19c2a8169db924415ff7ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab">VSIFree</a> (void *)</td></tr>
<tr class="memdesc:af26e15498e19c2a8169db924415ff7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of free() for data allocated with <a class="el" href="cpl__vsi_8h.html#a5ff69294658f2e1d02129bf69207c122" title="Analog of malloc().">VSIMalloc()</a>, <a class="el" href="cpl__vsi_8h.html#a35d73f4aa771b0c6299fea4ab41959a3" title="Analog of calloc().">VSICalloc()</a>, <a class="el" href="cpl__vsi_8h.html#add6cd6a32996ba1650528f2df3214c57" title="Analog of realloc().">VSIRealloc()</a> <br /></td></tr>
<tr class="separator:af26e15498e19c2a8169db924415ff7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6cd6a32996ba1650528f2df3214c57"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#add6cd6a32996ba1650528f2df3214c57">VSIRealloc</a> (void *, size_t)</td></tr>
<tr class="memdesc:add6cd6a32996ba1650528f2df3214c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of realloc().  <a href="cpl__vsi_8h.html#add6cd6a32996ba1650528f2df3214c57">More...</a><br /></td></tr>
<tr class="separator:add6cd6a32996ba1650528f2df3214c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0e16f51d70ca43d1c67e5dbe664277"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5a0e16f51d70ca43d1c67e5dbe664277">VSIStrdup</a> (const char *)</td></tr>
<tr class="memdesc:a5a0e16f51d70ca43d1c67e5dbe664277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of strdup().  <a href="cpl__vsi_8h.html#a5a0e16f51d70ca43d1c67e5dbe664277">More...</a><br /></td></tr>
<tr class="separator:a5a0e16f51d70ca43d1c67e5dbe664277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1">VSIMallocAligned</a> (size_t nAlignment, size_t nSize)</td></tr>
<tr class="memdesc:ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer with an alignment constraint.  <a href="cpl__vsi_8h.html#ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1">More...</a><br /></td></tr>
<tr class="separator:ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4e05ed5d30750133d43ca221b1ac70"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7c4e05ed5d30750133d43ca221b1ac70">VSIMallocAlignedAuto</a> (size_t nSize)</td></tr>
<tr class="memdesc:a7c4e05ed5d30750133d43ca221b1ac70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector instruction set on that platform.  <a href="cpl__vsi_8h.html#a7c4e05ed5d30750133d43ca221b1ac70">More...</a><br /></td></tr>
<tr class="separator:a7c4e05ed5d30750133d43ca221b1ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fc84461d6ad10524a64ead6af56e33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33">VSIFreeAligned</a> (void *ptr)</td></tr>
<tr class="memdesc:ad8fc84461d6ad10524a64ead6af56e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a buffer allocated with <a class="el" href="cpl__vsi_8h.html#ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1" title="Allocates a buffer with an alignment constraint.">VSIMallocAligned()</a>.  <a href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33">More...</a><br /></td></tr>
<tr class="separator:ad8fc84461d6ad10524a64ead6af56e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87268505f01af75052ab4cb58454c70f"><td class="memItemLeft" align="right" valign="top"><a id="a87268505f01af75052ab4cb58454c70f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a87268505f01af75052ab4cb58454c70f">VSIMallocAlignedAutoVerbose</a> (size_t nSize, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:a87268505f01af75052ab4cb58454c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="cpl__vsi_8h.html#a7c4e05ed5d30750133d43ca221b1ac70" title="Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector...">VSIMallocAlignedAuto()</a> <br /></td></tr>
<tr class="separator:a87268505f01af75052ab4cb58454c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b88331b0be4f7f2bd43e7b830af7038"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9b88331b0be4f7f2bd43e7b830af7038">VSIMalloc2</a> (size_t nSize1, size_t nSize2)</td></tr>
<tr class="memdesc:a9b88331b0be4f7f2bd43e7b830af7038"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc2 allocates (nSize1 * nSize2) bytes.  <a href="cpl__vsi_8h.html#a9b88331b0be4f7f2bd43e7b830af7038">More...</a><br /></td></tr>
<tr class="separator:a9b88331b0be4f7f2bd43e7b830af7038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644254757e7d9ec23df256d34fff565d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a644254757e7d9ec23df256d34fff565d">VSIMalloc3</a> (size_t nSize1, size_t nSize2, size_t nSize3)</td></tr>
<tr class="memdesc:a644254757e7d9ec23df256d34fff565d"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes.  <a href="cpl__vsi_8h.html#a644254757e7d9ec23df256d34fff565d">More...</a><br /></td></tr>
<tr class="separator:a644254757e7d9ec23df256d34fff565d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5534b6b1c687f387430dd6c4ea6ace56"><td class="memItemLeft" align="right" valign="top"><a id="a5534b6b1c687f387430dd6c4ea6ace56"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5534b6b1c687f387430dd6c4ea6ace56">VSIMallocVerbose</a> (size_t nSize, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:a5534b6b1c687f387430dd6c4ea6ace56"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMallocVerbose. <br /></td></tr>
<tr class="separator:a5534b6b1c687f387430dd6c4ea6ace56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5e7a43a73fb746af86f6e8fe839078"><td class="memItemLeft" align="right" valign="top"><a id="a2f5e7a43a73fb746af86f6e8fe839078"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2f5e7a43a73fb746af86f6e8fe839078">VSIMalloc2Verbose</a> (size_t nSize1, size_t nSize2, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:a2f5e7a43a73fb746af86f6e8fe839078"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc2Verbose. <br /></td></tr>
<tr class="separator:a2f5e7a43a73fb746af86f6e8fe839078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad539fca421bb7ddeb19e0c6b0de36db2"><td class="memItemLeft" align="right" valign="top"><a id="ad539fca421bb7ddeb19e0c6b0de36db2"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad539fca421bb7ddeb19e0c6b0de36db2">VSIMalloc3Verbose</a> (size_t nSize1, size_t nSize2, size_t nSize3, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:ad539fca421bb7ddeb19e0c6b0de36db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIMalloc3Verbose. <br /></td></tr>
<tr class="separator:ad539fca421bb7ddeb19e0c6b0de36db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe65868a3cb7045836455de3856dcc3"><td class="memItemLeft" align="right" valign="top"><a id="aafe65868a3cb7045836455de3856dcc3"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aafe65868a3cb7045836455de3856dcc3">VSICallocVerbose</a> (size_t nCount, size_t nSize, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:aafe65868a3cb7045836455de3856dcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSICallocVerbose. <br /></td></tr>
<tr class="separator:aafe65868a3cb7045836455de3856dcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21799ba8e93755fb048a31a20c47ac04"><td class="memItemLeft" align="right" valign="top"><a id="a21799ba8e93755fb048a31a20c47ac04"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a21799ba8e93755fb048a31a20c47ac04">VSIReallocVerbose</a> (void *pOldPtr, size_t nNewSize, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:a21799ba8e93755fb048a31a20c47ac04"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIReallocVerbose. <br /></td></tr>
<tr class="separator:a21799ba8e93755fb048a31a20c47ac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c732e6825a16d87905d99edbcbb305"><td class="memItemLeft" align="right" valign="top"><a id="af6c732e6825a16d87905d99edbcbb305"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af6c732e6825a16d87905d99edbcbb305">VSIStrdupVerbose</a> (const char *pszStr, const char *pszFile, int nLine)</td></tr>
<tr class="memdesc:af6c732e6825a16d87905d99edbcbb305"><td class="mdescLeft">&#160;</td><td class="mdescRight">VSIStrdupVerbose. <br /></td></tr>
<tr class="separator:af6c732e6825a16d87905d99edbcbb305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef39609553f41d5cb5078302c4b3de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2ef39609553f41d5cb5078302c4b3de2">CPLGetPhysicalRAM</a> (void)</td></tr>
<tr class="memdesc:a2ef39609553f41d5cb5078302c4b3de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total physical RAM in bytes.  <a href="cpl__vsi_8h.html#a2ef39609553f41d5cb5078302c4b3de2">More...</a><br /></td></tr>
<tr class="separator:a2ef39609553f41d5cb5078302c4b3de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eef6b11f21ea4d5c27a62ac265818a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac6eef6b11f21ea4d5c27a62ac265818a">CPLGetUsablePhysicalRAM</a> (void)</td></tr>
<tr class="memdesc:ac6eef6b11f21ea4d5c27a62ac265818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total physical RAM, usable by a process, in bytes.  <a href="cpl__vsi_8h.html#ac6eef6b11f21ea4d5c27a62ac265818a">More...</a><br /></td></tr>
<tr class="separator:ac6eef6b11f21ea4d5c27a62ac265818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6158d73485d6cf92c75b38e7f26d00c3"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3">VSIReadDir</a> (const char *)</td></tr>
<tr class="memdesc:a6158d73485d6cf92c75b38e7f26d00c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read names in a directory.  <a href="cpl__vsi_8h.html#a6158d73485d6cf92c75b38e7f26d00c3">More...</a><br /></td></tr>
<tr class="separator:a6158d73485d6cf92c75b38e7f26d00c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c473cd78f2dffabf709245a928e6c7"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a03c473cd78f2dffabf709245a928e6c7">VSIReadDirRecursive</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a03c473cd78f2dffabf709245a928e6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read names in a directory recursively.  <a href="cpl__vsi_8h.html#a03c473cd78f2dffabf709245a928e6c7">More...</a><br /></td></tr>
<tr class="separator:a03c473cd78f2dffabf709245a928e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f5bbeaa3ad170682f130f427930bd"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aab9f5bbeaa3ad170682f130f427930bd">VSIReadDirEx</a> (const char *pszPath, int nMaxFiles)</td></tr>
<tr class="memdesc:aab9f5bbeaa3ad170682f130f427930bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read names in a directory.  <a href="cpl__vsi_8h.html#aab9f5bbeaa3ad170682f130f427930bd">More...</a><br /></td></tr>
<tr class="separator:aab9f5bbeaa3ad170682f130f427930bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed636b28d00867f63348e13cd6b0a1bb"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aed636b28d00867f63348e13cd6b0a1bb">VSISiblingFiles</a> (const char *pszPath)</td></tr>
<tr class="memdesc:aed636b28d00867f63348e13cd6b0a1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return related filenames.  <a href="cpl__vsi_8h.html#aed636b28d00867f63348e13cd6b0a1bb">More...</a><br /></td></tr>
<tr class="separator:aed636b28d00867f63348e13cd6b0a1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fc9569f61a99e144a5f4e8dc185ad7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a35fc9569f61a99e144a5f4e8dc185ad7">VSIGetDirectorySeparator</a> (const char *pszPath)</td></tr>
<tr class="memdesc:a35fc9569f61a99e144a5f4e8dc185ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the directory separator for the specified path.  <a href="cpl__vsi_8h.html#a35fc9569f61a99e144a5f4e8dc185ad7">More...</a><br /></td></tr>
<tr class="separator:a35fc9569f61a99e144a5f4e8dc185ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d32d750cca298ea625c00e8be3f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90">VSIOpenDir</a> (const char *pszPath, int nRecurseDepth, const char *const *papszOptions)</td></tr>
<tr class="memdesc:a186d32d750cca298ea625c00e8be3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory to read its entries.  <a href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90">More...</a><br /></td></tr>
<tr class="separator:a186d32d750cca298ea625c00e8be3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce4131b005b1853a16d4f341d1ba031"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structVSIDIREntry.html">VSIDIREntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0ce4131b005b1853a16d4f341d1ba031">VSIGetNextDirEntry</a> (<a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *dir)</td></tr>
<tr class="memdesc:a0ce4131b005b1853a16d4f341d1ba031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next entry of the directory.  <a href="cpl__vsi_8h.html#a0ce4131b005b1853a16d4f341d1ba031">More...</a><br /></td></tr>
<tr class="separator:a0ce4131b005b1853a16d4f341d1ba031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7448bda4230b3d8133a59027c5f02f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f">VSICloseDir</a> (<a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *dir)</td></tr>
<tr class="memdesc:a7e7448bda4230b3d8133a59027c5f02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a directory.  <a href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f">More...</a><br /></td></tr>
<tr class="separator:a7e7448bda4230b3d8133a59027c5f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3e0b14583ca553a29bf163b972c157"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aaa3e0b14583ca553a29bf163b972c157">VSIMkdir</a> (const char *pszPathname, long mode)</td></tr>
<tr class="memdesc:aaa3e0b14583ca553a29bf163b972c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <a href="cpl__vsi_8h.html#aaa3e0b14583ca553a29bf163b972c157">More...</a><br /></td></tr>
<tr class="separator:aaa3e0b14583ca553a29bf163b972c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62018c639ec285ae04afa5799ee6a4d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a62018c639ec285ae04afa5799ee6a4d5">VSIMkdirRecursive</a> (const char *pszPathname, long mode)</td></tr>
<tr class="memdesc:a62018c639ec285ae04afa5799ee6a4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory and all its ancestors.  <a href="cpl__vsi_8h.html#a62018c639ec285ae04afa5799ee6a4d5">More...</a><br /></td></tr>
<tr class="separator:a62018c639ec285ae04afa5799ee6a4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c8873a6ff54d9c1e7f752cada9822"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af12c8873a6ff54d9c1e7f752cada9822">VSIRmdir</a> (const char *pszDirname)</td></tr>
<tr class="memdesc:af12c8873a6ff54d9c1e7f752cada9822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a directory.  <a href="cpl__vsi_8h.html#af12c8873a6ff54d9c1e7f752cada9822">More...</a><br /></td></tr>
<tr class="separator:af12c8873a6ff54d9c1e7f752cada9822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e05f10c591053fa876c9d3417421a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aa5e05f10c591053fa876c9d3417421a5">VSIRmdirRecursive</a> (const char *pszDirname)</td></tr>
<tr class="memdesc:aa5e05f10c591053fa876c9d3417421a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a directory recursively.  <a href="cpl__vsi_8h.html#aa5e05f10c591053fa876c9d3417421a5">More...</a><br /></td></tr>
<tr class="separator:aa5e05f10c591053fa876c9d3417421a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff49d132f70ec46a550c5a51103e394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7ff49d132f70ec46a550c5a51103e394">VSIUnlink</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:a7ff49d132f70ec46a550c5a51103e394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file.  <a href="cpl__vsi_8h.html#a7ff49d132f70ec46a550c5a51103e394">More...</a><br /></td></tr>
<tr class="separator:a7ff49d132f70ec46a550c5a51103e394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82382a50ea3be8c5c192a27a45b2673"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad82382a50ea3be8c5c192a27a45b2673">VSIUnlinkBatch</a> (<a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszFiles)</td></tr>
<tr class="memdesc:ad82382a50ea3be8c5c192a27a45b2673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete several files, possibly in a batch.  <a href="cpl__vsi_8h.html#ad82382a50ea3be8c5c192a27a45b2673">More...</a><br /></td></tr>
<tr class="separator:ad82382a50ea3be8c5c192a27a45b2673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cae93b5a32e11bef9ec7c118f8cca4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a26cae93b5a32e11bef9ec7c118f8cca4">VSIRename</a> (const char *oldpath, const char *newpath)</td></tr>
<tr class="memdesc:a26cae93b5a32e11bef9ec7c118f8cca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file.  <a href="cpl__vsi_8h.html#a26cae93b5a32e11bef9ec7c118f8cca4">More...</a><br /></td></tr>
<tr class="separator:a26cae93b5a32e11bef9ec7c118f8cca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2931707253132f6f2628be50e9e6db59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2931707253132f6f2628be50e9e6db59">VSICopyFile</a> (const char *pszSource, const char *pszTarget, <a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *fpSource, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nSourceSize, const char *const *papszOptions, GDALProgressFunc pProgressFunc, void *pProgressData)</td></tr>
<tr class="memdesc:a2931707253132f6f2628be50e9e6db59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a source file into a target file.  <a href="cpl__vsi_8h.html#a2931707253132f6f2628be50e9e6db59">More...</a><br /></td></tr>
<tr class="separator:a2931707253132f6f2628be50e9e6db59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca75ed325440d598169cd486e171e7cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf">VSICopyFileRestartable</a> (const char *pszSource, const char *pszTarget, const char *pszInputPayload, char **ppszOutputPayload, const char *const *papszOptions, GDALProgressFunc pProgressFunc, void *pProgressData)</td></tr>
<tr class="memdesc:aca75ed325440d598169cd486e171e7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a source file into a target file in a way that can (potentially) be restarted.  <a href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf">More...</a><br /></td></tr>
<tr class="separator:aca75ed325440d598169cd486e171e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6845a21b2c0491c594dd9deef757db6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6845a21b2c0491c594dd9deef757db6b">VSISync</a> (const char *pszSource, const char *pszTarget, const char *const *papszOptions, GDALProgressFunc pProgressFunc, void *pProgressData, char ***ppapszOutputs)</td></tr>
<tr class="memdesc:a6845a21b2c0491c594dd9deef757db6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize a source file/directory with a target file/directory.  <a href="cpl__vsi_8h.html#a6845a21b2c0491c594dd9deef757db6b">More...</a><br /></td></tr>
<tr class="separator:a6845a21b2c0491c594dd9deef757db6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d427470f6856989f19a1d4052c9f02f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a7d427470f6856989f19a1d4052c9f02f">VSIMultipartUploadGetCapabilities</a> (const char *pszFilename, int *pbNonSequentialUploadSupported, int *pbParallelUploadSupported, int *pbAbortSupported, size_t *pnMinPartSize, size_t *pnMaxPartSize, int *pnMaxPartCount)</td></tr>
<tr class="memdesc:a7d427470f6856989f19a1d4052c9f02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return capabilities for multiple part file upload.  <a href="cpl__vsi_8h.html#a7d427470f6856989f19a1d4052c9f02f">More...</a><br /></td></tr>
<tr class="separator:a7d427470f6856989f19a1d4052c9f02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80827e0cd2062452638eb16d73914a10"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10">VSIMultipartUploadStart</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a80827e0cd2062452638eb16d73914a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the upload a (big) file in a piece-wise way.  <a href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10">More...</a><br /></td></tr>
<tr class="separator:a80827e0cd2062452638eb16d73914a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40fa2b252fafa7d9212a07a45caa899"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad40fa2b252fafa7d9212a07a45caa899">VSIMultipartUploadAddPart</a> (const char *pszFilename, const char *pszUploadId, int nPartNumber, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nFileOffset, const void *pData, size_t nDataLength, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:ad40fa2b252fafa7d9212a07a45caa899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads a new part to a multi-part uploaded file.  <a href="cpl__vsi_8h.html#ad40fa2b252fafa7d9212a07a45caa899">More...</a><br /></td></tr>
<tr class="separator:ad40fa2b252fafa7d9212a07a45caa899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7b68759e67004aa29ddf3e6a5ee5cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2b7b68759e67004aa29ddf3e6a5ee5cc">VSIMultipartUploadEnd</a> (const char *pszFilename, const char *pszUploadId, size_t nPartIdsCount, const char *const *apszPartIds, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nTotalSize, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a2b7b68759e67004aa29ddf3e6a5ee5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes a multi-part file upload.  <a href="cpl__vsi_8h.html#a2b7b68759e67004aa29ddf3e6a5ee5cc">More...</a><br /></td></tr>
<tr class="separator:a2b7b68759e67004aa29ddf3e6a5ee5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e724523119104cbf8468a12ff4c5744"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6e724523119104cbf8468a12ff4c5744">VSIMultipartUploadAbort</a> (const char *pszFilename, const char *pszUploadId, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a6e724523119104cbf8468a12ff4c5744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a multi-part file upload.  <a href="cpl__vsi_8h.html#a6e724523119104cbf8468a12ff4c5744">More...</a><br /></td></tr>
<tr class="separator:a6e724523119104cbf8468a12ff4c5744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf0d1fa9f93e17738fba3912f010c81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#adbf0d1fa9f93e17738fba3912f010c81">VSIAbortPendingUploads</a> (const char *pszFilename)</td></tr>
<tr class="memdesc:adbf0d1fa9f93e17738fba3912f010c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort all ongoing multi-part uploads.  <a href="cpl__vsi_8h.html#adbf0d1fa9f93e17738fba3912f010c81">More...</a><br /></td></tr>
<tr class="separator:adbf0d1fa9f93e17738fba3912f010c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ee85ec9884dc16feda2b81de1cc36"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a312ee85ec9884dc16feda2b81de1cc36">VSIStrerror</a> (int)</td></tr>
<tr class="memdesc:a312ee85ec9884dc16feda2b81de1cc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the error string corresponding to the error number.  <a href="cpl__vsi_8h.html#a312ee85ec9884dc16feda2b81de1cc36">More...</a><br /></td></tr>
<tr class="separator:a312ee85ec9884dc16feda2b81de1cc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ae557aaaa4cc249cd97080101a8297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad4ae557aaaa4cc249cd97080101a8297">VSIGetDiskFreeSpace</a> (const char *pszDirname)</td></tr>
<tr class="memdesc:ad4ae557aaaa4cc249cd97080101a8297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return free disk space available on the filesystem.  <a href="cpl__vsi_8h.html#ad4ae557aaaa4cc249cd97080101a8297">More...</a><br /></td></tr>
<tr class="separator:ad4ae557aaaa4cc249cd97080101a8297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8c1d1c1954cfe7a7e811617df87323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a0e8c1d1c1954cfe7a7e811617df87323">VSINetworkStatsReset</a> (void)</td></tr>
<tr class="memdesc:a0e8c1d1c1954cfe7a7e811617df87323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear network related statistics.  <a href="cpl__vsi_8h.html#a0e8c1d1c1954cfe7a7e811617df87323">More...</a><br /></td></tr>
<tr class="separator:a0e8c1d1c1954cfe7a7e811617df87323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29c1f4b02612f1220bd574d610c67a2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac29c1f4b02612f1220bd574d610c67a2">VSINetworkStatsGetAsSerializedJSON</a> (char **papszOptions)</td></tr>
<tr class="memdesc:ac29c1f4b02612f1220bd574d610c67a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return network related statistics, as a JSON serialized object.  <a href="cpl__vsi_8h.html#ac29c1f4b02612f1220bd574d610c67a2">More...</a><br /></td></tr>
<tr class="separator:ac29c1f4b02612f1220bd574d610c67a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e2e6f093fd42f8a941b962d4c8a19e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a66e2e6f093fd42f8a941b962d4c8a19e">VSIInstallMemFileHandler</a> (void)</td></tr>
<tr class="memdesc:a66e2e6f093fd42f8a941b962d4c8a19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install "memory" file system handler.  <a href="cpl__vsi_8h.html#a66e2e6f093fd42f8a941b962d4c8a19e">More...</a><br /></td></tr>
<tr class="separator:a66e2e6f093fd42f8a941b962d4c8a19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee4232440e012b4b9920934fc571cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#abaee4232440e012b4b9920934fc571cc">VSIInstallSubFileHandler</a> (void)</td></tr>
<tr class="memdesc:abaee4232440e012b4b9920934fc571cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsisubfile/ virtual file handler.  <a href="cpl__vsi_8h.html#abaee4232440e012b4b9920934fc571cc">More...</a><br /></td></tr>
<tr class="separator:abaee4232440e012b4b9920934fc571cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f791960f2d86713d16e99e9c0c36258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258">VSIInstallCurlFileHandler</a> (void)</td></tr>
<tr class="memdesc:a4f791960f2d86713d16e99e9c0c36258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsicurl/ HTTP/FTP file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258">More...</a><br /></td></tr>
<tr class="separator:a4f791960f2d86713d16e99e9c0c36258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b22260317edc475793c4165957742b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6b22260317edc475793c4165957742b6">VSICurlClearCache</a> (void)</td></tr>
<tr class="memdesc:a6b22260317edc475793c4165957742b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean local cache associated with /vsicurl/ (and related file systems)  <a href="cpl__vsi_8h.html#a6b22260317edc475793c4165957742b6">More...</a><br /></td></tr>
<tr class="separator:a6b22260317edc475793c4165957742b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc83d16f0f279f601059a218ad2c55c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6bc83d16f0f279f601059a218ad2c55c">VSICurlPartialClearCache</a> (const char *pszFilenamePrefix)</td></tr>
<tr class="memdesc:a6bc83d16f0f279f601059a218ad2c55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean local cache associated with /vsicurl/ (and related file systems) for a given filename (and its subfiles and subdirectories if it is a directory)  <a href="cpl__vsi_8h.html#a6bc83d16f0f279f601059a218ad2c55c">More...</a><br /></td></tr>
<tr class="separator:a6bc83d16f0f279f601059a218ad2c55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab187e6713f07be9756c22c58b782642d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab187e6713f07be9756c22c58b782642d">VSIInstallCurlStreamingFileHandler</a> (void)</td></tr>
<tr class="memdesc:ab187e6713f07be9756c22c58b782642d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsicurl_streaming/ HTTP/FTP file system handler (requires libcurl).  <a href="cpl__vsi_8h.html#ab187e6713f07be9756c22c58b782642d">More...</a><br /></td></tr>
<tr class="separator:ab187e6713f07be9756c22c58b782642d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4754999acd06444bfda172ff2aaa16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5b4754999acd06444bfda172ff2aaa16">VSIInstallS3FileHandler</a> (void)</td></tr>
<tr class="memdesc:a5b4754999acd06444bfda172ff2aaa16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsis3/ Amazon S3 file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#a5b4754999acd06444bfda172ff2aaa16">More...</a><br /></td></tr>
<tr class="separator:a5b4754999acd06444bfda172ff2aaa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126c1e0314bbd7e4661bc526f45032c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a126c1e0314bbd7e4661bc526f45032c5">VSIInstallS3StreamingFileHandler</a> (void)</td></tr>
<tr class="memdesc:a126c1e0314bbd7e4661bc526f45032c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsis3_streaming/ Amazon S3 file system handler (requires libcurl).  <a href="cpl__vsi_8h.html#a126c1e0314bbd7e4661bc526f45032c5">More...</a><br /></td></tr>
<tr class="separator:a126c1e0314bbd7e4661bc526f45032c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80a70fd45cd7a2119f1a2f7da071870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af80a70fd45cd7a2119f1a2f7da071870">VSIInstallGSFileHandler</a> (void)</td></tr>
<tr class="memdesc:af80a70fd45cd7a2119f1a2f7da071870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsigs/ Google Cloud Storage file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#af80a70fd45cd7a2119f1a2f7da071870">More...</a><br /></td></tr>
<tr class="separator:af80a70fd45cd7a2119f1a2f7da071870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9158701b72f0c840996d8ad98bb2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aca9158701b72f0c840996d8ad98bb2ff">VSIInstallGSStreamingFileHandler</a> (void)</td></tr>
<tr class="memdesc:aca9158701b72f0c840996d8ad98bb2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsigs_streaming/ Google Cloud Storage file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#aca9158701b72f0c840996d8ad98bb2ff">More...</a><br /></td></tr>
<tr class="separator:aca9158701b72f0c840996d8ad98bb2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f1bf516788238d7138c879dedd62a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af1f1bf516788238d7138c879dedd62a4">VSIInstallAzureFileHandler</a> (void)</td></tr>
<tr class="memdesc:af1f1bf516788238d7138c879dedd62a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiaz/ Microsoft Azure Blob file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#af1f1bf516788238d7138c879dedd62a4">More...</a><br /></td></tr>
<tr class="separator:af1f1bf516788238d7138c879dedd62a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913ec753ebec2261f0420e8989dd6dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af913ec753ebec2261f0420e8989dd6dd">VSIInstallAzureStreamingFileHandler</a> (void)</td></tr>
<tr class="memdesc:af913ec753ebec2261f0420e8989dd6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiaz_streaming/ Microsoft Azure Blob file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#af913ec753ebec2261f0420e8989dd6dd">More...</a><br /></td></tr>
<tr class="separator:af913ec753ebec2261f0420e8989dd6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac645fd873dc52984a5b2bb9e7f1207b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac645fd873dc52984a5b2bb9e7f1207b9">VSIInstallADLSFileHandler</a> (void)</td></tr>
<tr class="memdesc:ac645fd873dc52984a5b2bb9e7f1207b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiaz/ Microsoft Azure Data Lake Storage Gen2 file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#ac645fd873dc52984a5b2bb9e7f1207b9">More...</a><br /></td></tr>
<tr class="separator:ac645fd873dc52984a5b2bb9e7f1207b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad393a845ca054eab086fb933cee74be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad393a845ca054eab086fb933cee74be0">VSIInstallOSSFileHandler</a> (void)</td></tr>
<tr class="memdesc:ad393a845ca054eab086fb933cee74be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#ad393a845ca054eab086fb933cee74be0">More...</a><br /></td></tr>
<tr class="separator:ad393a845ca054eab086fb933cee74be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966348bdbdd092035cd7925d56943d05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a966348bdbdd092035cd7925d56943d05">VSIInstallOSSStreamingFileHandler</a> (void)</td></tr>
<tr class="memdesc:a966348bdbdd092035cd7925d56943d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiaz_streaming/ Alibaba Cloud Object Storage Service (OSS) (requires libcurl)  <a href="cpl__vsi_8h.html#a966348bdbdd092035cd7925d56943d05">More...</a><br /></td></tr>
<tr class="separator:a966348bdbdd092035cd7925d56943d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a177eab3fbc4241083f6749b9a75d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a87a177eab3fbc4241083f6749b9a75d5">VSIInstallSwiftFileHandler</a> (void)</td></tr>
<tr class="memdesc:a87a177eab3fbc4241083f6749b9a75d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#a87a177eab3fbc4241083f6749b9a75d5">More...</a><br /></td></tr>
<tr class="separator:a87a177eab3fbc4241083f6749b9a75d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6112f0851a51fe5ad1333f5cd1672ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a6112f0851a51fe5ad1333f5cd1672ab6">VSIInstallSwiftStreamingFileHandler</a> (void)</td></tr>
<tr class="memdesc:a6112f0851a51fe5ad1333f5cd1672ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiswift_streaming/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#a6112f0851a51fe5ad1333f5cd1672ab6">More...</a><br /></td></tr>
<tr class="separator:a6112f0851a51fe5ad1333f5cd1672ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7afbe67a242152693eec13b3e15aa74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad7afbe67a242152693eec13b3e15aa74">VSIInstall7zFileHandler</a> (void)</td></tr>
<tr class="memdesc:ad7afbe67a242152693eec13b3e15aa74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsi7z/ 7zip file system handler (requires libarchive)  <a href="cpl__vsi_8h.html#ad7afbe67a242152693eec13b3e15aa74">More...</a><br /></td></tr>
<tr class="separator:ad7afbe67a242152693eec13b3e15aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46625a713d8fb18b05aa747080858bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac46625a713d8fb18b05aa747080858bf">VSIInstallRarFileHandler</a> (void)</td></tr>
<tr class="memdesc:ac46625a713d8fb18b05aa747080858bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsirar/ RAR file system handler (requires libarchive)  <a href="cpl__vsi_8h.html#ac46625a713d8fb18b05aa747080858bf">More...</a><br /></td></tr>
<tr class="separator:ac46625a713d8fb18b05aa747080858bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde09f204df6f417653b7af4761178e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a3cde09f204df6f417653b7af4761178e">VSIInstallGZipFileHandler</a> (void)</td></tr>
<tr class="memdesc:a3cde09f204df6f417653b7af4761178e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install GZip file system handler.  <a href="cpl__vsi_8h.html#a3cde09f204df6f417653b7af4761178e">More...</a><br /></td></tr>
<tr class="separator:a3cde09f204df6f417653b7af4761178e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884fac3cd6be2c09deb807e959d78b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a">VSIInstallZipFileHandler</a> (void)</td></tr>
<tr class="memdesc:a884fac3cd6be2c09deb807e959d78b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install ZIP file system handler.  <a href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a">More...</a><br /></td></tr>
<tr class="separator:a884fac3cd6be2c09deb807e959d78b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6b408477f59b40f0aec51d5980eb8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a2c6b408477f59b40f0aec51d5980eb8e">VSIInstallStdinHandler</a> (void)</td></tr>
<tr class="memdesc:a2c6b408477f59b40f0aec51d5980eb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsistdin/ file system handler.  <a href="cpl__vsi_8h.html#a2c6b408477f59b40f0aec51d5980eb8e">More...</a><br /></td></tr>
<tr class="separator:a2c6b408477f59b40f0aec51d5980eb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c296255c2263248d0e6ad7c4481d746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5c296255c2263248d0e6ad7c4481d746">VSIInstallHdfsHandler</a> (void)</td></tr>
<tr class="memdesc:a5c296255c2263248d0e6ad7c4481d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsihdfs/ file system handler (requires JVM and HDFS support)  <a href="cpl__vsi_8h.html#a5c296255c2263248d0e6ad7c4481d746">More...</a><br /></td></tr>
<tr class="separator:a5c296255c2263248d0e6ad7c4481d746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b1d08d5f6dcd37d2ed89583765ee9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a51b1d08d5f6dcd37d2ed89583765ee9b">VSIInstallWebHdfsHandler</a> (void)</td></tr>
<tr class="memdesc:a51b1d08d5f6dcd37d2ed89583765ee9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system handler (requires libcurl)  <a href="cpl__vsi_8h.html#a51b1d08d5f6dcd37d2ed89583765ee9b">More...</a><br /></td></tr>
<tr class="separator:a51b1d08d5f6dcd37d2ed89583765ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d2250ab2b22ca79b051a8479ee5383"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a61d2250ab2b22ca79b051a8479ee5383">VSIInstallStdoutHandler</a> (void)</td></tr>
<tr class="memdesc:a61d2250ab2b22ca79b051a8479ee5383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsistdout/ file system handler.  <a href="cpl__vsi_8h.html#a61d2250ab2b22ca79b051a8479ee5383">More...</a><br /></td></tr>
<tr class="separator:a61d2250ab2b22ca79b051a8479ee5383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79aed725b28eb22471a8b6733405843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ab79aed725b28eb22471a8b6733405843">VSIInstallSparseFileHandler</a> (void)</td></tr>
<tr class="memdesc:ab79aed725b28eb22471a8b6733405843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsisparse/ virtual file handler.  <a href="cpl__vsi_8h.html#ab79aed725b28eb22471a8b6733405843">More...</a><br /></td></tr>
<tr class="separator:ab79aed725b28eb22471a8b6733405843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dd983338849e7da4eaa88f6458ab64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64">VSIInstallTarFileHandler</a> (void)</td></tr>
<tr class="memdesc:ad6dd983338849e7da4eaa88f6458ab64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsitar/ file system handler.  <a href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64">More...</a><br /></td></tr>
<tr class="separator:ad6dd983338849e7da4eaa88f6458ab64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f6ee32e8e7ae962fb93889b6e9f0de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a10f6ee32e8e7ae962fb93889b6e9f0de">VSIInstallCachedFileHandler</a> (void)</td></tr>
<tr class="memdesc:a10f6ee32e8e7ae962fb93889b6e9f0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsicached? file system handler.  <a href="cpl__vsi_8h.html#a10f6ee32e8e7ae962fb93889b6e9f0de">More...</a><br /></td></tr>
<tr class="separator:a10f6ee32e8e7ae962fb93889b6e9f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e20b79947f58970f5514b3eb9a524a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a5e20b79947f58970f5514b3eb9a524a9">VSIInstallCryptFileHandler</a> (void)</td></tr>
<tr class="memdesc:a5e20b79947f58970f5514b3eb9a524a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install /vsicrypt/ encrypted file system handler (requires <a href="http://www.cryptopp.com/">libcrypto++</a>)  <a href="cpl__vsi_8h.html#a5e20b79947f58970f5514b3eb9a524a9">More...</a><br /></td></tr>
<tr class="separator:a5e20b79947f58970f5514b3eb9a524a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619a6f6758371a39e0c1a4168462452c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c">VSISetCryptKey</a> (const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyKey, int nKeySize)</td></tr>
<tr class="memdesc:a619a6f6758371a39e0c1a4168462452c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the encryption/decryption key.  <a href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c">More...</a><br /></td></tr>
<tr class="separator:a619a6f6758371a39e0c1a4168462452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60410259e9a7a40b5c9e99881927d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#ac60410259e9a7a40b5c9e99881927d62">VSIDuplicateFileSystemHandler</a> (const char *pszSourceFSName, const char *pszNewFSName)</td></tr>
<tr class="memdesc:ac60410259e9a7a40b5c9e99881927d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an existing file system handler.  <a href="cpl__vsi_8h.html#ac60410259e9a7a40b5c9e99881927d62">More...</a><br /></td></tr>
<tr class="separator:ac60410259e9a7a40b5c9e99881927d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c1b931449d423e7a80bacb75ff0717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#af9c1b931449d423e7a80bacb75ff0717">VSIFileFromMemBuffer</a> (const char *pszFilename, <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyData, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nDataLength, int bTakeOwnership)</td></tr>
<tr class="memdesc:af9c1b931449d423e7a80bacb75ff0717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create memory "file" from a buffer.  <a href="cpl__vsi_8h.html#af9c1b931449d423e7a80bacb75ff0717">More...</a><br /></td></tr>
<tr class="separator:af9c1b931449d423e7a80bacb75ff0717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf26bcc4a5314371f426bb2a5e6ce7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">VSIGetMemFileBuffer</a> (const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *pnDataLength, int bUnlinkAndSeize)</td></tr>
<tr class="memdesc:aeaf26bcc4a5314371f426bb2a5e6ce7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch buffer underlying memory file.  <a href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">More...</a><br /></td></tr>
<tr class="separator:aeaf26bcc4a5314371f426bb2a5e6ce7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4a67cc303d7662c34f506d0bdddd79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79">VSIStdoutSetRedirection</a> (<a class="el" href="cpl__vsi_8h.html#a121ccf7fcbd054704350f72be08adec8">VSIWriteFunction</a> pFct, FILE *stream)</td></tr>
<tr class="memdesc:adc4a67cc303d7662c34f506d0bdddd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an alternative write function and output file handle instead of fwrite() / stdout.  <a href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79">More...</a><br /></td></tr>
<tr class="separator:adc4a67cc303d7662c34f506d0bdddd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060262f8e9dbe8509bbe535341021750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a060262f8e9dbe8509bbe535341021750">VSIAllocFilesystemPluginCallbacksStruct</a> (void)</td></tr>
<tr class="memdesc:a060262f8e9dbe8509bbe535341021750"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html" title="struct containing callbacks to used by the handler.">VSIFilesystemPluginCallbacksStruct</a> to be populated at runtime with handler callbacks  <a href="cpl__vsi_8h.html#a060262f8e9dbe8509bbe535341021750">More...</a><br /></td></tr>
<tr class="separator:a060262f8e9dbe8509bbe535341021750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463cc08892a277549cff8b1e4fe460a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a463cc08892a277549cff8b1e4fe460a2">VSIFreeFilesystemPluginCallbacksStruct</a> (<a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *poCb)</td></tr>
<tr class="memdesc:a463cc08892a277549cff8b1e4fe460a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">free resources allocated by VSIAllocFilesystemPluginCallbacksStruct  <a href="cpl__vsi_8h.html#a463cc08892a277549cff8b1e4fe460a2">More...</a><br /></td></tr>
<tr class="separator:a463cc08892a277549cff8b1e4fe460a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd74a1b0cad563fe1518660967a673f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a9fd74a1b0cad563fe1518660967a673f">VSIInstallPluginHandler</a> (const char *pszPrefix, const <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *poCb)</td></tr>
<tr class="memdesc:a9fd74a1b0cad563fe1518660967a673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a handler on the given prefix.  <a href="cpl__vsi_8h.html#a9fd74a1b0cad563fe1518660967a673f">More...</a><br /></td></tr>
<tr class="separator:a9fd74a1b0cad563fe1518660967a673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc0473cc58704717095fd5cb6835935"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cpl__vsi_8h.html#a4cc0473cc58704717095fd5cb6835935">VSIRemovePluginHandler</a> (const char *pszPrefix)</td></tr>
<tr class="memdesc:a4cc0473cc58704717095fd5cb6835935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a handler previously installed with <a class="el" href="cpl__vsi_8h.html#a9fd74a1b0cad563fe1518660967a673f" title="register a handler on the given prefix.">VSIInstallPluginHandler()</a> on the given prefix.  <a href="cpl__vsi_8h.html#a4cc0473cc58704717095fd5cb6835935">More...</a><br /></td></tr>
<tr class="separator:a4cc0473cc58704717095fd5cb6835935"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Standard C Covers. </p>
<p>The VSI functions are intended to be hookable aliases for Standard C I/O, memory allocation and other system functions. They are intended to allow virtualization of disk I/O so that non file data sources can be made to appear as files, and so that additional error trapping and reporting can be interested. The memory access API is aliased so that special application memory management services can be used.</p>
<p>It is intended that each of these functions retains exactly the same calling pattern as the original Standard C functions they relate to. This means we don't have to provide custom documentation, and also means that the default implementation is very simple. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7fee943d92d35104c3ccbdc96985fd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fee943d92d35104c3ccbdc96985fd8a">&#9670;&nbsp;</a></span>VSI_STAT_CACHE_ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VSI_STAT_CACHE_ONLY&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag provided to <a class="el" href="cpl__vsi_8h.html#ad1a691db1ba2f43add25a5c0d6498da6" title="Get filesystem object info.">VSIStatExL()</a> to only use already cached results. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4 </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a42e8ffa000d76320d8d4b5c99d0cdfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e8ffa000d76320d8d4b5c99d0cdfc5">&#9670;&nbsp;</a></span>VSIFilesystemPluginAdviseReadCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* VSIFilesystemPluginAdviseReadCallback) (void *pFile, int nRanges, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This optional method is called when code plans to access soon one or several ranges in a file. </p>
<p>Some file systems may be able to use this hint to for example asynchronously start such requests.</p>
<p>Offsets may be given in a non-increasing order, and may potentially overlap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFile</td><td>File handle. </td></tr>
    <tr><td class="paramname">nRanges</td><td>Size of the panOffsets and panSizes arrays. </td></tr>
    <tr><td class="paramname">panOffsets</td><td>Array containing the start offset of each range. </td></tr>
    <tr><td class="paramname">panSizes</td><td>Array containing the size (in bytes) of each range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a9e6c073bbfa87f66db171a363c9e69db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6c073bbfa87f66db171a363c9e69db">&#9670;&nbsp;</a></span>VSIFilesystemPluginClearErrCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* VSIFilesystemPluginClearErrCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear error and end-of-file flags. </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

</div>
</div>
<a id="a6a9c46d54ad75e6914322a84ced153f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9c46d54ad75e6914322a84ced153f5">&#9670;&nbsp;</a></span>VSIFilesystemPluginCloseCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginCloseCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close file handle. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="acff9cabb436bd411346471369bee545d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff9cabb436bd411346471369bee545d">&#9670;&nbsp;</a></span>VSIFilesystemPluginEofCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginEofCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has end of file been reached. </p>
<p>Mandatory? for read handles. </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="af90944c54a489fa5778863d5d1c26c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90944c54a489fa5778863d5d1c26c61">&#9670;&nbsp;</a></span>VSIFilesystemPluginErrorCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginErrorCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has a read error (non end-of-file related) has occurred? </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

</div>
</div>
<a id="aed880694c27b9f94fd619c6ba81bf3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed880694c27b9f94fd619c6ba81bf3fe">&#9670;&nbsp;</a></span>VSIFilesystemPluginFlushCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginFlushCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync written bytes. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a8adeb34e38b0bd646643e18d016fe47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adeb34e38b0bd646643e18d016fe47d">&#9670;&nbsp;</a></span>VSIFilesystemPluginGetRangeStatusCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a>(* VSIFilesystemPluginGetRangeStatusCallback) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nLength)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get empty ranges. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a6f54d817dbcfce03ce9610f3bc76185b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f54d817dbcfce03ce9610f3bc76185b">&#9670;&nbsp;</a></span>VSIFilesystemPluginMkdirCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginMkdirCallback) (void *pUserData, const char *pszDirname, long nMode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Directory. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a5fb10302b47889ece6b19479a81f05bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb10302b47889ece6b19479a81f05bc">&#9670;&nbsp;</a></span>VSIFilesystemPluginOpenCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* VSIFilesystemPluginOpenCallback) (void *pUserData, const char *pszFilename, const char *pszAccess)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a handle. </p>
<p>Mandatory. Returns an opaque pointer that will be used in subsequent file I/O calls. Should return null and/or set errno if the handle does not exist or the access mode is incorrect. </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a2bb9bc1c9e4faa76fe1395c5a2ecfc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb9bc1c9e4faa76fe1395c5a2ecfc13">&#9670;&nbsp;</a></span>VSIFilesystemPluginReadCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* VSIFilesystemPluginReadCallback) (void *pFile, void *pBuffer, size_t nSize, size_t nCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from current position, returns the number of blocks correctly read. </p>
<p>Mandatory except for write only handles </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a5375b18a338bd51e92e3496d23e7c491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5375b18a338bd51e92e3496d23e7c491">&#9670;&nbsp;</a></span>VSIFilesystemPluginReadDirCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char**(* VSIFilesystemPluginReadDirCallback) (void *pUserData, const char *pszDirname, int nMaxFiles)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List directory content. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a2253223aadc64bea6904fd485eede527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2253223aadc64bea6904fd485eede527">&#9670;&nbsp;</a></span>VSIFilesystemPluginReadMultiRangeCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginReadMultiRangeCallback) (void *pFile, int nRanges, void **ppData, const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *panOffsets, const size_t *panSizes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from multiple offsets. </p>
<p>Optional, will be replaced by multiple calls to Read() if not provided </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a46d7066fe0aadaab4d2be154c100a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d7066fe0aadaab4d2be154c100a1b2">&#9670;&nbsp;</a></span>VSIFilesystemPluginRenameCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginRenameCallback) (void *pUserData, const char *oldpath, const char *newpath)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename handle. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="afdedd1069c545b7fe216a209fd6767a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdedd1069c545b7fe216a209fd6767a3">&#9670;&nbsp;</a></span>VSIFilesystemPluginRmdirCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginRmdirCallback) (void *pUserData, const char *pszDirname)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete Directory. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a93db78968a0bc9d5b859a5f1ab9d579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93db78968a0bc9d5b859a5f1ab9d579d">&#9670;&nbsp;</a></span>VSIFilesystemPluginSeekCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginSeekCallback) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nOffset, int nWhence)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to position in handle. </p>
<p>Mandatory except for write only handles </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="ad4f067064f3f728ae2404e1c5eab5004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f067064f3f728ae2404e1c5eab5004">&#9670;&nbsp;</a></span>VSIFilesystemPluginSiblingFilesCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char**(* VSIFilesystemPluginSiblingFilesCallback) (void *pUserData, const char *pszDirname)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List related files. </p>
<p>Must return NULL if unknown, or a list of relative filenames that can be opened along the main file. If no other file than pszFilename needs to be opened, return static_cast&lt;char**&gt; (CPLCalloc(1,sizeof(char*)));</p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="a94d3d7c93b141ad3947a696dd298781a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d3d7c93b141ad3947a696dd298781a">&#9670;&nbsp;</a></span>VSIFilesystemPluginStatCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginStatCallback) (void *pUserData, const char *pszFilename, <a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *pStatBuf, int nFlags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about a handle. </p>
<p>Optional (driver dependent) </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a3522495c9dd6b480828847e06f573781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3522495c9dd6b480828847e06f573781">&#9670;&nbsp;</a></span>VSIFilesystemPluginTellCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>(* VSIFilesystemPluginTellCallback) (void *pFile)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return current position in handle. </p>
<p>Mandatory </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a700c550a3f060ef72be35a639fa67775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700c550a3f060ef72be35a639fa67775">&#9670;&nbsp;</a></span>VSIFilesystemPluginTruncateCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginTruncateCallback) (void *pFile, <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nNewSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate handle. </p>
<p>Mandatory (driver dependent?) for write handles </p>

</div>
</div>
<a id="abfad10f0726010c7b046b2a9153e496b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfad10f0726010c7b046b2a9153e496b">&#9670;&nbsp;</a></span>VSIFilesystemPluginUnlinkCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* VSIFilesystemPluginUnlinkCallback) (void *pUserData, const char *pszFilename)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove handle by name. </p>
<p>Optional </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a7bb9cabc545c740a05dfe0dc2c237834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb9cabc545c740a05dfe0dc2c237834">&#9670;&nbsp;</a></span>VSIFilesystemPluginWriteCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* VSIFilesystemPluginWriteCallback) (void *pFile, const void *pBuffer, size_t nSize, size_t nCount)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes at current offset. </p>
<p>Mandatory for writable handles </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2aa5b80209e71d81a118d647c6a9be66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa5b80209e71d81a118d647c6a9be66">&#9670;&nbsp;</a></span>VSIRangeStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2aa5b80209e71d81a118d647c6a9be66a68ea00493f4c073e19da9613d1d3d630"></a>VSI_RANGE_STATUS_UNKNOWN&#160;</td><td class="fielddoc"><p>Unknown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aa5b80209e71d81a118d647c6a9be66a20f1d70259ba20c9c8767fed7b0a7119"></a>VSI_RANGE_STATUS_DATA&#160;</td><td class="fielddoc"><p>Data present. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2aa5b80209e71d81a118d647c6a9be66a4518228a517000ca00f132bc67ac6dc7"></a>VSI_RANGE_STATUS_HOLE&#160;</td><td class="fielddoc"><p>Hole. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2ef39609553f41d5cb5078302c4b3de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef39609553f41d5cb5078302c4b3de2">&#9670;&nbsp;</a></span>CPLGetPhysicalRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> CPLGetPhysicalRAM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total physical RAM in bytes. </p>
<p>In the context of a container using cgroups (typically Docker), this will take into account that limitation (starting with GDAL 2.4.0 and with extra fixes in GDAL 3.6.3)</p>
<p>You should generally use <a class="el" href="cpl__vsi_8h.html#ac6eef6b11f21ea4d5c27a62ac265818a" title="Return the total physical RAM, usable by a process, in bytes.">CPLGetUsablePhysicalRAM()</a> instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the total physical RAM in bytes (or 0 in case of failure). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac6eef6b11f21ea4d5c27a62ac265818a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eef6b11f21ea4d5c27a62ac265818a">&#9670;&nbsp;</a></span>CPLGetUsablePhysicalRAM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> CPLGetUsablePhysicalRAM </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total physical RAM, usable by a process, in bytes. </p>
<p>This is the same as <a class="el" href="cpl__vsi_8h.html#a2ef39609553f41d5cb5078302c4b3de2" title="Return the total physical RAM in bytes.">CPLGetPhysicalRAM()</a> except it will limit to 2 GB for 32 bit processes.</p>
<p>Starting with GDAL 2.4.0, it will also take account resource limits (virtual memory) on Posix systems. Starting with GDAL 3.6.1, it will also take into account RLIMIT_RSS on Linux.</p>
<p>Note: This memory may already be partly used by other processes.</p>
<dl class="section return"><dt>Returns</dt><dd>the total physical RAM, usable by a process, in bytes (or 0 in case of failure). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="adbf0d1fa9f93e17738fba3912f010c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf0d1fa9f93e17738fba3912f010c81">&#9670;&nbsp;</a></span>VSIAbortPendingUploads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIAbortPendingUploads </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort all ongoing multi-part uploads. </p>
<p>Abort ongoing multi-part uploads on AWS S3 and Google Cloud Storage. This can be used in case a process doing such uploads was killed in a unclean way.</p>
<p>This can be needed to avoid extra billing for some cloud storage providers.</p>
<p>Without effect on other virtual file systems.</p>
<p><a class="el" href="cpl__vsi_8h.html#a6e724523119104cbf8468a12ff4c5744" title="Aborts a multi-part file upload.">VSIMultipartUploadAbort()</a> can also be used to cancel a given upload, if the upload ID is known.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>filename or prefix of a directory into which multipart uploads must be aborted. This can be the root directory of a bucket. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4 </dd></dl>

</div>
</div>
<a id="a060262f8e9dbe8509bbe535341021750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060262f8e9dbe8509bbe535341021750">&#9670;&nbsp;</a></span>VSIAllocFilesystemPluginCallbacksStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a>* VSIAllocFilesystemPluginCallbacksStruct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html" title="struct containing callbacks to used by the handler.">VSIFilesystemPluginCallbacksStruct</a> to be populated at runtime with handler callbacks </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a35d73f4aa771b0c6299fea4ab41959a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d73f4aa771b0c6299fea4ab41959a3">&#9670;&nbsp;</a></span>VSICalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSICalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of calloc(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> to free </p>

</div>
</div>
<a id="a949779115e8e9d865a5bfe4acf2b8aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949779115e8e9d865a5bfe4acf2b8aad">&#9670;&nbsp;</a></span>VSIClearCredentials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIClearCredentials </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathPrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear path specific options set with <a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a> </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>in GDAL 3.6 for the better named <a class="el" href="cpl__vsi_8h.html#af52959eb86a4f6f6f4034da55b82d480" title="Clear path specific options set with VSISetPathSpecificOption()">VSIClearPathSpecificOptions()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#af52959eb86a4f6f6f4034da55b82d480" title="Clear path specific options set with VSISetPathSpecificOption()">VSIClearPathSpecificOptions()</a> </dd></dl>

</div>
</div>
<a id="af52959eb86a4f6f6f4034da55b82d480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52959eb86a4f6f6f4034da55b82d480">&#9670;&nbsp;</a></span>VSIClearPathSpecificOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIClearPathSpecificOptions </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathPrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear path specific options set with <a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a> </p>
<p>Note that no particular care is taken to remove them from RAM in a secure way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathPrefix</td><td>If set to NULL, all path specific options are cleared. If set to not-NULL, only those set with VSISetPathSpecificOption(pszPathPrefix, ...) will be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a7e7448bda4230b3d8133a59027c5f02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7448bda4230b3d8133a59027c5f02f">&#9670;&nbsp;</a></span>VSICloseDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSICloseDir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a directory. </p>
<p>This function is close to the POSIX closedir() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Directory handled returned by <a class="el" href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90" title="Open a directory to read its entries.">VSIOpenDir()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a2931707253132f6f2628be50e9e6db59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2931707253132f6f2628be50e9e6db59">&#9670;&nbsp;</a></span>VSICopyFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSICopyFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fpSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nSourceSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pProgressFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a source file into a target file. </p>
<p>For a /vsizip/foo.zip/bar target, the options available are those of <a class="el" href="cpl__conv_8h.html#a42a6fd38f14a41bd51f6ca7f80aa78b2" title="Add a file inside a ZIP file opened/created with CPLCreateZip().">CPLAddFileInZip()</a></p>
<p>The following copies are made fully on the target server, without local download from source and upload to target:</p><ul>
<li>/vsis3/ -&gt; /vsis3/</li>
<li>/vsigs/ -&gt; /vsigs/</li>
<li>/vsiaz/ -&gt; /vsiaz/</li>
<li>/vsiadls/ -&gt; /vsiadls/</li>
<li>any of the above or /vsicurl/ -&gt; /vsiaz/ (starting with GDAL 3.8)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSource</td><td>Source filename. UTF-8 encoded. May be NULL if fpSource is not NULL. </td></tr>
    <tr><td class="paramname">pszTarget</td><td>Target filename. UTF-8 encoded. Must not be NULL </td></tr>
    <tr><td class="paramname">fpSource</td><td>File handle on the source file. May be NULL if pszSource is not NULL. </td></tr>
    <tr><td class="paramname">nSourceSize</td><td>Size of the source file. Pass -1 if unknown. If set to -1, and progress callback is used, <a class="el" href="cpl__vsi_8h.html#ac92fbd5e6fc143b026001b32c4c19ed1" title="Get filesystem object info.">VSIStatL()</a> will be used on pszSource to retrieve the source size. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Null terminated list of options, or NULL. </td></tr>
    <tr><td class="paramname">pProgressFunc</td><td>Progress callback, or NULL. </td></tr>
    <tr><td class="paramname">pProgressData</td><td>User data of progress callback, or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="aca75ed325440d598169cd486e171e7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca75ed325440d598169cd486e171e7cf">&#9670;&nbsp;</a></span>VSICopyFileRestartable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSICopyFileRestartable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszInputPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszOutputPayload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pProgressFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a source file into a target file in a way that can (potentially) be restarted. </p>
<p>This function provides the possibility of efficiently restarting upload of large files to cloud storage that implements upload in a chunked way, such as /vsis3/ and /vsigs/. For other destination file systems, this function may fallback to <a class="el" href="cpl__vsi_8h.html#a2931707253132f6f2628be50e9e6db59" title="Copy a source file into a target file.">VSICopyFile()</a> and not provide any smart restartable implementation.</p>
<p>Example of a potential workflow:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>* pszOutputPayload = NULL;</div>
<div class="line"><span class="keywordtype">int</span> ret = <a class="code" href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf">VSICopyFileRestartable</a>(pszSource, pszTarget, NULL,</div>
<div class="line">                                 &amp;pszOutputPayload, NULL, NULL, NULL);</div>
<div class="line"><span class="keywordflow">while</span>( ret == 1 ) <span class="comment">// add also a limiting counter to avoid potentiall endless looping</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// TODO: wait for some time</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">char</span>* pszOutputPayloadNew = NULL;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* pszInputPayload = pszOutputPayload;</div>
<div class="line">    ret = <a class="code" href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf">VSICopyFileRestartable</a>(pszSource, pszTarget, pszInputPayload,</div>
<div class="line">                                 &amp;pszOutputPayloadNew, NULL, NULL, NULL);</div>
<div class="line">    <a class="code" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab">VSIFree</a>(pszOutputPayload);</div>
<div class="line">    pszOutputPayload = pszOutputPayloadNew;</div>
<div class="line">}</div>
<div class="line"><a class="code" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab">VSIFree</a>(pszOutputPayload);</div>
<div class="ttc" id="acpl__vsi_8h_html_aca75ed325440d598169cd486e171e7cf"><div class="ttname"><a href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf">VSICopyFileRestartable</a></div><div class="ttdeci">int VSICopyFileRestartable(const char *pszSource, const char *pszTarget, const char *pszInputPayload, char **ppszOutputPayload, const char *const *papszOptions, GDALProgressFunc pProgressFunc, void *pProgressData)</div><div class="ttdoc">Copy a source file into a target file in a way that can (potentially) be restarted.</div><div class="ttdef"><b>Definition:</b> cpl_vsil.cpp:660</div></div>
<div class="ttc" id="acpl__vsi_8h_html_af26e15498e19c2a8169db924415ff7ab"><div class="ttname"><a href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab">VSIFree</a></div><div class="ttdeci">void VSIFree(void *)</div><div class="ttdoc">Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()</div><div class="ttdef"><b>Definition:</b> cpl_vsisimple.cpp:843</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pszSource</td><td>Source filename. UTF-8 encoded. Must not be NULL </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pszTarget</td><td>Target filename. UTF-8 encoded. Must not be NULL </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pszInputPayload</td><td>NULL at the first invocation. When doing a retry, should be the content of *ppszOutputPayload from a previous invocation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppszOutputPayload</td><td>Pointer to an output string that will be set to a value that can be provided as pszInputPayload for a next call to <a class="el" href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf" title="Copy a source file into a target file in a way that can (potentially) be restarted.">VSICopyFileRestartable()</a>. ppszOutputPayload must not be NULL. The string set in *ppszOutputPayload, if not NULL, is JSON-encoded, and can be re-used in another process instance. It must be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> when no longer needed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">papszOptions</td><td>Null terminated list of options, or NULL. Currently accepted options are: <ul>
<li>
NUM_THREADS=integer or ALL_CPUS. Number of threads to use for parallel file copying. Only use for when /vsis3/, /vsigs/, /vsiaz/ or /vsiadls/ is in source or target. The default is 10.  </li>
<li>
CHUNK_SIZE=integer. Maximum size of chunk (in bytes) to use to split large objects. For upload to /vsis3/, this chunk size must be set at least to 5 MB. The default is 50 MB.  </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pProgressFunc</td><td>Progress callback, or NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pProgressData</td><td>User data of progress callback, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on (non-restartable) failure, 1 if <a class="el" href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf" title="Copy a source file into a target file in a way that can (potentially) be restarted.">VSICopyFileRestartable()</a> can be called again in a restartable way </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#adbf0d1fa9f93e17738fba3912f010c81" title="Abort all ongoing multi-part uploads.">VSIAbortPendingUploads()</a> </dd></dl>

</div>
</div>
<a id="a6b22260317edc475793c4165957742b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b22260317edc475793c4165957742b6">&#9670;&nbsp;</a></span>VSICurlClearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSICurlClearCache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean local cache associated with /vsicurl/ (and related file systems) </p>
<p>/vsicurl (and related file systems like /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiswift/) cache a number of metadata and data for faster execution in read-only scenarios. But when the content on the server-side may change during the same process, those mechanisms can prevent opening new files, or give an outdated version of them.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2.1 </dd></dl>

</div>
</div>
<a id="a6bc83d16f0f279f601059a218ad2c55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc83d16f0f279f601059a218ad2c55c">&#9670;&nbsp;</a></span>VSICurlPartialClearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSICurlPartialClearCache </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilenamePrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean local cache associated with /vsicurl/ (and related file systems) for a given filename (and its subfiles and subdirectories if it is a directory) </p>
<p>/vsicurl (and related file systems like /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiswift/) cache a number of metadata and data for faster execution in read-only scenarios. But when the content on the server-side may change during the same process, those mechanisms can prevent opening new files, or give an outdated version of them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilenamePrefix</td><td>Filename prefix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4.0 </dd></dl>

</div>
</div>
<a id="ac60410259e9a7a40b5c9e99881927d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60410259e9a7a40b5c9e99881927d62">&#9670;&nbsp;</a></span>VSIDuplicateFileSystemHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VSIDuplicateFileSystemHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSourceFSName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewFSName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an existing file system handler. </p>
<p>A number of virtual file system for remote object stores use protocols identical or close to popular ones (typically AWS S3), but with slightly different settings (at the very least the endpoint).</p>
<p>This functions allows to duplicate the source virtual file system handler as a new one with a different prefix (when the source virtual file system handler supports the duplication operation).</p>
<p><a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a> will typically be called afterwards to change configurable settings on the cloned file system handler (e.g. AWS_S3_ENDPOINT for a clone of /vsis3/).</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a401e381ab9b3c6019876e9305151b00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401e381ab9b3c6019876e9305151b00d">&#9670;&nbsp;</a></span>VSIFClearErrL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIFClearErrL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the error and end-of-file indicators. </p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX clearerr() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="a82fe6612261c1948eee388e75b7d6db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fe6612261c1948eee388e75b7d6db7">&#9670;&nbsp;</a></span>VSIFCloseL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFCloseL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close file. </p>
<p>This function closes the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fclose() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. Passing a nullptr produces undefined behavior.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ab72b69150d9dd7adb6e756196867a9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72b69150d9dd7adb6e756196867a9b2">&#9670;&nbsp;</a></span>VSIFEofL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFEofL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for end of file. </p>
<p>Returns TRUE (non-zero) if an end-of-file condition occurred during the previous read operation. The end-of-file flag is cleared by a successful <a class="el" href="cpl__vsi_8h.html#aeac1c2bc2d4dac71e504f62be5c564f3" title="Seek to requested offset.">VSIFSeekL()</a> call, or a call to <a class="el" href="cpl__vsi_8h.html#a401e381ab9b3c6019876e9305151b00d" title="Reset the error and end-of-file indicators.">VSIFClearErrL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX feof() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if at EOF, else FALSE. </dd></dl>

</div>
</div>
<a id="a55b7a7ffb058c8fab7525b604b5df577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b7a7ffb058c8fab7525b604b5df577">&#9670;&nbsp;</a></span>VSIFErrorL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFErrorL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the error indicator. </p>
<p>Returns TRUE (non-zero) if an error condition occurred during the previous read operation. The error indicator is cleared by a call to <a class="el" href="cpl__vsi_8h.html#a401e381ab9b3c6019876e9305151b00d" title="Reset the error and end-of-file indicators.">VSIFClearErrL()</a>. Note that a end-of-file situation, reported by <a class="el" href="cpl__vsi_8h.html#ab72b69150d9dd7adb6e756196867a9b2" title="Test for end of file.">VSIFEofL()</a>, is <em>not</em> an error reported by <a class="el" href="cpl__vsi_8h.html#a55b7a7ffb058c8fab7525b604b5df577" title="Test the error indicator.">VSIFErrorL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX feof() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the error indicator is set, else FALSE. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="a224b7e3c50275ae1924e89185df5494d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224b7e3c50275ae1924e89185df5494d">&#9670;&nbsp;</a></span>VSIFFlushL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFFlushL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending writes to disk. </p>
<p>For files in write or update mode and on filesystem types where it is applicable, all pending output on the file is flushed to the physical disk.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fflush() call.</p>
<p>On Windows regular files, this method does nothing, unless the VSI_FLUSH configuration option is set to YES (and only when the file has <em>not</em> been opened with the WRITE_THROUGH option).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error. </dd></dl>

</div>
</div>
<a id="a41fd7388a7491b3430d0abe961dada82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fd7388a7491b3430d0abe961dada82">&#9670;&nbsp;</a></span>VSIFGetNativeFileDescriptorL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIFGetNativeFileDescriptorL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the "native" file descriptor for the virtual handle. </p>
<p>This will only return a non-NULL value for "real" files handled by the operating system (to be opposed to GDAL virtual file systems).</p>
<p>On POSIX systems, this will be a integer value ("fd") cast as a void*. On Windows systems, this will be the HANDLE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the native file descriptor, or NULL. </dd></dl>

</div>
</div>
<a id="a0e748fc4b8a074da08095bd91fff8fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e748fc4b8a074da08095bd91fff8fed">&#9670;&nbsp;</a></span>VSIFGetRangeStatusL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a2aa5b80209e71d81a118d647c6a9be66">VSIRangeStatus</a> VSIFGetRangeStatusL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if a given file range contains data or holes filled with zeroes. </p>
<p>This uses the filesystem capabilities of querying which regions of a sparse file are allocated or not. This is currently only implemented for Linux (and no other Unix derivatives) and Windows.</p>
<p>Note: A return of VSI_RANGE_STATUS_DATA doesn't exclude that the extent is filled with zeroes! It must be interpreted as "may
contain non-zero data".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset of the start of the extent. </td></tr>
    <tr><td class="paramname">nLength</td><td>extent length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>extent status: VSI_RANGE_STATUS_UNKNOWN, VSI_RANGE_STATUS_DATA or VSI_RANGE_STATUS_HOLE </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="af9c1b931449d423e7a80bacb75ff0717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c1b931449d423e7a80bacb75ff0717">&#9670;&nbsp;</a></span>VSIFileFromMemBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a>* VSIFileFromMemBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bTakeOwnership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create memory "file" from a buffer. </p>
<p>A virtual memory file is created from the passed buffer with the indicated filename. Under normal conditions the filename would need to be absolute and within the /vsimem/ portion of the filesystem. Starting with GDAL 3.6, nullptr can also be passed as pszFilename to mean an anonymous file, that is destroyed when the handle is closed.</p>
<p>If bTakeOwnership is TRUE, then the memory file system handler will take ownership of the buffer, freeing it when the file is deleted. Otherwise it remains the responsibility of the caller, but should not be freed as long as it might be accessed as a file. In no circumstances does this function take a copy of the pabyData contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the filename to be created, or nullptr </td></tr>
    <tr><td class="paramname">pabyData</td><td>the data buffer for the file. </td></tr>
    <tr><td class="paramname">nDataLength</td><td>the length of buffer in bytes. </td></tr>
    <tr><td class="paramname">bTakeOwnership</td><td>TRUE to transfer "ownership" of buffer or FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>open file handle on created file (see <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>). </dd></dl>

</div>
</div>
<a id="ae178578975a632abe5e4d598e0b5fb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae178578975a632abe5e4d598e0b5fb79">&#9670;&nbsp;</a></span>VSIFOpenEx2L()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a>* VSIFOpenEx2L </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bSetError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open/create file. </p>
<p>This function opens (or creates) a file with the desired access. Binary access is always implied and the "b" does not need to be included in the pszAccess string.</p>
<p>Note that the "VSILFILE *" returned by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the "VSI*L" family of functions. They aren't "real" FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>The following options are supported: </p><ul>
<li>
MIME headers such as Content-Type and Content-Encoding are supported for the /vsis3/, /vsigs/, /vsiaz/, /vsiadls/ file systems. </li>
<li>
DISABLE_READDIR_ON_OPEN=YES/NO (GDAL &gt;= 3.6) for /vsicurl/ and other network-based file systems. By default, directory file listing is done, unless YES is specified. </li>
<li>
WRITE_THROUGH=YES (GDAL &gt;= 3.8) for the Windows regular files to set the FILE_FLAG_WRITE_THROUGH flag to the CreateFile() function. In that mode, the data is written to the system cache but is flushed to disk without delay. </li>
</ul>
<p>Options specifics to /vsis3/, /vsigs/, /vsioss/ and /vsiaz/ in "w" mode: </p><ul>
<li>
CHUNK_SIZE=val in MiB. (GDAL &gt;= 3.10) Size of a block. Default is 50 MiB. For /vsis3/, /vsigz/, /vsioss/, it can be up to 5000 MiB. For /vsiaz/, only taken into account when BLOB_TYPE=BLOCK. It can be up to 4000 MiB.  </li>
</ul>
<p>Options specifics to /vsiaz/ in "w" mode: </p><ul>
<li>
BLOB_TYPE=APPEND/BLOCK. (GDAL &gt;= 3.10) Type of blob. Defaults to APPEND. Append blocks are limited to 195 GiB (however if the file size is below 4 MiB, a block blob will be created in a single PUT operation)  </li>
</ul>
<p>Analog of the POSIX fopen() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the file to open. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszAccess</td><td>access requested (i.e. "r", "r+", "w") </td></tr>
    <tr><td class="paramname">bSetError</td><td>flag determining whether or not this open call should set VSIErrors on failure. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL or NULL-terminated list of strings. The content is highly file system dependent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, or the file handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="ae516076358c7d9af4e84340433a4f4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae516076358c7d9af4e84340433a4f4da">&#9670;&nbsp;</a></span>VSIFOpenExL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a>* VSIFOpenExL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bSetError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open/create file. </p>
<p>This function opens (or creates) a file with the desired access. Binary access is always implied and the "b" does not need to be included in the pszAccess string.</p>
<p>Note that the "VSILFILE *" returned by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the "VSI*L" family of functions. They aren't "real" FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the file to open. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszAccess</td><td>access requested (i.e. "r", "r+", "w") </td></tr>
    <tr><td class="paramname">bSetError</td><td>flag determining whether or not this open call should set VSIErrors on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, or the file handle.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ad487ad46f2841815f331292051192d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad487ad46f2841815f331292051192d5f">&#9670;&nbsp;</a></span>VSIFOpenL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a>* VSIFOpenL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file. </p>
<p>This function opens a file with the desired access. Large files (larger than 2GB) should be supported. Binary access is always implied and the "b" does not need to be included in the pszAccess string.</p>
<p>Note that the "VSILFILE *" returned since GDAL 1.8.0 by this function is <em>NOT</em> a standard C library FILE *, and cannot be used with any functions other than the "VSI*L" family of functions. They aren't "real" FILE objects.</p>
<p>On windows it is possible to define the configuration option GDAL_FILE_IS_UTF8 to have pszFilename treated as being in the local encoding instead of UTF-8, restoring the pre-1.8.0 behavior of <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fopen() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the file to open. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszAccess</td><td>access requested (i.e. "r", "r+", "w")</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, or the file handle. </dd></dl>

</div>
</div>
<a id="ad19d593846fa567ada334b12a7bf8a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19d593846fa567ada334b12a7bf8a3b">&#9670;&nbsp;</a></span>VSIFPrintfL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFPrintfL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formatted write to file. </p>
<p>Provides fprintf() style formatted output to a VSI*L file. This formats an internal buffer which is written using <a class="el" href="cpl__vsi_8h.html#a2a382b55d461f4979f523e8c6e257ada" title="Write bytes to file.">VSIFWriteL()</a>.</p>
<p>Analog of the POSIX fprintf() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">pszFormat</td><td>the printf() style format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written or -1 on an error. </dd></dl>

</div>
</div>
<a id="a6765447625c67466595e410519586fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6765447625c67466595e410519586fb7">&#9670;&nbsp;</a></span>VSIFPutcL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFPutcL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single byte to the file. </p>
<p>Writes the character nChar, cast to an unsigned char, to file.</p>
<p>Almost an analog of the POSIX fputc() call, except that it returns the number of character written (1 or 0), and not the (cast) character itself or EOF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nChar</td><td>character to write. </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 in case of success, 0 on error. </dd></dl>

</div>
</div>
<a id="aaddb197f5fb0d431a565b89281d42d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddb197f5fb0d431a565b89281d42d93">&#9670;&nbsp;</a></span>VSIFReadL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VSIFReadL </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bytes from file. </p>
<p>Reads nCount objects of nSize bytes from the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fread() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>the buffer into which the data should be read (at least nCount * nSize bytes in size. </td></tr>
    <tr><td class="paramname">nSize</td><td>size of objects to read in bytes. </td></tr>
    <tr><td class="paramname">nCount</td><td>number of objects to read. </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects successfully read. If that number is less than nCount, <a class="el" href="cpl__vsi_8h.html#ab72b69150d9dd7adb6e756196867a9b2" title="Test for end of file.">VSIFEofL()</a> or <a class="el" href="cpl__vsi_8h.html#a55b7a7ffb058c8fab7525b604b5df577" title="Test the error indicator.">VSIFErrorL()</a> can be used to determine the reason for the short read. </dd></dl>

</div>
</div>
<a id="aaeb325d9dcb43c16a3fa1592ed7c1d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb325d9dcb43c16a3fa1592ed7c1d2b">&#9670;&nbsp;</a></span>VSIFReadMultiRangeL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFReadMultiRangeL </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ppData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *&#160;</td>
          <td class="paramname"><em>panOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>panSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read several ranges of bytes from file. </p>
<p>Reads nRanges objects of panSizes[i] bytes from the indicated file at the offset panOffsets[i] into the buffer ppData[i].</p>
<p>Ranges must be sorted in ascending start offset, and must not overlap each other.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory or /vsicurl/.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nRanges</td><td>number of ranges to read. </td></tr>
    <tr><td class="paramname">ppData</td><td>array of nRanges buffer into which the data should be read (ppData[i] must be at list panSizes[i] bytes). </td></tr>
    <tr><td class="paramname">panOffsets</td><td>array of nRanges offsets at which the data should be read. </td></tr>
    <tr><td class="paramname">panSizes</td><td>array of nRanges sizes of objects to read (in bytes). </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, -1 otherwise. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="ad8fc84461d6ad10524a64ead6af56e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fc84461d6ad10524a64ead6af56e33">&#9670;&nbsp;</a></span>VSIFreeAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIFreeAligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a buffer allocated with <a class="el" href="cpl__vsi_8h.html#ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1" title="Allocates a buffer with an alignment constraint.">VSIMallocAligned()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a463cc08892a277549cff8b1e4fe460a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463cc08892a277549cff8b1e4fe460a2">&#9670;&nbsp;</a></span>VSIFreeFilesystemPluginCallbacksStruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIFreeFilesystemPluginCallbacksStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *&#160;</td>
          <td class="paramname"><em>poCb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free resources allocated by VSIAllocFilesystemPluginCallbacksStruct </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="aeac1c2bc2d4dac71e504f62be5c564f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac1c2bc2d4dac71e504f62be5c564f3">&#9670;&nbsp;</a></span>VSIFSeekL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFSeekL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nWhence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek to requested offset. </p>
<p>Seek to the desired offset (nOffset) in the indicated file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fseek() call.</p>
<p>Caution: vsi_l_offset is a unsigned type, so SEEK_CUR can only be used for positive seek. If negative seek is needed, use VSIFSeekL( fp, VSIFTellL(fp) + negative_offset, SEEK_SET ).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nOffset</td><td>offset in bytes. </td></tr>
    <tr><td class="paramname">nWhence</td><td>one of SEEK_SET, SEEK_CUR or SEEK_END.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 one failure. </dd></dl>

</div>
</div>
<a id="a25fe184bb565bbda49965102dbe0ca15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fe184bb565bbda49965102dbe0ca15">&#9670;&nbsp;</a></span>VSIFTellL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> VSIFTellL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell current file offset. </p>
<p>Returns the current file read/write offset in bytes from the beginning of the file.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftell() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>file offset in bytes. </dd></dl>

</div>
</div>
<a id="a3363cbf28c47b5dcadaf0812dd50e6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3363cbf28c47b5dcadaf0812dd50e6b9">&#9670;&nbsp;</a></span>VSIFTruncateL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIFTruncateL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate/expand the file to the specified size. </p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX ftruncate() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">nNewSize</td><td>new size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.9.0 </dd></dl>

</div>
</div>
<a id="a2a382b55d461f4979f523e8c6e257ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a382b55d461f4979f523e8c6e257ada">&#9670;&nbsp;</a></span>VSIFWriteL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t VSIFWriteL </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write bytes to file. </p>
<p>Writes nCount objects of nSize bytes to the indicated file at the current offset into the indicated buffer.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX fwrite() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>the buffer from which the data should be written (at least nCount * nSize bytes in size. </td></tr>
    <tr><td class="paramname">nSize</td><td>size of objects to write in bytes. </td></tr>
    <tr><td class="paramname">nCount</td><td>number of objects to write. </td></tr>
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects successfully written. </dd></dl>

</div>
</div>
<a id="a0cc60b3e3bf1e892313f2abf0bcfaffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc60b3e3bf1e892313f2abf0bcfaffd">&#9670;&nbsp;</a></span>VSIGetActualURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetActualURL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual URL of a supplied filename. </p>
<p>Currently only returns a non-NULL value for network-based virtual file systems. For example "/vsis3/bucket/filename" will be expanded as "https://bucket.s3.amazon.com/filename"</p>
<p>Note that the lifetime of the returned string, is short, and may be invalidated by any following GDAL functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual URL corresponding to the supplied filename, or NULL. Should not be freed.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a76cdb6f0c3f542c94201484008d70a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cdb6f0c3f542c94201484008d70a2a">&#9670;&nbsp;</a></span>VSIGetCanonicalFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIGetCanonicalFilename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical filename. </p>
<p>May be implemented by case-insensitive filesystems (currently Win32 and MacOSX) to return the filename with its actual case (i.e. the one that would be used when listing the content of the directory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>UTF-8 encoded path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 encoded string, to free with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a8958a8fbb353910a75e082efd26e1ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8958a8fbb353910a75e082efd26e1ce7">&#9670;&nbsp;</a></span>VSIGetCredential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetCredential </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of a credential (or more generally an option related to a virtual file system) for a given path. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>in GDAL 3.6 for the better named <a class="el" href="cpl__vsi_8h.html#af40db650bf590c736876183095cef983" title="Get the value a path specific option.">VSIGetPathSpecificOption()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#af40db650bf590c736876183095cef983" title="Get the value a path specific option.">VSIGetPathSpecificOption()</a> </dd></dl>

</div>
</div>
<a id="a35fc9569f61a99e144a5f4e8dc185ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fc9569f61a99e144a5f4e8dc185ad7">&#9670;&nbsp;</a></span>VSIGetDirectorySeparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetDirectorySeparator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the directory separator for the specified path. </p>
<p>Default is forward slash. The only exception currently is the Windows file system which returns anti-slash, unless the specified path is of the form "{drive_letter}:/{rest_of_the_path}".</p>
<dl class="section since"><dt>Since</dt><dd>3.9 </dd></dl>

</div>
</div>
<a id="ad4ae557aaaa4cc249cd97080101a8297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ae557aaaa4cc249cd97080101a8297">&#9670;&nbsp;</a></span>VSIGetDiskFreeSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> VSIGetDiskFreeSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return free disk space available on the filesystem. </p>
<p>This function returns the free disk space available on the filesystem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDirname</td><td>a directory of the filesystem to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The free space in bytes. Or -1 in case of error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="acabfff0f98787365472b7351b8e34907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabfff0f98787365472b7351b8e34907">&#9670;&nbsp;</a></span>VSIGetFileMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIGetFileMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get metadata on files. </p>
<p>Implemented currently only for network-like filesystems, or starting with GDAL 3.7 for /vsizip/</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>Metadata domain to query. Depends on the file system. The following are supported: <ul>
<li>
HEADERS: to get HTTP headers for network-like filesystems (/vsicurl/, /vsis3/, /vsgis/, etc) </li>
<li>
TAGS: <ul>
<li>
/vsis3/: to get S3 Object tagging information </li>
<li>
/vsiaz/: to get blob tags. Refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-tags">https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-tags</a> </li>
</ul>
</li>
<li>
STATUS: specific to /vsiadls/: returns all system defined properties for a path (seems in practice to be a subset of HEADERS) </li>
<li>
ACL: specific to /vsiadls/ and /vsigs/: returns the access control list for a path. For /vsigs/, a single XML=xml_content string is returned. Refer to <a href="https://cloud.google.com/storage/docs/xml-api/get-object-acls">https://cloud.google.com/storage/docs/xml-api/get-object-acls</a>  </li>
<li>
METADATA: specific to /vsiaz/: to set blob metadata. Refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-metadata">https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-metadata</a>. Note: this will be a subset of what pszDomain=HEADERS returns </li>
<li>
ZIP: specific to /vsizip/: to obtain ZIP specific metadata, in particular if a file is SOZIP-enabled (SOZIP_VALID=YES) </li>
</ul>
</td></tr>
    <tr><td class="paramname">papszOptions</td><td>Unused. Should be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a NULL-terminated list of key=value strings, to be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> or NULL in case of error / empty list.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="a85ca54aa40490c9237e9dd2905d9daac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ca54aa40490c9237e9dd2905d9daac">&#9670;&nbsp;</a></span>VSIGetFileSystemOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetFileSystemOptions </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of options associated with a virtual file system handler as a serialized XML string. </p>
<p>Those options may be set as configuration options with <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>a filename, or prefix of a virtual file system handler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string, which must not be freed, or NULL if no options is declared. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="adfb3d5eb0effa7326ca6d3130b60bc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb3d5eb0effa7326ca6d3130b60bc94">&#9670;&nbsp;</a></span>VSIGetFileSystemsPrefixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIGetFileSystemsPrefixes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of prefixes for virtual file system handlers currently registered. </p>
<p>Typically: "", "/vsimem/", "/vsicurl/", etc</p>
<dl class="section return"><dt>Returns</dt><dd>a NULL terminated list of prefixes. Must be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="aeaf26bcc4a5314371f426bb2a5e6ce7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf26bcc4a5314371f426bb2a5e6ce7a">&#9670;&nbsp;</a></span>VSIGetMemFileBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a>* VSIGetMemFileBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *&#160;</td>
          <td class="paramname"><em>pnDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUnlinkAndSeize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch buffer underlying memory file. </p>
<p>This function returns a pointer to the memory buffer underlying a virtual "in memory" file. If bUnlinkAndSeize is TRUE the filesystem object will be deleted, and ownership of the buffer will pass to the caller otherwise the underlying file will remain in existence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the name of the file to grab the buffer of. </td></tr>
    <tr><td class="paramname">pnDataLength</td><td>(file) length returned in this variable. </td></tr>
    <tr><td class="paramname">bUnlinkAndSeize</td><td>TRUE to remove the file, or FALSE to leave unaltered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory buffer or NULL on failure. </dd></dl>

</div>
</div>
<a id="a0ce4131b005b1853a16d4f341d1ba031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce4131b005b1853a16d4f341d1ba031">&#9670;&nbsp;</a></span>VSIGetNextDirEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVSIDIREntry.html">VSIDIREntry</a>* VSIGetNextDirEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a> *&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next entry of the directory. </p>
<p>This function is close to the POSIX readdir() function. It actually returns more information (file size, last modification time), which on 'real' file systems involve one 'stat' call per file.</p>
<p>For filesystems that can have both a regular file and a directory name of the same name (typically /vsis3/), when this situation of duplicate happens, the directory name will be suffixed by a slash character. Otherwise directory names are not suffixed by slash.</p>
<p>The returned entry remains valid until the next call to VSINextDirEntry() or <a class="el" href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f" title="Close a directory.">VSICloseDir()</a> with the same handle.</p>
<p>Note: since GDAL 3.9, for recursive mode, the directory separator will no longer be always forward slash, but will be the one returned by VSIGetDirectorySeparator(pszPathIn), so potentially backslash on Windows file systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Directory handled returned by <a class="el" href="cpl__vsi_8h.html#a186d32d750cca298ea625c00e8be3f90" title="Open a directory to read its entries.">VSIOpenDir()</a>. Must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a entry, or NULL if there is no more entry in the directory. This return value must not be freed. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="af40db650bf590c736876183095cef983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40db650bf590c736876183095cef983">&#9670;&nbsp;</a></span>VSIGetPathSpecificOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* VSIGetPathSpecificOption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value a path specific option. </p>
<p>Such option is typically, but not limited to, a credential setting for a virtual file system.</p>
<p>If no match occurs, CPLGetConfigOption(pszKey, pszDefault) is returned.</p>
<p>Mostly to be used by virtual file system implementations.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a> </dd></dl>

</div>
</div>
<a id="a9b7d8fe76bc6c58fce962424574f0325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7d8fe76bc6c58fce962424574f0325">&#9670;&nbsp;</a></span>VSIGetSignedURL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIGetSignedURL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a signed URL of a supplied filename. </p>
<p>Currently only returns a non-NULL value for /vsis3/, /vsigs/, /vsiaz/ and /vsioss/ For example "/vsis3/bucket/filename" will be expanded as "https://bucket.s3.amazon.com/filename?X-Amz-Algorithm=AWS4-HMAC-SHA256..." Configuration options that apply for file opening (typically to provide credentials), and are returned by <a class="el" href="cpl__vsi_8h.html#a85ca54aa40490c9237e9dd2905d9daac" title="Return the list of options associated with a virtual file system handler as a serialized XML string.">VSIGetFileSystemOptions()</a>, are also valid in that context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>list of options, or NULL. Depend on file system handler. For /vsis3/, /vsigs/, /vsiaz/ and /vsioss/, the following options are supported: <ul>
<li>
START_DATE=YYMMDDTHHMMSSZ: date and time in UTC following ISO 8601 standard, corresponding to the start of validity of the URL. If not specified, current date time. </li>
<li>
EXPIRATION_DELAY=number_of_seconds: number between 1 and 604800 (seven days) for the validity of the signed URL. Defaults to 3600 (one hour) </li>
<li>
VERB=GET/HEAD/DELETE/PUT/POST: HTTP VERB for which the request will be used. Default to GET. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>/vsiaz/ supports additional options: </p><ul>
<li>
SIGNEDIDENTIFIER=value: to relate the given shared access signature to a corresponding stored access policy. </li>
<li>
SIGNEDPERMISSIONS=r|w: permissions associated with the shared access signature. Normally deduced from VERB. </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a signed URL, or NULL. Should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a40f2fd6f6c0676f27eb1bfdec56753a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f2fd6f6c0676f27eb1bfdec56753a9">&#9670;&nbsp;</a></span>VSIHasOptimizedReadMultiRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIHasOptimizedReadMultiRange </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filesystem supports efficient multi-range reading. </p>
<p>Currently only returns TRUE for /vsicurl/ and derived file systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the file system is known to have an efficient multi-range reading.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6c5ab5def482f0efc439162b2896b4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5ab5def482f0efc439162b2896b4ea">&#9670;&nbsp;</a></span>VSIIngestFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIIngestFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> **&#160;</td>
          <td class="paramname"><em>ppabyRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *&#160;</td>
          <td class="paramname"><em>pnSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nMaxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ingest a file into memory. </p>
<p>Read the whole content of a file into a memory buffer.</p>
<p>Either fp or pszFilename can be NULL, but not both at the same time.</p>
<p>If fp is passed non-NULL, it is the responsibility of the caller to close it.</p>
<p>If non-NULL, the returned buffer is guaranteed to be NUL-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>filename. </td></tr>
    <tr><td class="paramname">ppabyRet</td><td>pointer to the target buffer. *ppabyRet must be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> </td></tr>
    <tr><td class="paramname">pnSize</td><td>pointer to variable to store the file size. May be NULL. </td></tr>
    <tr><td class="paramname">nMaxSize</td><td>maximum size of file allowed. If no limit, set to a negative value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="ad7afbe67a242152693eec13b3e15aa74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7afbe67a242152693eec13b3e15aa74">&#9670;&nbsp;</a></span>VSIInstall7zFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstall7zFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsi7z/ 7zip file system handler (requires libarchive) </p>
<pre class="fragment">embed:rst
See :ref:`/vsi7z/ documentation &lt;vsi7z&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="ac645fd873dc52984a5b2bb9e7f1207b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac645fd873dc52984a5b2bb9e7f1207b9">&#9670;&nbsp;</a></span>VSIInstallADLSFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallADLSFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiaz/ Microsoft Azure Data Lake Storage Gen2 file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsiadls/ documentation &lt;vsiadls&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="af1f1bf516788238d7138c879dedd62a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f1bf516788238d7138c879dedd62a4">&#9670;&nbsp;</a></span>VSIInstallAzureFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallAzureFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiaz/ Microsoft Azure Blob file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsiaz/ documentation &lt;vsiaz&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="af913ec753ebec2261f0420e8989dd6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af913ec753ebec2261f0420e8989dd6dd">&#9670;&nbsp;</a></span>VSIInstallAzureStreamingFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallAzureStreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiaz_streaming/ Microsoft Azure Blob file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsiaz_streaming/ documentation &lt;vsiaz_streaming&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a10f6ee32e8e7ae962fb93889b6e9f0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f6ee32e8e7ae962fb93889b6e9f0de">&#9670;&nbsp;</a></span>VSIInstallCachedFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCachedFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsicached? file system handler. </p>
<pre class="fragment">embed:rst
See :ref:`/vsicached? documentation &lt;vsicached&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 3.8.0 </dd></dl>

</div>
</div>
<a id="a5e20b79947f58970f5514b3eb9a524a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e20b79947f58970f5514b3eb9a524a9">&#9670;&nbsp;</a></span>VSIInstallCryptFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCryptFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsicrypt/ encrypted file system handler (requires <a href="http://www.cryptopp.com/">libcrypto++</a>) </p>
<p>A special file handler is installed that allows reading/creating/update encrypted files on the fly, with random access capabilities.</p>
<p>The cryptographic algorithms used are <a href="https://en.wikipedia.org/wiki/Block_cipher">block ciphers</a>, with symmetric key.</p>
<p>In their simplest form, recognized filenames are of the form /vsicrypt//absolute_path/to/file, /vsicrypt/c:/absolute_path/to/file or /vsicrypt/relative/path/to/file.</p>
<p>Options can also be used with the following format : /vsicrypt/option1=val1,option2=val2,...,file=/path/to/file</p>
<p>They can also be passed as configuration option/environment variable, because in some use cases, the syntax with option in the filename might not properly work with some drivers.</p>
<p>In all modes, the encryption key must be provided. There are several ways of doing so : </p><ul>
<li>
By adding a key= parameter to the filename, like /vsicrypt/key=my_secret_key,file=/path/to/file. Note that this restricts the key to be in text format, whereas at its full power, it can be binary content. </li>
<li>
By adding a key_b64= parameter to the filename, to specify a binary key expressed in Base64 encoding, like /vsicrypt/key_b64=th1sl00kslikebase64=,file=/path/to/file. </li>
<li>
By setting the VSICRYPT_KEY configuration option. The key should be in text format. </li>
<li>
By setting the VSICRYPT_KEY_B64 configuration option. The key should be encoded in Base64. </li>
<li>
By using the <a class="el" href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c" title="Installs the encryption/decryption key.">VSISetCryptKey()</a> C function. </li>
</ul>
<p>When creating a file, if key=GENERATE_IT or VSICRYPT_KEY=GENERATE_IT is passed, the encryption key will be generated from the pseudo-random number generator of the operating system. The key will be displayed on the standard error stream in a Base64 form (unless the VSICRYPT_DISPLAY_GENERATED_KEY configuration option is set to OFF), and the VSICRYPT_KEY_B64 configuration option will also be set with the Base64 form of the key (so that CPLGetConfigOption("VSICRYPT_KEY_B64", NULL) can be used to get it back).</p>
<p>The available options are : </p><ul>
<li>
alg=AES/Blowfish/Camellia/CAST256/DES_EDE2/DES_EDE3/MARS/IDEA/RC5/RC6/Serpent/SHACAL2/SKIPJACK/Twofish/XTEA: to specify the <a href="https://en.wikipedia.org/wiki/Block_cipher">block cipher</a> algorithm. The default is AES. Only used on creation. Ignored otherwise. Note: depending on how GDAL is build, if linked against the DLL version of libcrypto++, only a subset of those algorithms will be available, namely AES, DES_EDE2, DES_EDE3 and SKIPJACK. Also available as VSICRYPT_ALG configuration option. </li>
<li>
mode=CBC/CFB/OFB/CTR/CBC_CTS: to specify the <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">block cipher mode of operation</a>. The default is CBC. Only used on creation. Ignored otherwise. Also available as VSICRYPT_MODE configuration option. </li>
<li>
key=text_key: see above. </li>
<li>
key_b64=base64_encoded_key: see above. </li>
<li>
freetext=some_text: to specify a text content that will be written <em>unencrypted</em> in the file header, for informational purposes. Default to empty. Only used on creation. Ignored otherwise. Also available as VSICRYPT_FREETEXT configuration option. </li>
<li>
sector_size=int_value: to specify the size of the "sector", which is the unit chunk of information that is encrypted/decrypted. Default to 512 bytes. The valid values depend on the algorithm and block cipher mode of operation. Only used on creation. Ignored otherwise. Also available as VSICRYPT_SECTOR_SIZE configuration option. </li>
<li>
<p class="startli">iv=initial_vector_as_text: to specify the Initial Vector. This is an advanced option that should generally <em>NOT</em> be used. It is only useful to get completely deterministic output given the plaintext, key and other parameters, which in general <em>NOT</em> what you want to do. By default, a random initial vector of the appropriate size will be generated for each new file created. Only used on creation. Ignored otherwise. Also available as VSICRYPT_IV configuration option.</p>
<p class="endli"></p>
</li>
<li>
add_key_check=YES/NO: whether a special value should be encrypted in the header, so as to be quickly able to determine if the decryption key is correct. Defaults to NO. Only used on creation. Ignored otherwise. Also available as VSICRYPT_ADD_KEY_CHECK configuration option. </li>
<li>
file=filename. To specify the filename. This must be the last option put in the option list (so as to make it possible to use filenames with comma in them. ) </li>
</ul>
<p>This special file handler can be combined with other virtual filesystems handlers, such as /vsizip. For example, /vsicrypt//vsicurl/path/to/remote/encrypted/file.tif</p>
<p>Implementation details:</p>
<p>The structure of encrypted files is the following: a header, immediately followed by the encrypted payload (by sectors, i.e. chunks of sector_size bytes).</p>
<p>The header structure is the following : </p><ol>
<li>
8 bytes. Signature. Fixed value: VSICRYPT. </li>
<li>
UINT16_LE. Header size (including previous signature bytes). </li>
<li>
UINT8. Format major version. Current value: 1. </li>
<li>
UINT8. Format minor version. Current value: 0. </li>
<li>
UINT16. Sector size. </li>
<li>
UINT8. Cipher algorithm. Valid values are: 0 = AES (Rijndael), 1 = Blowfish, 2 = Camellia, 3 = CAST256, 4 = DES_EDE2, 5 = DES_EDE3, 6 = MARS, 7 = IDEA, 8 = RC5, 9 = RC6, 10 = Serpent, 11 = SHACAL2, 12 = SKIPJACK, 13 = Twofish, 14 = XTEA. </li>
<li>
UINT8. Block cipher mode of operation. Valid values are: 0 = CBC, 1 = CFB, 2 = OFB, 3 = CTR, 4 = CBC_CTS. </li>
<li>
UINT8. Size in bytes of the Initial Vector. </li>
<li>
N bytes with the content of the Initial Vector, where N is the value of the previous field. </li>
<li>
UINT16_LE. Size in bytes of the free text. </li>
<li>
N bytes with the content of the free text, where N is the value of the previous field. </li>
<li>
UINT8. Size in bytes of encrypted content (key check), or 0 if key check is absent. </li>
<li>
N bytes with encrypted content (key check), where N is the value of the previous field. </li>
<li>
UINT64_LE. Size of the unencrypted file, in bytes. </li>
<li>
UINT16_LE. Size in bytes of extra content (of unspecified semantics). For v1.0, fixed value of 0 </li>
<li>
N bytes with extra content (of unspecified semantics), where N is the value of the previous field. </li>
</ol>
<p>This design does not provide any means of authentication or integrity check.</p>
<p>Each sector is encrypted/decrypted independently of other sectors. For that, the Initial Vector contained in the header is XOR'ed with the file offset (relative to plain text file) of the start of the sector being processed, as a 8-byte integer. More precisely, the first byte of the main IV is XOR'ed with the 8 least-significant bits of the sector offset, the second byte of the main IV is XOR'ed with the following 8 bits of the sector offset, etc... until the 8th byte.</p>
<p>This design could potentially be prone to chosen-plaintext attack, for example if the attacker managed to get (part of) an existing encrypted file to be encrypted from plaintext he might have selected.</p>
<p>Note: if "hostile" code can explore process content, or attach to it with a debugger, it might be relatively easy to retrieve the encryption key. A GDAL plugin could for example get the content of configuration options, or list opened datasets and see the key/key_b64 values, so disabling plugin loading might be a first step, as well as linking statically GDAL to application code. If plugin loading is enabled or GDAL dynamically linked, using <a class="el" href="cpl__vsi_8h.html#a619a6f6758371a39e0c1a4168462452c" title="Installs the encryption/decryption key.">VSISetCryptKey()</a> to set the key might make it a bit more complicated to spy the key. But, as said initially, this is in no way a perfect protection.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1.0 </dd></dl>

</div>
</div>
<a id="a4f791960f2d86713d16e99e9c0c36258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f791960f2d86713d16e99e9c0c36258">&#9670;&nbsp;</a></span>VSIInstallCurlFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCurlFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsicurl/ HTTP/FTP file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsicurl/ documentation &lt;vsicurl&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="ab187e6713f07be9756c22c58b782642d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab187e6713f07be9756c22c58b782642d">&#9670;&nbsp;</a></span>VSIInstallCurlStreamingFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallCurlStreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsicurl_streaming/ HTTP/FTP file system handler (requires libcurl). </p>
<pre class="fragment">embed:rst
See :ref:`/vsicurl_streaming/ documentation &lt;vsicurl_streaming&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.10 </dd></dl>

</div>
</div>
<a id="af80a70fd45cd7a2119f1a2f7da071870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80a70fd45cd7a2119f1a2f7da071870">&#9670;&nbsp;</a></span>VSIInstallGSFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallGSFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsigs/ Google Cloud Storage file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsigs/ documentation &lt;vsigs&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="aca9158701b72f0c840996d8ad98bb2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9158701b72f0c840996d8ad98bb2ff">&#9670;&nbsp;</a></span>VSIInstallGSStreamingFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallGSStreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsigs_streaming/ Google Cloud Storage file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsigs_streaming/ documentation &lt;vsigs_streaming&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a3cde09f204df6f417653b7af4761178e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cde09f204df6f417653b7af4761178e">&#9670;&nbsp;</a></span>VSIInstallGZipFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallGZipFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install GZip file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly and writing in GZip (.gz) files.</p>
<p>All portions of the file system underneath the base path "/vsigzip/" will be handled by this driver.</p>
<pre class="fragment">embed:rst
See :ref:`/vsigzip/ documentation &lt;vsigzip&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="a5c296255c2263248d0e6ad7c4481d746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c296255c2263248d0e6ad7c4481d746">&#9670;&nbsp;</a></span>VSIInstallHdfsHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallHdfsHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsihdfs/ file system handler (requires JVM and HDFS support) </p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4.0 </dd></dl>

</div>
</div>
<a id="a66e2e6f093fd42f8a941b962d4c8a19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e2e6f093fd42f8a941b962d4c8a19e">&#9670;&nbsp;</a></span>VSIInstallMemFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallMemFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install "memory" file system handler. </p>
<p>A special file handler is installed that allows block of memory to be treated as files. All portions of the file system underneath the base path "/vsimem/" will be handled by this driver.</p>
<p>Normal VSI*L functions can be used freely to create and destroy memory arrays treating them as if they were real file system objects. Some additional methods exist to efficient create memory file system objects without duplicating original copies of the data or to "steal" the block of memory associated with a memory file.</p>
<p>Directory related functions are supported.</p>
<p>This code example demonstrates using GDAL to translate from one memory buffer to another.</p>
<div class="fragment"><div class="line"><a class="code" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *ConvertBufferFormat( <a class="code" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *pabyInData, <a class="code" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> nInDataLength,</div>
<div class="line">                            <a class="code" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a> *pnOutDataLength )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// create memory file system object from buffer.</span></div>
<div class="line">    <a class="code" href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7">VSIFCloseL</a>( <a class="code" href="cpl__vsi_8h.html#af9c1b931449d423e7a80bacb75ff0717">VSIFileFromMemBuffer</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span>, pabyInData,</div>
<div class="line">                                      nInDataLength, FALSE ) );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Open memory buffer for read.</span></div>
<div class="line">    <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hDS = <a class="code" href="gdal_8h.html#ae97be045eb4701183ad332ffce29745b">GDALOpen</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span>, <a class="code" href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7a5a021a550b9d5640307d3c0e7e35b732">GA_ReadOnly</a> );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get output format driver.</span></div>
<div class="line">    <a class="code" href="gdal_8h.html#adfd09c07260442427a225e2a536ead72">GDALDriverH</a> hDriver = <a class="code" href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4">GDALGetDriverByName</a>( <span class="stringliteral">&quot;GTiff&quot;</span> );</div>
<div class="line">    <a class="code" href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a> hOutDS;</div>
<div class="line"> </div>
<div class="line">    hOutDS = <a class="code" href="gdal_8h.html#af30eed404fd7fd32f5a23761d61ca7d3">GDALCreateCopy</a>( hDriver, <span class="stringliteral">&quot;/vsimem/out.tif&quot;</span>, hDS, TRUE, NULL,</div>
<div class="line">                             NULL, NULL );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// close source file, and &quot;unlink&quot; it.</span></div>
<div class="line">    <a class="code" href="gdal_8h.html#a7c728fbbef87fe4929e6dd418f4035fa">GDALClose</a>( hDS );</div>
<div class="line">    <a class="code" href="cpl__vsi_8h.html#a7ff49d132f70ec46a550c5a51103e394">VSIUnlink</a>( <span class="stringliteral">&quot;/vsimem/work.dat&quot;</span> );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// seize the buffer associated with the output file.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">VSIGetMemFileBuffer</a>( <span class="stringliteral">&quot;/vsimem/out.tif&quot;</span>, pnOutDataLength, TRUE );</div>
<div class="line">}</div>
<div class="ttc" id="acpl__port_8h_html_ae7fbc84d3d1f7a40973be07382e28401"><div class="ttname"><a href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a></div><div class="ttdeci">unsigned char GByte</div><div class="ttdoc">Unsigned byte type.</div><div class="ttdef"><b>Definition:</b> cpl_port.h:185</div></div>
<div class="ttc" id="acpl__vsi_8h_html_a7ff49d132f70ec46a550c5a51103e394"><div class="ttname"><a href="cpl__vsi_8h.html#a7ff49d132f70ec46a550c5a51103e394">VSIUnlink</a></div><div class="ttdeci">int VSIUnlink(const char *pszFilename)</div><div class="ttdoc">Delete a file.</div><div class="ttdef"><b>Definition:</b> cpl_vsil.cpp:450</div></div>
<div class="ttc" id="acpl__vsi_8h_html_a82fe6612261c1948eee388e75b7d6db7"><div class="ttname"><a href="cpl__vsi_8h.html#a82fe6612261c1948eee388e75b7d6db7">VSIFCloseL</a></div><div class="ttdeci">int VSIFCloseL(VSILFILE *)</div><div class="ttdoc">Close file.</div><div class="ttdef"><b>Definition:</b> cpl_vsil.cpp:2470</div></div>
<div class="ttc" id="acpl__vsi_8h_html_aeaf26bcc4a5314371f426bb2a5e6ce7a"><div class="ttname"><a href="cpl__vsi_8h.html#aeaf26bcc4a5314371f426bb2a5e6ce7a">VSIGetMemFileBuffer</a></div><div class="ttdeci">GByte * VSIGetMemFileBuffer(const char *pszFilename, vsi_l_offset *pnDataLength, int bUnlinkAndSeize)</div><div class="ttdoc">Fetch buffer underlying memory file.</div><div class="ttdef"><b>Definition:</b> cpl_vsi_mem.cpp:1122</div></div>
<div class="ttc" id="acpl__vsi_8h_html_af56f9ebab1994e4c2ed3f0a50af787b2"><div class="ttname"><a href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a></div><div class="ttdeci">GUIntBig vsi_l_offset</div><div class="ttdoc">Type for a file offset.</div><div class="ttdef"><b>Definition:</b> cpl_vsi.h:146</div></div>
<div class="ttc" id="acpl__vsi_8h_html_af9c1b931449d423e7a80bacb75ff0717"><div class="ttname"><a href="cpl__vsi_8h.html#af9c1b931449d423e7a80bacb75ff0717">VSIFileFromMemBuffer</a></div><div class="ttdeci">VSILFILE * VSIFileFromMemBuffer(const char *pszFilename, GByte *pabyData, vsi_l_offset nDataLength, int bTakeOwnership)</div><div class="ttdoc">Create memory &quot;file&quot; from a buffer.</div><div class="ttdef"><b>Definition:</b> cpl_vsi_mem.cpp:1037</div></div>
<div class="ttc" id="agdal_8h_html_a045e3967c208993f70257bfd40c9f1d7a5a021a550b9d5640307d3c0e7e35b732"><div class="ttname"><a href="gdal_8h.html#a045e3967c208993f70257bfd40c9f1d7a5a021a550b9d5640307d3c0e7e35b732">GA_ReadOnly</a></div><div class="ttdeci">@ GA_ReadOnly</div><div class="ttdef"><b>Definition:</b> gdal.h:126</div></div>
<div class="ttc" id="agdal_8h_html_a2316f0c00f9997839f782ec946f8303d"><div class="ttname"><a href="gdal_8h.html#a2316f0c00f9997839f782ec946f8303d">GDALDatasetH</a></div><div class="ttdeci">void * GDALDatasetH</div><div class="ttdoc">Opaque type used for the C bindings of the C++ GDALDataset class.</div><div class="ttdef"><b>Definition:</b> gdal.h:291</div></div>
<div class="ttc" id="agdal_8h_html_a7c728fbbef87fe4929e6dd418f4035fa"><div class="ttname"><a href="gdal_8h.html#a7c728fbbef87fe4929e6dd418f4035fa">GDALClose</a></div><div class="ttdeci">CPLErr GDALClose(GDALDatasetH)</div><div class="ttdoc">Close GDAL dataset.</div><div class="ttdef"><b>Definition:</b> gdaldataset.cpp:4119</div></div>
<div class="ttc" id="agdal_8h_html_adfd09c07260442427a225e2a536ead72"><div class="ttname"><a href="gdal_8h.html#adfd09c07260442427a225e2a536ead72">GDALDriverH</a></div><div class="ttdeci">void * GDALDriverH</div><div class="ttdoc">Opaque type used for the C bindings of the C++ GDALDriver class.</div><div class="ttdef"><b>Definition:</b> gdal.h:297</div></div>
<div class="ttc" id="agdal_8h_html_ae8ae868eef1e4773283d137b0a1adfc4"><div class="ttname"><a href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4">GDALGetDriverByName</a></div><div class="ttdeci">GDALDriverH GDALGetDriverByName(const char *)</div><div class="ttdoc">Fetch a driver based on the short name.</div><div class="ttdef"><b>Definition:</b> gdaldrivermanager.cpp:691</div></div>
<div class="ttc" id="agdal_8h_html_ae97be045eb4701183ad332ffce29745b"><div class="ttname"><a href="gdal_8h.html#ae97be045eb4701183ad332ffce29745b">GDALOpen</a></div><div class="ttdeci">GDALDatasetH GDALOpen(const char *pszFilename, GDALAccess eAccess)</div><div class="ttdoc">Open a raster file as a GDALDataset.</div><div class="ttdef"><b>Definition:</b> gdaldataset.cpp:3427</div></div>
<div class="ttc" id="agdal_8h_html_af30eed404fd7fd32f5a23761d61ca7d3"><div class="ttname"><a href="gdal_8h.html#af30eed404fd7fd32f5a23761d61ca7d3">GDALCreateCopy</a></div><div class="ttdeci">GDALDatasetH GDALCreateCopy(GDALDriverH, const char *, GDALDatasetH, int, CSLConstList, GDALProgressFunc, void *)</div><div class="ttdoc">Create a copy of a dataset.</div><div class="ttdef"><b>Definition:</b> gdaldriver.cpp:1403</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad393a845ca054eab086fb933cee74be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad393a845ca054eab086fb933cee74be0">&#9670;&nbsp;</a></span>VSIInstallOSSFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallOSSFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsioss/ Alibaba Cloud Object Storage Service (OSS) file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsioss/ documentation &lt;vsioss&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a966348bdbdd092035cd7925d56943d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966348bdbdd092035cd7925d56943d05">&#9670;&nbsp;</a></span>VSIInstallOSSStreamingFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallOSSStreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiaz_streaming/ Alibaba Cloud Object Storage Service (OSS) (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsioss_streaming/ documentation &lt;vsioss_streaming&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a9fd74a1b0cad563fe1518660967a673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd74a1b0cad563fe1518660967a673f">&#9670;&nbsp;</a></span>VSIInstallPluginHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIInstallPluginHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structVSIFilesystemPluginCallbacksStruct.html">VSIFilesystemPluginCallbacksStruct</a> *&#160;</td>
          <td class="paramname"><em>poCb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register a handler on the given prefix. </p>
<p>All IO on datasets opened with the filename /prefix/xxxxxx will go through these callbacks. pszPrefix must begin and end with a '/' </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="ac46625a713d8fb18b05aa747080858bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46625a713d8fb18b05aa747080858bf">&#9670;&nbsp;</a></span>VSIInstallRarFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallRarFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsirar/ RAR file system handler (requires libarchive) </p>
<pre class="fragment">embed:rst
See :ref:`/vsirar/ documentation &lt;vsirar&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a5b4754999acd06444bfda172ff2aaa16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4754999acd06444bfda172ff2aaa16">&#9670;&nbsp;</a></span>VSIInstallS3FileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallS3FileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsis3/ Amazon S3 file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsis3/ documentation &lt;vsis3&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a126c1e0314bbd7e4661bc526f45032c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126c1e0314bbd7e4661bc526f45032c5">&#9670;&nbsp;</a></span>VSIInstallS3StreamingFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallS3StreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsis3_streaming/ Amazon S3 file system handler (requires libcurl). </p>
<pre class="fragment">embed:rst
See :ref:`/vsis3_streaming/ documentation &lt;vsis3_streaming&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ab79aed725b28eb22471a8b6733405843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79aed725b28eb22471a8b6733405843">&#9670;&nbsp;</a></span>VSIInstallSparseFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSparseFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsisparse/ virtual file handler. </p>
<pre class="fragment">embed:rst
See :ref:`/vsisparse/ documentation &lt;vsisparse&gt;`
</pre> 
</div>
</div>
<a id="a2c6b408477f59b40f0aec51d5980eb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6b408477f59b40f0aec51d5980eb8e">&#9670;&nbsp;</a></span>VSIInstallStdinHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallStdinHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsistdin/ file system handler. </p>
<p>A special file handler is installed that allows reading from the standard input stream.</p>
<p>The file operations available are of course limited to Read() and forward Seek() (full seek in the first MB of a file by default).</p>
<p>Starting with GDAL 3.6, this limit can be configured either by setting the CPL_VSISTDIN_BUFFER_LIMIT configuration option to a number of bytes (can be -1 for unlimited), or using the "/vsistdin?buffer_limit=value" filename.</p>
<pre class="fragment">embed:rst
See :ref:`/vsistdin/ documentation &lt;vsistdin&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="a61d2250ab2b22ca79b051a8479ee5383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d2250ab2b22ca79b051a8479ee5383">&#9670;&nbsp;</a></span>VSIInstallStdoutHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallStdoutHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsistdout/ file system handler. </p>
<p>A special file handler is installed that allows writing to the standard output stream.</p>
<p>The file operations available are of course limited to Write().</p>
<p>A variation of this file system exists as the /vsistdout_redirect/ file system handler, where the output function can be defined with <a class="el" href="cpl__vsi_8h.html#adc4a67cc303d7662c34f506d0bdddd79" title="Set an alternative write function and output file handle instead of fwrite() / stdout.">VSIStdoutSetRedirection()</a>.</p>
<pre class="fragment">embed:rst
See :ref:`/vsistdout/ documentation &lt;vsistdout&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="abaee4232440e012b4b9920934fc571cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaee4232440e012b4b9920934fc571cc">&#9670;&nbsp;</a></span>VSIInstallSubFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSubFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsisubfile/ virtual file handler. </p>
<pre class="fragment">embed:rst
See :ref:`/vsisubfile/ documentation &lt;vsisubfile&gt;`
</pre> 
</div>
</div>
<a id="a87a177eab3fbc4241083f6749b9a75d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a177eab3fbc4241083f6749b9a75d5">&#9670;&nbsp;</a></span>VSIInstallSwiftFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSwiftFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiswift/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsiswift/ documentation &lt;vsiswift&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6112f0851a51fe5ad1333f5cd1672ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6112f0851a51fe5ad1333f5cd1672ab6">&#9670;&nbsp;</a></span>VSIInstallSwiftStreamingFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallSwiftStreamingFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiswift_streaming/ OpenStack Swif Object Storage (Swift) file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsiswift_streaming/ documentation &lt;vsiswift_streaming&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="ad6dd983338849e7da4eaa88f6458ab64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dd983338849e7da4eaa88f6458ab64">&#9670;&nbsp;</a></span>VSIInstallTarFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallTarFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsitar/ file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in TAR (regular .tar, or compressed .tar.gz/.tgz) archives.</p>
<p>All portions of the file system underneath the base path "/vsitar/" will be handled by this driver.</p>
<pre class="fragment">embed:rst
See :ref:`/vsitar/ documentation &lt;vsitar&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="a51b1d08d5f6dcd37d2ed89583765ee9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b1d08d5f6dcd37d2ed89583765ee9b">&#9670;&nbsp;</a></span>VSIInstallWebHdfsHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallWebHdfsHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install /vsiwebhdfs/ WebHDFS (Hadoop File System) REST API file system handler (requires libcurl) </p>
<pre class="fragment">embed:rst
See :ref:`/vsiwebhdfs/ documentation &lt;vsiwebhdfs&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a884fac3cd6be2c09deb807e959d78b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884fac3cd6be2c09deb807e959d78b3a">&#9670;&nbsp;</a></span>VSIInstallZipFileHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIInstallZipFileHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install ZIP file system handler. </p>
<p>A special file handler is installed that allows reading on-the-fly in ZIP (.zip) archives.</p>
<p>All portions of the file system underneath the base path "/vsizip/" will be handled by this driver.</p>
<pre class="fragment">embed:rst
See :ref:`/vsizip/ documentation &lt;vsizip&gt;`
</pre><dl class="section since"><dt>Since</dt><dd>GDAL 1.6.0 </dd></dl>

</div>
</div>
<a id="a36737f0cb2949ba2f7bbf23cc6592a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36737f0cb2949ba2f7bbf23cc6592a04">&#9670;&nbsp;</a></span>VSIIsCaseSensitiveFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIIsCaseSensitiveFS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filenames of the filesystem are case sensitive. </p>
<p>This method retrieves to which filesystem belongs the passed filename and return TRUE if the filenames of that filesystem are case sensitive.</p>
<p>Currently, this will return FALSE only for Windows real filenames. Other VSI virtual filesystems are case sensitive.</p>
<p>This methods avoid ugly #ifndef _WIN32 / #endif code, that is wrong when dealing with virtual filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the filenames of the filesystem are case sensitive.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="aef3fe30982dfd3591bd4dee6eeb50bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3fe30982dfd3591bd4dee6eeb50bc1">&#9670;&nbsp;</a></span>VSIIsLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VSIIsLocal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the file/filesystem is "local". </p>
<p>The concept of local is mostly by opposition with a network / remote file system whose access time can be long.</p>
<p>/vsimem/ is considered to be a local file system, although a non-persistent one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a5ff69294658f2e1d02129bf69207c122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff69294658f2e1d02129bf69207c122">&#9670;&nbsp;</a></span>VSIMalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of malloc(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> to free </p>

</div>
</div>
<a id="a9b88331b0be4f7f2bd43e7b830af7038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b88331b0be4f7f2bd43e7b830af7038">&#9670;&nbsp;</a></span>VSIMalloc2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VSIMalloc2 allocates (nSize1 * nSize2) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error.">CPLError()</a>. If nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> can be used to free memory allocated by this function. </p>

</div>
</div>
<a id="a644254757e7d9ec23df256d34fff565d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644254757e7d9ec23df256d34fff565d">&#9670;&nbsp;</a></span>VSIMalloc3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMalloc3 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes. </p>
<p>In case of overflow of the multiplication, or if memory allocation fails, a NULL pointer is returned and a CE_Failure error is raised with <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error.">CPLError()</a>. If nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned. <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> or <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> can be used to free memory allocated by this function. </p>

</div>
</div>
<a id="ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84e60d7bf7fc3f5d0d3fa21fb4c3fa1">&#9670;&nbsp;</a></span>VSIMallocAligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMallocAligned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer with an alignment constraint. </p>
<p>The return value must be freed with <a class="el" href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33" title="Free a buffer allocated with VSIMallocAligned().">VSIFreeAligned()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nAlignment</td><td>Must be a power of 2, multiple of sizeof(void*), and lesser than 256. </td></tr>
    <tr><td class="paramname">nSize</td><td>Size of the buffer to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a buffer aligned on nAlignment and of size nSize, or NULL </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a7c4e05ed5d30750133d43ca221b1ac70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4e05ed5d30750133d43ca221b1ac70">&#9670;&nbsp;</a></span>VSIMallocAlignedAuto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIMallocAlignedAuto </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a buffer with an alignment constraint such that it can be used by the most demanding vector instruction set on that platform. </p>
<p>The return value must be freed with <a class="el" href="cpl__vsi_8h.html#ad8fc84461d6ad10524a64ead6af56e33" title="Free a buffer allocated with VSIMallocAligned().">VSIFreeAligned()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSize</td><td>Size of the buffer to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an aligned buffer of size nSize, or NULL </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="aaa3e0b14583ca553a29bf163b972c157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3e0b14583ca553a29bf163b972c157">&#9670;&nbsp;</a></span>VSIMkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<p>Create a new directory with the indicated mode. For POSIX-style systems, the mode is modified by the file creation mask (umask). However, some file systems and platforms may not use umask, or they may ignore the mode completely. So a reasonable cross-platform default mode value is 0755.</p>
<p>Analog of the POSIX mkdir() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathname</td><td>the path to the directory to create. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">mode</td><td>the permissions mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="a62018c639ec285ae04afa5799ee6a4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62018c639ec285ae04afa5799ee6a4d5">&#9670;&nbsp;</a></span>VSIMkdirRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMkdirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory and all its ancestors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathname</td><td>the path to the directory to create. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">mode</td><td>the permissions mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a6e724523119104cbf8468a12ff4c5744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e724523119104cbf8468a12ff4c5744">&#9670;&nbsp;</a></span>VSIMultipartUploadAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMultipartUploadAbort </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUploadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts a multi-part file upload. </p>
<p>Cf <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a>.</p>
<p>This function is not implemented for all virtual file systems. Use <a class="el" href="cpl__vsi_8h.html#a7d427470f6856989f19a1d4052c9f02f" title="Return capabilities for multiple part file upload.">VSIMultipartUploadGetCapabilities()</a> to determine if it is supported.</p>
<p>This can be needed to avoid extra billing for some cloud storage providers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Filename for which multipart upload should be completed. Should be the same as the one used for <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a> </td></tr>
    <tr><td class="paramname">pszUploadId</td><td>Value returned by <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a> </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Unused. Should be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="ad40fa2b252fafa7d9212a07a45caa899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40fa2b252fafa7d9212a07a45caa899">&#9670;&nbsp;</a></span>VSIMultipartUploadAddPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIMultipartUploadAddPart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUploadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPartNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nFileOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads a new part to a multi-part uploaded file. </p>
<p>Cf <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a>.</p>
<p><a class="el" href="cpl__vsi_8h.html#a7d427470f6856989f19a1d4052c9f02f" title="Return capabilities for multiple part file upload.">VSIMultipartUploadGetCapabilities()</a> returns hints on the constraints that apply to the upload, in terms of minimum/maximum size of each part, maximum number of parts, and whether non-sequential or parallel uploads are supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Filename to which to append the new part. Should be the same as the one used for <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a> </td></tr>
    <tr><td class="paramname">pszUploadId</td><td>Value returned by <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a> </td></tr>
    <tr><td class="paramname">nPartNumber</td><td>Part number, starting at 1. </td></tr>
    <tr><td class="paramname">nFileOffset</td><td>Offset within the file at which (starts at 0) the passed data starts. </td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to an array of nDataLength bytes. </td></tr>
    <tr><td class="paramname">nDataLength</td><td>Size in bytes of pData. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Unused. Should be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a part identifier that must be passed into the apszPartIds[] array of <a class="el" href="cpl__vsi_8h.html#a2b7b68759e67004aa29ddf3e6a5ee5cc" title="Completes a multi-part file upload.">VSIMultipartUploadEnd()</a>, and to free with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> once done, or nullptr in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="a2b7b68759e67004aa29ddf3e6a5ee5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7b68759e67004aa29ddf3e6a5ee5cc">&#9670;&nbsp;</a></span>VSIMultipartUploadEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMultipartUploadEnd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszUploadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nPartIdsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>apszPartIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#af56f9ebab1994e4c2ed3f0a50af787b2">vsi_l_offset</a>&#160;</td>
          <td class="paramname"><em>nTotalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completes a multi-part file upload. </p>
<p>Cf <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Filename for which multipart upload should be completed. Should be the same as the one used for <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a> </td></tr>
    <tr><td class="paramname">pszUploadId</td><td>Value returned by <a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a> </td></tr>
    <tr><td class="paramname">nPartIdsCount</td><td>Number of parts, andsize of apszPartIds </td></tr>
    <tr><td class="paramname">apszPartIds</td><td>Array of part identifiers (as returned by <a class="el" href="cpl__vsi_8h.html#ad40fa2b252fafa7d9212a07a45caa899" title="Uploads a new part to a multi-part uploaded file.">VSIMultipartUploadAddPart()</a>), that must be ordered in the sequential order of parts, and of size nPartIdsCount. </td></tr>
    <tr><td class="paramname">nTotalSize</td><td>Total size of the file in bytes (must be equal to the sum of nDataLength passed to <a class="el" href="cpl__vsi_8h.html#ad40fa2b252fafa7d9212a07a45caa899" title="Uploads a new part to a multi-part uploaded file.">VSIMultipartUploadAddPart()</a>) </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Unused. Should be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE in case of failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="a7d427470f6856989f19a1d4052c9f02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d427470f6856989f19a1d4052c9f02f">&#9670;&nbsp;</a></span>VSIMultipartUploadGetCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIMultipartUploadGetCapabilities </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbNonSequentialUploadSupported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbParallelUploadSupported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pbAbortSupported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pnMinPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>pnMaxPartSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMaxPartCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return capabilities for multiple part file upload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pszFilename</td><td>Filename, or virtual file system prefix, onto which capabilities should apply. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbNonSequentialUploadSupported</td><td>If not null, the pointed value is set if parts can be uploaded in a non-sequential way. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbParallelUploadSupported</td><td>If not null, the pointed value is set if parts can be uploaded in a parallel way. (implies *pbNonSequentialUploadSupported = true) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbAbortSupported</td><td>If not null, the pointed value is set if <a class="el" href="cpl__vsi_8h.html#a6e724523119104cbf8468a12ff4c5744" title="Aborts a multi-part file upload.">VSIMultipartUploadAbort()</a> is implemented. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnMinPartSize</td><td>If not null, the pointed value is set to the minimum size of parts (but the last one), in MiB. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnMaxPartSize</td><td>If not null, the pointed value is set to the maximum size of parts, in MiB. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnMaxPartCount</td><td>If not null, the pointed value is set to the maximum number of parts that can be uploaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success, FALSE otherwise.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="a80827e0cd2062452638eb16d73914a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80827e0cd2062452638eb16d73914a10">&#9670;&nbsp;</a></span>VSIMultipartUploadStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIMultipartUploadStart </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the upload a (big) file in a piece-wise way. </p>
<p>Using this API directly is generally not needed, but in very advanced cases, as VSIFOpenL(..., "wb") + <a class="el" href="cpl__vsi_8h.html#a2a382b55d461f4979f523e8c6e257ada" title="Write bytes to file.">VSIFWriteL()</a>, <a class="el" href="cpl__vsi_8h.html#a6845a21b2c0491c594dd9deef757db6b" title="Synchronize a source file/directory with a target file/directory.">VSISync()</a>, <a class="el" href="cpl__vsi_8h.html#a2931707253132f6f2628be50e9e6db59" title="Copy a source file into a target file.">VSICopyFile()</a> or <a class="el" href="cpl__vsi_8h.html#aca75ed325440d598169cd486e171e7cf" title="Copy a source file into a target file in a way that can (potentially) be restarted.">VSICopyFileRestartable()</a> may be able to leverage it when needed.</p>
<p>This is only implemented for the /vsis3/, /vsigs/, /vsiaz/, /vsiadls/ and /vsioss/ virtual file systems.</p>
<p>The typical workflow is to do :</p><ul>
<li><a class="el" href="cpl__vsi_8h.html#a80827e0cd2062452638eb16d73914a10" title="Initiates the upload a (big) file in a piece-wise way.">VSIMultipartUploadStart()</a></li>
<li><a class="el" href="cpl__vsi_8h.html#ad40fa2b252fafa7d9212a07a45caa899" title="Uploads a new part to a multi-part uploaded file.">VSIMultipartUploadAddPart()</a>: several times</li>
<li><a class="el" href="cpl__vsi_8h.html#a2b7b68759e67004aa29ddf3e6a5ee5cc" title="Completes a multi-part file upload.">VSIMultipartUploadEnd()</a></li>
</ul>
<p>If <a class="el" href="cpl__vsi_8h.html#a6e724523119104cbf8468a12ff4c5744" title="Aborts a multi-part file upload.">VSIMultipartUploadAbort()</a> is supported by the filesystem (<a class="el" href="cpl__vsi_8h.html#a7d427470f6856989f19a1d4052c9f02f" title="Return capabilities for multiple part file upload.">VSIMultipartUploadGetCapabilities()</a> can be used to determine it), this function should be called to cancel an upload. This can be needed to avoid extra billing for some cloud storage providers.</p>
<p>The following options are supported: </p><ul>
<li>
MIME headers such as Content-Type and Content-Encoding are supported for the /vsis3/, /vsigs/, /vsiaz/, /vsiadls/ file systems. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>Filename to create </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL or null-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an upload ID to pass to other VSIMultipartUploadXXXXX() functions, and to free with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> once done, or nullptr in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="ac29c1f4b02612f1220bd574d610c67a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29c1f4b02612f1220bd574d610c67a2">&#9670;&nbsp;</a></span>VSINetworkStatsGetAsSerializedJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSINetworkStatsGetAsSerializedJSON </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return network related statistics, as a JSON serialized object. </p>
<p>Statistics collecting should be enabled with the CPL_VSIL_NETWORK_STATS_ENABLED configuration option set to YES before any network activity starts (for efficiency, reading it is cached on first access, until <a class="el" href="cpl__vsi_8h.html#a0e8c1d1c1954cfe7a7e811617df87323" title="Clear network related statistics.">VSINetworkStatsReset()</a> is called)</p>
<p>Statistics can also be emitted on standard output at process termination if the CPL_VSIL_SHOW_NETWORK_STATS configuration option is set to YES.</p>
<p>Example of output: </p><pre>
  {
    "methods":{
      "GET":{
        "count":6,
        "downloaded_bytes":40825
      },
      "PUT":{
        "count":1,
        "uploaded_bytes":35472
      }
    },
    "handlers":{
      "vsigs":{
        "methods":{
          "GET":{
            "count":2,
            "downloaded_bytes":446
          },
          "PUT":{
            "count":1,
            "uploaded_bytes":35472
          }
        },
        "files":{
          "\/vsigs\/spatialys\/byte.tif":{
            "methods":{
              "PUT":{
                "count":1,
                "uploaded_bytes":35472
              }
            },
            "actions":{
              "Write":{
                "methods":{
                  "PUT":{
                    "count":1,
                    "uploaded_bytes":35472
                  }
                }
              }
            }
          }
        },
        "actions":{
          "Stat":{
            "methods":{
              "GET":{
                "count":2,
                "downloaded_bytes":446
              }
            },
            "files":{
              "\/vsigs\/spatialys\/byte.tif\/":{
                "methods":{
                  "GET":{
                    "count":1,
                    "downloaded_bytes":181
                  }
                }
              }
            }
          }
        }
      },
      "vsis3":{
           [...]
      }
    }
  }

  </pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszOptions</td><td>Unused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a JSON serialized string to free with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a>, or nullptr </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2.0 </dd></dl>

</div>
</div>
<a id="a0e8c1d1c1954cfe7a7e811617df87323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8c1d1c1954cfe7a7e811617df87323">&#9670;&nbsp;</a></span>VSINetworkStatsReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSINetworkStatsReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear network related statistics. </p>
<p>The effect of the CPL_VSIL_NETWORK_STATS_ENABLED configuration option will also be reset. That is, that the next network access will check its value again.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2.0 </dd></dl>

</div>
</div>
<a id="a186d32d750cca298ea625c00e8be3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186d32d750cca298ea625c00e8be3f90">&#9670;&nbsp;</a></span>VSIOpenDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__vsi_8h.html#a6abfa965a6cceea416b192b38c90f9ad">VSIDIR</a>* VSIOpenDir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRecurseDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory to read its entries. </p>
<p>This function is close to the POSIX opendir() function.</p>
<p>For /vsis3/, /vsigs/, /vsioss/, /vsiaz/ and /vsiadls/, this function has an efficient implementation, minimizing the number of network requests, when invoked with nRecurseDepth &lt;= 0.</p>
<p>Entries are read by calling <a class="el" href="cpl__vsi_8h.html#a0ce4131b005b1853a16d4f341d1ba031" title="Return the next entry of the directory.">VSIGetNextDirEntry()</a> on the handled returned by that function, until it returns NULL. <a class="el" href="cpl__vsi_8h.html#a7e7448bda4230b3d8133a59027c5f02f" title="Close a directory.">VSICloseDir()</a> must be called once done with the returned directory handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">nRecurseDepth</td><td>0 means do not recurse in subdirectories, 1 means recurse only in the first level of subdirectories, etc. -1 means unlimited recursion level </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or NULL. The following options are implemented: <ul>
<li>
PREFIX=string: (GDAL &gt;= 3.4) Filter to select filenames only starting with the specified prefix. Implemented efficiently for /vsis3/, /vsigs/, and /vsiaz/ (but not /vsiadls/)  </li>
<li>
NAME_AND_TYPE_ONLY=YES/NO: (GDAL &gt;= 3.4) Defaults to NO. If set to YES, only the pszName and nMode members of VSIDIR are guaranteed to be set. This is implemented efficiently for the Unix virtual file system.  </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle, or NULL in case of error </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a610595be39b84ad87d077f0499fa4460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610595be39b84ad87d077f0499fa4460">&#9670;&nbsp;</a></span>VSIOverwriteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIOverwriteFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fpTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSourceFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite an existing file with content from another one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fpTarget</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a> with "rb+" flag. </td></tr>
    <tr><td class="paramname">pszSourceFilename</td><td>source filename</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="a6158d73485d6cf92c75b38e7f26d00c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6158d73485d6cf92c75b38e7f26d00c3">&#9670;&nbsp;</a></span>VSIReadDir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error.">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<p>This function used to be known as <a class="el" href="cpl__vsi_8h.html#afdc1dc07ba4fe31933c9b522de783692" title="Alias of VSIReadDir()">CPLReadDir()</a>, but the old name is now deprecated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries in the directory, or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>

</div>
</div>
<a id="aab9f5bbeaa3ad170682f130f427930bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f5bbeaa3ad170682f130f427930bd">&#9670;&nbsp;</a></span>VSIReadDirEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDirEx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMaxFiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read names in a directory. </p>
<p>This function abstracts access to directory contains. It returns a list of strings containing the names of files, and directories in this directory. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error.">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<p>If nMaxFiles is set to a positive number, directory listing will stop after that limit has been reached. Note that to indicate truncate, at least one element more than the nMaxFiles limit will be returned. If <a class="el" href="cpl__string_8h.html#a827f21b7a67d16059c131d0946482bb1" title="Return number of items in a string list.">CSLCount()</a> on the result is lesser or equal to nMaxFiles, then no truncation occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">nMaxFiles</td><td>maximum number of files after which to stop, or 0 for no limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries in the directory, or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a03c473cd78f2dffabf709245a928e6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c473cd78f2dffabf709245a928e6c7">&#9670;&nbsp;</a></span>VSIReadDirRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSIReadDirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read names in a directory recursively. </p>
<p>This function abstracts access to directory contents and subdirectories. It returns a list of strings containing the names of files and directories in this directory and all subdirectories. The resulting string list becomes the responsibility of the application and should be freed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> when no longer needed.</p>
<p>Note that no error is issued via <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error.">CPLError()</a> if the directory path is invalid, though NULL is returned.</p>
<p>Note: since GDAL 3.9, for recursive mode, the directory separator will no longer be always forward slash, but will be the one returned by VSIGetDirectorySeparator(pszPathIn), so potentially backslash on Windows file systems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathIn</td><td>the relative, or absolute path of a directory to read. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries in the directory and subdirectories or NULL if the directory doesn't exist. Filenames are returned in UTF-8 encoding. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.10.0 </dd></dl>

</div>
</div>
<a id="add6cd6a32996ba1650528f2df3214c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6cd6a32996ba1650528f2df3214c57">&#9670;&nbsp;</a></span>VSIRealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VSIRealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nNewSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of realloc(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> to free </p>

</div>
</div>
<a id="a4cc0473cc58704717095fd5cb6835935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc0473cc58704717095fd5cb6835935">&#9670;&nbsp;</a></span>VSIRemovePluginHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRemovePluginHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a handler previously installed with <a class="el" href="cpl__vsi_8h.html#a9fd74a1b0cad563fe1518660967a673f" title="register a handler on the given prefix.">VSIInstallPluginHandler()</a> on the given prefix. </p>
<p>Note: it is generally unsafe to remove a handler while there are still file handles opened that are managed by that handler. It is the responsibility of the caller to ensure that it calls this function in a situation where it is safe to do so. </p><dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a26cae93b5a32e11bef9ec7c118f8cca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26cae93b5a32e11bef9ec7c118f8cca4">&#9670;&nbsp;</a></span>VSIRename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a file. </p>
<p>Renames a file object in the file system. It should be possible to rename a file onto a new filesystem, but it is safest if this function is only used to rename files that remain in the same directory.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rename() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldpath</td><td>the name of the file to be renamed. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">newpath</td><td>the name the file should be given. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="abbbc227f7c966e95ece4691c3cc1c562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbc227f7c966e95ece4691c3cc1c562">&#9670;&nbsp;</a></span>VSIRewindL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIRewindL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a1d4f822e1cc1e28bdf631f1baa835b7b">VSILFILE</a> *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind the file pointer to the beginning of the file. </p>
<p>This is equivalent to VSIFSeekL( fp, 0, SEEK_SET )</p>
<p>Analog of the POSIX rewind() call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>file handle opened with <a class="el" href="cpl__vsi_8h.html#ad487ad46f2841815f331292051192d5f" title="Open file.">VSIFOpenL()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af12c8873a6ff54d9c1e7f752cada9822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c8873a6ff54d9c1e7f752cada9822">&#9670;&nbsp;</a></span>VSIRmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a directory. </p>
<p>Deletes a directory object from the file system. On some systems the directory must be empty before it can be deleted.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX rmdir() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszDirname</td><td>the path of the directory to be deleted. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="aa5e05f10c591053fa876c9d3417421a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e05f10c591053fa876c9d3417421a5">&#9670;&nbsp;</a></span>VSIRmdirRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIRmdirRecursive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a directory recursively. </p>
<p>Deletes a directory object and its content from the file system.</p>
<p>Starting with GDAL 3.1, /vsis3/ has an efficient implementation of this function. Starting with GDAL 3.4, /vsigs/ has an efficient implementation of this function, provided that OAuth2 authentication is used.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a28296bd513f263acec28a02e12876664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28296bd513f263acec28a02e12876664">&#9670;&nbsp;</a></span>VSISetCredential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSISetCredential </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a credential (or more generally an option related to a virtual file system) for a given path prefix. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>in GDAL 3.6 for the better named <a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#a4808a875c09ec946a9df0147ced8655f" title="Set a path specific option for a given path prefix.">VSISetPathSpecificOption()</a> </dd></dl>

</div>
</div>
<a id="a619a6f6758371a39e0c1a4168462452c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619a6f6758371a39e0c1a4168462452c">&#9670;&nbsp;</a></span>VSISetCryptKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSISetCryptKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td>
          <td class="paramname"><em>pabyKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nKeySize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs the encryption/decryption key. </p>
<p>By passing a NULL key, the previously installed key will be cleared. Note, however, that it is not guaranteed that there won't be trace of it in other places in memory or in on-disk temporary file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyKey</td><td>key. Might be NULL to clear previously set key. </td></tr>
    <tr><td class="paramname">nKeySize</td><td>length of the key in bytes. Might be 0 to clear previously set key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__vsi_8h.html#a5e20b79947f58970f5514b3eb9a524a9" title="Install /vsicrypt/ encrypted file system handler (requires libcrypto++)">VSIInstallCryptFileHandler()</a> for documentation on /vsicrypt/ </dd></dl>

</div>
</div>
<a id="a0a1c8d0014e7c76fbef98d24b9233a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c8d0014e7c76fbef98d24b9233a89">&#9670;&nbsp;</a></span>VSISetFileMetadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSISetFileMetadata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set metadata on files. </p>
<p>Implemented currently only for /vsis3/, /vsigs/, /vsiaz/ and /vsiadls/</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be set. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszMetadata</td><td>NULL-terminated list of key=value strings. </td></tr>
    <tr><td class="paramname">pszDomain</td><td>Metadata domain to set. Depends on the file system. The following are supported: <ul>
<li>
HEADERS: specific to /vsis3/ and /vsigs/: to set HTTP headers, such as "Content-Type", or other file system specific header. For /vsigs/, this also includes: x-goog-meta-{key}={value}. Note that you should specify all metadata to be set, as existing metadata will be overridden.  </li>
<li>
TAGS: Content of papszMetadata should be KEY=VALUE pairs. <ul>
<li>
/vsis3/: to set S3 Object tagging information </li>
<li>
/vsiaz/: to set blob tags. Refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tags">https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tags</a>. Note: storageV2 must be enabled on the account </li>
</ul>
</li>
<li>
PROPERTIES: <ul>
<li>
to /vsiaz/: to set properties. Refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties">https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties</a>. </li>
<li>
to /vsiadls/: to set properties. Refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update">https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update</a> for headers valid for action=setProperties. </li>
</ul>
</li>
<li>
ACL: specific to /vsiadls/ and /vsigs/: to set access control list. For /vsiadls/, refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update">https://docs.microsoft.com/en-us/rest/api/storageservices/datalakestoragegen2/path/update</a> for headers valid for action=setAccessControl or setAccessControlRecursive. In setAccessControlRecursive, x-ms-acl must be specified in papszMetadata. For /vsigs/, refer to <a href="https://cloud.google.com/storage/docs/xml-api/put-object-acls">https://cloud.google.com/storage/docs/xml-api/put-object-acls</a>. A single XML=xml_content string should be specified as in papszMetadata.  </li>
<li>
METADATA: specific to /vsiaz/: to set blob metadata. Refer to <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata">https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata</a>. Content of papszMetadata should be strings in the form x-ms-meta-name=value </li>
</ul>
</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL or NULL terminated list of options. For /vsiadls/ and pszDomain=ACL, "RECURSIVE=TRUE" can be set to set the access control list recursively. When RECURSIVE=TRUE is set, MODE should also be set to one of "set", "modify" or "remove".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="a4808a875c09ec946a9df0147ced8655f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4808a875c09ec946a9df0147ced8655f">&#9670;&nbsp;</a></span>VSISetPathSpecificOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSISetPathSpecificOption </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPathPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a path specific option for a given path prefix. </p>
<p>Such option is typically, but not limited to, a credential setting for a virtual file system.</p>
<p>That option may also be set as a configuration option with <a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a>, but this function allows to specify them with a granularity at the level of a file path, which makes it easier if using the same virtual file system but with different credentials (e.g. different credentials for bucket "/vsis3/foo" and "/vsis3/bar")</p>
<p>This is supported for the following virtual file systems: /vsis3/, /vsigs/, /vsiaz/, /vsioss/, /vsiwebhdfs, /vsiswift. Note: setting them for a path starting with /vsiXXX/ will also apply for /vsiXXX_streaming/ requests.</p>
<p>Note that no particular care is taken to store them in RAM in a secure way. So they might accidentally hit persistent storage if swapping occurs, or someone with access to the memory allocated by the process may be able to read them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPathPrefix</td><td>a path prefix of a virtual file system handler. Typically of the form "/vsiXXX/bucket". Must NOT be NULL. Should not include trailing slashes. </td></tr>
    <tr><td class="paramname">pszKey</td><td>Option name. Must NOT be NULL. </td></tr>
    <tr><td class="paramname">pszValue</td><td>Option value. May be NULL to erase it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="aed636b28d00867f63348e13cd6b0a1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed636b28d00867f63348e13cd6b0a1bb">&#9670;&nbsp;</a></span>VSISiblingFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** VSISiblingFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return related filenames. </p>
<p>This function is essentially meant at being used by GDAL internals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of a filename to inspect UTF-8 encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of entries, relative to the directory, of all sidecar files available or NULL if the list is not known. Filenames are returned in UTF-8 encoding. Most implementations will return NULL, and a subsequent ReadDir will list all files available in the file's directory. This function will be overridden by VSI FilesystemHandlers that wish to force e.g. an empty list to avoid opening non-existent files on slow filesystems. The return value shall be destroyed with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="ad1a691db1ba2f43add25a5c0d6498da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a691db1ba2f43add25a5c0d6498da6">&#9670;&nbsp;</a></span>VSIStatExL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIStatExL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *&#160;</td>
          <td class="paramname"><em>psStatBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function, with an extra parameter to specify which information is needed, which offers a potential for speed optimizations on specialized and potentially slow virtual filesystem objects (/vsigzip/, /vsicurl/)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">psStatBuf</td><td>the structure to load with information. </td></tr>
    <tr><td class="paramname">nFlags</td><td>0 to get all information, or VSI_STAT_EXISTS_FLAG, VSI_STAT_NATURE_FLAG, VSI_STAT_SIZE_FLAG, VSI_STAT_SET_ERROR_FLAG, VSI_STAT_CACHE_ONLY or a combination of those to get partial info.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.8.0 </dd></dl>

</div>
</div>
<a id="ac92fbd5e6fc143b026001b32c4c19ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92fbd5e6fc143b026001b32c4c19ed1">&#9670;&nbsp;</a></span>VSIStatL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIStatL </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a05a9e6a14285f31ad3d34390a3d7ac23">VSIStatBufL</a> *&#160;</td>
          <td class="paramname"><em>psStatBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get filesystem object info. </p>
<p>Fetches status information about a filesystem object (file, directory, etc). The returned information is placed in the VSIStatBufL structure. For portability, only use the st_size (size in bytes) and st_mode (file type). This method is similar to VSIStat(), but will work on large files on systems where this requires special calls.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX stat() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the filesystem object to be queried. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">psStatBuf</td><td>the structure to load with information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="adc4a67cc303d7662c34f506d0bdddd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4a67cc303d7662c34f506d0bdddd79">&#9670;&nbsp;</a></span>VSIStdoutSetRedirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VSIStdoutSetRedirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__vsi_8h.html#a121ccf7fcbd054704350f72be08adec8">VSIWriteFunction</a>&#160;</td>
          <td class="paramname"><em>pFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an alternative write function and output file handle instead of fwrite() / stdout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFct</td><td>Function with same signature as fwrite() </td></tr>
    <tr><td class="paramname">stream</td><td>File handle on which to output. Passed to pFct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a5a0e16f51d70ca43d1c67e5dbe664277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0e16f51d70ca43d1c67e5dbe664277">&#9670;&nbsp;</a></span>VSIStrdup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIStrdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of strdup(). </p>
<p>Use <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a> to free </p>

</div>
</div>
<a id="a312ee85ec9884dc16feda2b81de1cc36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312ee85ec9884dc16feda2b81de1cc36">&#9670;&nbsp;</a></span>VSIStrerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* VSIStrerror </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nErrno</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the error string corresponding to the error number. </p>
<p>Do not free it </p>

</div>
</div>
<a id="a2e4e6b2f84be8402bb0bffc23717cb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4e6b2f84be8402bb0bffc23717cb97">&#9670;&nbsp;</a></span>VSISupportsRandomWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VSISupportsRandomWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowLocalTempFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filesystem supports random write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">bAllowLocalTempFile</td><td>whether the file system is allowed to use a local temporary file before uploading to the target location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a5450ce943465f873c4b7039e3388fb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5450ce943465f873c4b7039e3388fb97">&#9670;&nbsp;</a></span>VSISupportsSequentialWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VSISupportsSequentialWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowLocalTempFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filesystem supports sequential write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">bAllowLocalTempFile</td><td>whether the file system is allowed to use a local temporary file before uploading to the target location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a6d1bc0831510b6d134fa4d865b2f1328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1bc0831510b6d134fa4d865b2f1328">&#9670;&nbsp;</a></span>VSISupportsSparseFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSISupportsSparseFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the filesystem supports sparse files. </p>
<p>Only supported on Linux (and no other Unix derivatives) and Windows. On Linux, the answer depends on a few hardcoded signatures for common filesystems. Other filesystems will be considered as not supporting sparse files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszPath</td><td>the path of the filesystem object to be tested. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the file system is known to support sparse files. FALSE may be returned both in cases where it is known to not support them, or when it is unknown.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a6845a21b2c0491c594dd9deef757db6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6845a21b2c0491c594dd9deef757db6b">&#9670;&nbsp;</a></span>VSISync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSISync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pProgressFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>ppapszOutputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize a source file/directory with a target file/directory. </p>
<p>This is a analog of the 'rsync' utility. In the current implementation, rsync would be more efficient for local file copying, but <a class="el" href="cpl__vsi_8h.html#a6845a21b2c0491c594dd9deef757db6b" title="Synchronize a source file/directory with a target file/directory.">VSISync()</a> main interest is when the source or target is a remote file system like /vsis3/ or /vsigs/, in which case it can take into account the timestamps of the files (or optionally the ETag/MD5Sum) to avoid unneeded copy operations.</p>
<p>This is only implemented efficiently for: </p><ul>
<li>
local filesystem &lt;--&gt; remote filesystem. </li>
<li>
remote filesystem &lt;--&gt; remote filesystem (starting with GDAL 3.1). Where the source and target remote filesystems are the same and one of /vsis3/, /vsigs/ or /vsiaz/. Or when the target is /vsiaz/ and the source is /vsis3/, /vsigs/, /vsiadls/ or /vsicurl/ (starting with GDAL 3.8) </li>
</ul>
<p>Similarly to rsync behavior, if the source filename ends with a slash, it means that the content of the directory must be copied, but not the directory name. For example, assuming "/home/even/foo" contains a file "bar", VSISync("/home/even/foo/", "/mnt/media", ...) will create a "/mnt/media/bar" file. Whereas VSISync("/home/even/foo", "/mnt/media", ...) will create a "/mnt/media/foo" directory which contains a bar file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszSource</td><td>Source file or directory. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">pszTarget</td><td>Target file or directory. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Null terminated list of options, or NULL. Currently accepted options are: <ul>
<li>
RECURSIVE=NO (the default is YES) </li>
<li>
<p class="startli">SYNC_STRATEGY=TIMESTAMP/ETAG/OVERWRITE.</p>
<p class="interli">Determines which criterion is used to determine if a target file must be replaced when it already exists and has the same file size as the source. Only applies for a source or target being a network filesystem.</p>
<p class="interli">The default is TIMESTAMP (similarly to how 'aws s3 sync' works), that is to say that for an upload operation, a remote file is replaced if it has a different size or if it is older than the source. For a download operation, a local file is replaced if it has a different size or if it is newer than the remote file.</p>
<p class="interli">The ETAG strategy assumes that the ETag metadata of the remote file is the MD5Sum of the file content, which is only true in the case of /vsis3/ for files not using KMS server side encryption and uploaded in a single PUT operation (so smaller than 50 MB given the default used by GDAL). Only to be used for /vsis3/, /vsigs/ or other filesystems using a MD5Sum as ETAG.</p>
<p class="endli">The OVERWRITE strategy (GDAL &gt;= 3.2) will always overwrite the target file with the source one.  </p>
</li>
<li>
NUM_THREADS=integer. (GDAL &gt;= 3.1) Number of threads to use for parallel file copying. Only use for when /vsis3/, /vsigs/, /vsiaz/ or /vsiadls/ is in source or target. The default is 10 since GDAL 3.3 </li>
<li>
CHUNK_SIZE=integer. (GDAL &gt;= 3.1) Maximum size of chunk (in bytes) to use to split large objects when downloading them from /vsis3/, /vsigs/, /vsiaz/ or /vsiadls/ to local file system, or for upload to /vsis3/, /vsiaz/ or /vsiadls/ from local file system. Only used if NUM_THREADS &gt; 1. For upload to /vsis3/, this chunk size must be set at least to 5 MB. The default is 8 MB since GDAL 3.3 </li>
<li>
x-amz-KEY=value. (GDAL &gt;= 3.5) MIME header to pass during creation of a /vsis3/ object. </li>
<li>
x-goog-KEY=value. (GDAL &gt;= 3.5) MIME header to pass during creation of a /vsigs/ object. </li>
<li>
x-ms-KEY=value. (GDAL &gt;= 3.5) MIME header to pass during creation of a /vsiaz/ or /vsiadls/ object. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pProgressFunc</td><td>Progress callback, or NULL. </td></tr>
    <tr><td class="paramname">pProgressData</td><td>User data of progress callback, or NULL. </td></tr>
    <tr><td class="paramname">ppapszOutputs</td><td>Unused. Should be set to NULL for now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on an error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.4 </dd></dl>

</div>
</div>
<a id="a7ff49d132f70ec46a550c5a51103e394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff49d132f70ec46a550c5a51103e394">&#9670;&nbsp;</a></span>VSIUnlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VSIUnlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file. </p>
<p>Deletes a file object from the file system.</p>
<p>This method goes through the VSIFileHandler virtualization and may work on unusual filesystems such as in memory.</p>
<p>Analog of the POSIX unlink() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFilename</td><td>the path of the file to be deleted. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on an error. </dd></dl>

</div>
</div>
<a id="ad82382a50ea3be8c5c192a27a45b2673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82382a50ea3be8c5c192a27a45b2673">&#9670;&nbsp;</a></span>VSIUnlinkBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* VSIUnlinkBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszFiles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete several files, possibly in a batch. </p>
<p>All files should belong to the same file system handler.</p>
<p>This is implemented efficiently for /vsis3/ and /vsigs/ (provided for /vsigs/ that OAuth2 authentication is used).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">papszFiles</td><td>NULL terminated list of files. UTF-8 encoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of size CSLCount(papszFiles), whose values are TRUE or FALSE depending on the success of deletion of the corresponding file. The array should be freed with <a class="el" href="cpl__vsi_8h.html#af26e15498e19c2a8169db924415ff7ab" title="Analog of free() for data allocated with VSIMalloc(), VSICalloc(), VSIRealloc()">VSIFree()</a>. NULL might be return in case of a more general error (for example, files belonging to different file system handlers)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
