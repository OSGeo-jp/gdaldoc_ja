<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GDAL: ogr_api.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GDAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_95e959066acc6fd9509e74b3cd6c200f.html">ogr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ogr_api.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C API and defines for <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>, <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes.">OGRGeometry</a>, and <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> related classes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;cpl_progress.h&quot;</code><br />
<code>#include &quot;<a class="el" href="cpl__minixml_8h_source.html">cpl_minixml.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ogr__core_8h_source.html">ogr_core.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="ogr__api_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOGRGeometryTypeCounter.html">OGRGeometryTypeCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result item of OGR_L_GetGeometryTypes.  <a href="structOGRGeometryTypeCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6b727e17a6ce846ead38f69e1b86d83a"><td class="memItemLeft" align="right" valign="top"><a id="a6b727e17a6ce846ead38f69e1b86d83a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6b727e17a6ce846ead38f69e1b86d83a">OGR_GEOM_COORD_PRECISION_UNKNOWN</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a6b727e17a6ce846ead38f69e1b86d83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value for a unknown coordinate precision. <br /></td></tr>
<tr class="separator:a6b727e17a6ce846ead38f69e1b86d83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4f116ca0ab67788e6acd2b6dfe1431"><td class="memItemLeft" align="right" valign="top"><a id="a6a4f116ca0ab67788e6acd2b6dfe1431"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6a4f116ca0ab67788e6acd2b6dfe1431">OGR_GEOS_PREC_NO_TOPO</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:a6a4f116ca0ab67788e6acd2b6dfe1431"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option causes <a class="el" href="ogr__api_8h.html#a90133f7d05c95ae681274cce4481c74f" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGR_G_SetPrecision()</a> to not attempt at preserving the topology. <br /></td></tr>
<tr class="separator:a6a4f116ca0ab67788e6acd2b6dfe1431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbc4912c3a3d6afb0d9e56608bae42e"><td class="memItemLeft" align="right" valign="top"><a id="a9cbc4912c3a3d6afb0d9e56608bae42e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9cbc4912c3a3d6afb0d9e56608bae42e">OGR_GEOS_PREC_KEEP_COLLAPSED</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="memdesc:a9cbc4912c3a3d6afb0d9e56608bae42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option causes <a class="el" href="ogr__api_8h.html#a90133f7d05c95ae681274cce4481c74f" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGR_G_SetPrecision()</a> to retain collapsed elements. <br /></td></tr>
<tr class="separator:a9cbc4912c3a3d6afb0d9e56608bae42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343d96cc7bcd6f1c9bb40b055e0ed95c"><td class="memItemLeft" align="right" valign="top"><a id="a343d96cc7bcd6f1c9bb40b055e0ed95c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a343d96cc7bcd6f1c9bb40b055e0ed95c">OGR_GGT_COUNT_NOT_NEEDED</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a343d96cc7bcd6f1c9bb40b055e0ed95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="ogr__api_8h.html#a61c3e553be67cbec0a7794abdc0260ec" title="Get actual geometry types found in features.">OGR_L_GetGeometryTypes()</a> indicating that <a class="el" href="structOGRGeometryTypeCounter.html#a1bc2bc19fda12169023d9b91ecf6a2f2" title="Number of geometries of type eGeomType.">OGRGeometryTypeCounter::nCount</a> value is not needed. <br /></td></tr>
<tr class="separator:a343d96cc7bcd6f1c9bb40b055e0ed95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9b475d328781ef0a61c074ee615b57"><td class="memItemLeft" align="right" valign="top"><a id="acc9b475d328781ef0a61c074ee615b57"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acc9b475d328781ef0a61c074ee615b57">OGR_GGT_STOP_IF_MIXED</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:acc9b475d328781ef0a61c074ee615b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="ogr__api_8h.html#a61c3e553be67cbec0a7794abdc0260ec" title="Get actual geometry types found in features.">OGR_L_GetGeometryTypes()</a> indicating that iteration might stop as sooon as 2 distinct geometry types are found. <br /></td></tr>
<tr class="separator:acc9b475d328781ef0a61c074ee615b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dad3cb02c62f207cafc2487c79d909"><td class="memItemLeft" align="right" valign="top"><a id="a77dad3cb02c62f207cafc2487c79d909"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a77dad3cb02c62f207cafc2487c79d909">OGR_GGT_GEOMCOLLECTIONZ_TINZ</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:a77dad3cb02c62f207cafc2487c79d909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="ogr__api_8h.html#a61c3e553be67cbec0a7794abdc0260ec" title="Get actual geometry types found in features.">OGR_L_GetGeometryTypes()</a> indicating that a GeometryCollectionZ whose first subgeometry is a TinZ should be reported as TinZ. <br /></td></tr>
<tr class="separator:a77dad3cb02c62f207cafc2487c79d909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ecc4eb3468bae5f5deaed761f4221"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a261ecc4eb3468bae5f5deaed761f4221">OGR_FOR_EACH_FEATURE_BEGIN</a>(hFeat,  hLayer)</td></tr>
<tr class="memdesc:a261ecc4eb3468bae5f5deaed761f4221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveniency macro to iterate over features of a layer.  <a href="ogr__api_8h.html#a261ecc4eb3468bae5f5deaed761f4221">More...</a><br /></td></tr>
<tr class="separator:a261ecc4eb3468bae5f5deaed761f4221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1c16c3af1f08084b3c261411beaf99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7c1c16c3af1f08084b3c261411beaf99">OGR_FOR_EACH_FEATURE_END</a>(hFeat)</td></tr>
<tr class="memdesc:a7c1c16c3af1f08084b3c261411beaf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of iterator.  <a href="ogr__api_8h.html#a7c1c16c3af1f08084b3c261411beaf99">More...</a><br /></td></tr>
<tr class="separator:a7c1c16c3af1f08084b3c261411beaf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a147386126eed05cc383cb3eb1b34104c"><td class="memItemLeft" align="right" valign="top"><a id="a147386126eed05cc383cb3eb1b34104c"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a></td></tr>
<tr class="memdesc:a147386126eed05cc383cb3eb1b34104c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a geometry. <br /></td></tr>
<tr class="separator:a147386126eed05cc383cb3eb1b34104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23361112dba57d043fa64632348c0870"><td class="memItemLeft" align="right" valign="top"><a id="a23361112dba57d043fa64632348c0870"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a></td></tr>
<tr class="memdesc:a23361112dba57d043fa64632348c0870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a spatial reference system. <br /></td></tr>
<tr class="separator:a23361112dba57d043fa64632348c0870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069f206f0e8e54328d648c14658cbf81"><td class="memItemLeft" align="right" valign="top"><a id="a069f206f0e8e54328d648c14658cbf81"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a></td></tr>
<tr class="memdesc:a069f206f0e8e54328d648c14658cbf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a coordinate transformation object. <br /></td></tr>
<tr class="separator:a069f206f0e8e54328d648c14658cbf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6f27b9210fc32231a13736ee3f2916"><td class="memItemLeft" align="right" valign="top"><a id="a3f6f27b9210fc32231a13736ee3f2916"></a>
typedef struct <a class="el" href="structOGRGeomCoordinatePrecision.html">OGRGeomCoordinatePrecision</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a></td></tr>
<tr class="memdesc:a3f6f27b9210fc32231a13736ee3f2916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>. <br /></td></tr>
<tr class="separator:a3f6f27b9210fc32231a13736ee3f2916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec7fbf26308ed9dc3158e3f73d2223a"><td class="memItemLeft" align="right" valign="top"><a id="a9ec7fbf26308ed9dc3158e3f73d2223a"></a>
typedef struct <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9ec7fbf26308ed9dc3158e3f73d2223a">OGRwkbExportOptions</a></td></tr>
<tr class="memdesc:a9ec7fbf26308ed9dc3158e3f73d2223a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for WKB export options. <br /></td></tr>
<tr class="separator:a9ec7fbf26308ed9dc3158e3f73d2223a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd327453a3ded09dad8dcfa88170dbb"><td class="memItemLeft" align="right" valign="top"><a id="abfd327453a3ded09dad8dcfa88170dbb"></a>
typedef struct OGRGeomTransformer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a></td></tr>
<tr class="memdesc:abfd327453a3ded09dad8dcfa88170dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a geometry transformer. <br /></td></tr>
<tr class="separator:abfd327453a3ded09dad8dcfa88170dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1edf7eb8c3b0dadf4cc9cdbb777ad3"><td class="memItemLeft" align="right" valign="top"><a id="adc1edf7eb8c3b0dadf4cc9cdbb777ad3"></a>
typedef struct _OGRPreparedGeometry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a></td></tr>
<tr class="memdesc:adc1edf7eb8c3b0dadf4cc9cdbb777ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a prepared geometry. <br /></td></tr>
<tr class="separator:adc1edf7eb8c3b0dadf4cc9cdbb777ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624dc73953f25ea4efd8686d5121249b"><td class="memItemLeft" align="right" valign="top"><a id="a624dc73953f25ea4efd8686d5121249b"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a></td></tr>
<tr class="memdesc:a624dc73953f25ea4efd8686d5121249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a field definition (<a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>) <br /></td></tr>
<tr class="separator:a624dc73953f25ea4efd8686d5121249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827cc74dba4613e928843c4b5f781618"><td class="memItemLeft" align="right" valign="top"><a id="a827cc74dba4613e928843c4b5f781618"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a></td></tr>
<tr class="memdesc:a827cc74dba4613e928843c4b5f781618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a feature definition (<a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>) <br /></td></tr>
<tr class="separator:a827cc74dba4613e928843c4b5f781618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ebb4d695364da5635718ec664b95bf"><td class="memItemLeft" align="right" valign="top"><a id="aa4ebb4d695364da5635718ec664b95bf"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a></td></tr>
<tr class="memdesc:aa4ebb4d695364da5635718ec664b95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a feature (<a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>) <br /></td></tr>
<tr class="separator:aa4ebb4d695364da5635718ec664b95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9fad6abd55f6760170e0e47a7455d8"><td class="memItemLeft" align="right" valign="top"><a id="ade9fad6abd55f6760170e0e47a7455d8"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a></td></tr>
<tr class="memdesc:ade9fad6abd55f6760170e0e47a7455d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a style table (<a class="el" href="classOGRStyleTable.html" title="This class represents a style table.">OGRStyleTable</a>) <br /></td></tr>
<tr class="separator:ade9fad6abd55f6760170e0e47a7455d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02dff2945904f6c0664e17a80c5f6bf"><td class="memItemLeft" align="right" valign="top"><a id="ab02dff2945904f6c0664e17a80c5f6bf"></a>
typedef struct OGRGeomFieldDefnHS *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a></td></tr>
<tr class="memdesc:ab02dff2945904f6c0664e17a80c5f6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a geometry field definition (<a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a>) <br /></td></tr>
<tr class="separator:ab02dff2945904f6c0664e17a80c5f6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbd7571f377f30aac50ed2b22cd9bc7"><td class="memItemLeft" align="right" valign="top"><a id="aafbd7571f377f30aac50ed2b22cd9bc7"></a>
typedef struct OGRFieldDomainHS *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a></td></tr>
<tr class="memdesc:aafbd7571f377f30aac50ed2b22cd9bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a field domain definition (<a class="el" href="classOGRFieldDomain.html" title="Definition of a field domain.">OGRFieldDomain</a>) <br /></td></tr>
<tr class="separator:aafbd7571f377f30aac50ed2b22cd9bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635095fa23dfea934f4bb2df38fb9a67"><td class="memItemLeft" align="right" valign="top"><a id="a635095fa23dfea934f4bb2df38fb9a67"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a></td></tr>
<tr class="memdesc:a635095fa23dfea934f4bb2df38fb9a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a layer (<a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a>) <br /></td></tr>
<tr class="separator:a635095fa23dfea934f4bb2df38fb9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37d6a007fbf6453a11062443c9cc2a4"><td class="memItemLeft" align="right" valign="top"><a id="ae37d6a007fbf6453a11062443c9cc2a4"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a></td></tr>
<tr class="memdesc:ae37d6a007fbf6453a11062443c9cc2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a OGR datasource (<a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a>) <br /></td></tr>
<tr class="separator:ae37d6a007fbf6453a11062443c9cc2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb21d6f230ef8a5d2c1e65bf98473eca"><td class="memItemLeft" align="right" valign="top"><a id="acb21d6f230ef8a5d2c1e65bf98473eca"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a></td></tr>
<tr class="memdesc:acb21d6f230ef8a5d2c1e65bf98473eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type for a OGR driver (<a class="el" href="classOGRSFDriver.html" title="LEGACY class.">OGRSFDriver</a>) <br /></td></tr>
<tr class="separator:acb21d6f230ef8a5d2c1e65bf98473eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e20dd0f2767e72fdf1cd84bfa58edd"><td class="memItemLeft" align="right" valign="top"><a id="a52e20dd0f2767e72fdf1cd84bfa58edd"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a></td></tr>
<tr class="memdesc:a52e20dd0f2767e72fdf1cd84bfa58edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style manager opaque type. <br /></td></tr>
<tr class="separator:a52e20dd0f2767e72fdf1cd84bfa58edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f1ce388fcfa9dfcedf873eb417e1c5"><td class="memItemLeft" align="right" valign="top"><a id="a92f1ce388fcfa9dfcedf873eb417e1c5"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a></td></tr>
<tr class="memdesc:a92f1ce388fcfa9dfcedf873eb417e1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Style tool opaque type. <br /></td></tr>
<tr class="separator:a92f1ce388fcfa9dfcedf873eb417e1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6bcaa56ea34ca19dec8ef120cd34616e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6bcaa56ea34ca19dec8ef120cd34616e">OGRGetGEOSVersion</a> (int *pnMajor, int *pnMinor, int *pnPatch)</td></tr>
<tr class="memdesc:a6bcaa56ea34ca19dec8ef120cd34616e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GEOS version.  <a href="ogr__api_8h.html#a6bcaa56ea34ca19dec8ef120cd34616e">More...</a><br /></td></tr>
<tr class="separator:a6bcaa56ea34ca19dec8ef120cd34616e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88df313ed48b64f371fbbd7ac4021550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88df313ed48b64f371fbbd7ac4021550">OGRGeomCoordinatePrecisionCreate</a> (void)</td></tr>
<tr class="memdesc:a88df313ed48b64f371fbbd7ac4021550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>.  <a href="ogr__api_8h.html#a88df313ed48b64f371fbbd7ac4021550">More...</a><br /></td></tr>
<tr class="separator:a88df313ed48b64f371fbbd7ac4021550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ba15322c93ff0113335525dd6a062f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa8ba15322c93ff0113335525dd6a062f">OGRGeomCoordinatePrecisionDestroy</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:aa8ba15322c93ff0113335525dd6a062f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>.  <a href="ogr__api_8h.html#aa8ba15322c93ff0113335525dd6a062f">More...</a><br /></td></tr>
<tr class="separator:aa8ba15322c93ff0113335525dd6a062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb8a87a442b07ccd069ddf913608585"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9fb8a87a442b07ccd069ddf913608585">OGRGeomCoordinatePrecisionGetXYResolution</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:a9fb8a87a442b07ccd069ddf913608585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the X/Y resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>.  <a href="ogr__api_8h.html#a9fb8a87a442b07ccd069ddf913608585">More...</a><br /></td></tr>
<tr class="separator:a9fb8a87a442b07ccd069ddf913608585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d1a1049ef521c7072dd9e840db9567"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a13d1a1049ef521c7072dd9e840db9567">OGRGeomCoordinatePrecisionGetZResolution</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:a13d1a1049ef521c7072dd9e840db9567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Z resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>.  <a href="ogr__api_8h.html#a13d1a1049ef521c7072dd9e840db9567">More...</a><br /></td></tr>
<tr class="separator:a13d1a1049ef521c7072dd9e840db9567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b92ec14b6fd2ee458aa3f47f3d9ac93"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6b92ec14b6fd2ee458aa3f47f3d9ac93">OGRGeomCoordinatePrecisionGetMResolution</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:a6b92ec14b6fd2ee458aa3f47f3d9ac93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the M resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>.  <a href="ogr__api_8h.html#a6b92ec14b6fd2ee458aa3f47f3d9ac93">More...</a><br /></td></tr>
<tr class="separator:a6b92ec14b6fd2ee458aa3f47f3d9ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dfcd9e95e5cf41962f2b910160f017"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a48dfcd9e95e5cf41962f2b910160f017">OGRGeomCoordinatePrecisionGetFormats</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:a48dfcd9e95e5cf41962f2b910160f017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of format names for coordinate precision format specific options.  <a href="ogr__api_8h.html#a48dfcd9e95e5cf41962f2b910160f017">More...</a><br /></td></tr>
<tr class="separator:a48dfcd9e95e5cf41962f2b910160f017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7030715259644f64ecf8087170db5227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7030715259644f64ecf8087170db5227">OGRGeomCoordinatePrecisionGetFormatSpecificOptions</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>, const char *pszFormatName)</td></tr>
<tr class="memdesc:a7030715259644f64ecf8087170db5227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get format specific coordinate precision options.  <a href="ogr__api_8h.html#a7030715259644f64ecf8087170db5227">More...</a><br /></td></tr>
<tr class="separator:a7030715259644f64ecf8087170db5227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4d3a7bfc56898febdde93ad542ead3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade4d3a7bfc56898febdde93ad542ead3">OGRGeomCoordinatePrecisionSet</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>, double dfXYResolution, double dfZResolution, double dfMResolution)</td></tr>
<tr class="memdesc:ade4d3a7bfc56898febdde93ad542ead3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the resolution of the geometry coordinate components.  <a href="ogr__api_8h.html#ade4d3a7bfc56898febdde93ad542ead3">More...</a><br /></td></tr>
<tr class="separator:ade4d3a7bfc56898febdde93ad542ead3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb9249dce947c203e640ce432547703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aacb9249dce947c203e640ce432547703">OGRGeomCoordinatePrecisionSetFromMeter</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSRS, double dfXYMeterResolution, double dfZMeterResolution, double dfMResolution)</td></tr>
<tr class="memdesc:aacb9249dce947c203e640ce432547703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the resolution of the geometry coordinate components.  <a href="ogr__api_8h.html#aacb9249dce947c203e640ce432547703">More...</a><br /></td></tr>
<tr class="separator:aacb9249dce947c203e640ce432547703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b74fbc01b7c28024d1c0d67d5f9a2b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4b74fbc01b7c28024d1c0d67d5f9a2b7">OGRGeomCoordinatePrecisionSetFormatSpecificOptions</a> (<a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>, const char *pszFormatName, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a4b74fbc01b7c28024d1c0d67d5f9a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set format specific coordinate precision options.  <a href="ogr__api_8h.html#a4b74fbc01b7c28024d1c0d67d5f9a2b7">More...</a><br /></td></tr>
<tr class="separator:a4b74fbc01b7c28024d1c0d67d5f9a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65af51cbb3d62789dee6f96044f4dcb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a65af51cbb3d62789dee6f96044f4dcb6">OGR_G_CreateFromWkb</a> (const void *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *, int)</td></tr>
<tr class="memdesc:a65af51cbb3d62789dee6f96044f4dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known binary representation.  <a href="ogr__api_8h.html#a65af51cbb3d62789dee6f96044f4dcb6">More...</a><br /></td></tr>
<tr class="separator:a65af51cbb3d62789dee6f96044f4dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2f1b68f3dee366c2387e1fc9b32700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c2f1b68f3dee366c2387e1fc9b32700">OGR_G_CreateFromWkbEx</a> (const void *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *, size_t)</td></tr>
<tr class="memdesc:a6c2f1b68f3dee366c2387e1fc9b32700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known binary representation.  <a href="ogr__api_8h.html#a6c2f1b68f3dee366c2387e1fc9b32700">More...</a><br /></td></tr>
<tr class="separator:a6c2f1b68f3dee366c2387e1fc9b32700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02c3ed5f7ebd5039dc2ae70154fd94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">OGR_G_CreateFromWkt</a> (char **, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *)</td></tr>
<tr class="memdesc:ac02c3ed5f7ebd5039dc2ae70154fd94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its well known text representation.  <a href="ogr__api_8h.html#ac02c3ed5f7ebd5039dc2ae70154fd94a">More...</a><br /></td></tr>
<tr class="separator:ac02c3ed5f7ebd5039dc2ae70154fd94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab486f7ab98a4b592d25e4b8a0ac698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3ab486f7ab98a4b592d25e4b8a0ac698">OGR_G_CreateFromFgf</a> (const void *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *, int, int *)</td></tr>
<tr class="memdesc:a3ab486f7ab98a4b592d25e4b8a0ac698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation.  <a href="ogr__api_8h.html#a3ab486f7ab98a4b592d25e4b8a0ac698">More...</a><br /></td></tr>
<tr class="separator:a3ab486f7ab98a4b592d25e4b8a0ac698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e665f5f9690c4fa0c190b930fe9492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">OGR_G_DestroyGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ac4e665f5f9690c4fa0c190b930fe9492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy geometry object.  <a href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492">More...</a><br /></td></tr>
<tr class="separator:ac4e665f5f9690c4fa0c190b930fe9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e47710cf70e5bc72216704ddfead0dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd">OGR_G_CreateGeometry</a> (<a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:a4e47710cf70e5bc72216704ddfead0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty geometry of desired type.  <a href="ogr__api_8h.html#a4e47710cf70e5bc72216704ddfead0dd">More...</a><br /></td></tr>
<tr class="separator:a4e47710cf70e5bc72216704ddfead0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9ee71d0030dc30bdd595c37ab71062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7c9ee71d0030dc30bdd595c37ab71062">OGR_G_ApproximateArcAngles</a> (double dfCenterX, double dfCenterY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees)</td></tr>
<tr class="memdesc:a7c9ee71d0030dc30bdd595c37ab71062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke arc to linestring.  <a href="ogr__api_8h.html#a7c9ee71d0030dc30bdd595c37ab71062">More...</a><br /></td></tr>
<tr class="separator:a7c9ee71d0030dc30bdd595c37ab71062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d5e3d348db62e46ebba718edb36abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4d5e3d348db62e46ebba718edb36abe">OGR_G_ForceToPolygon</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ac4d5e3d348db62e46ebba718edb36abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to polygon.  <a href="ogr__api_8h.html#ac4d5e3d348db62e46ebba718edb36abe">More...</a><br /></td></tr>
<tr class="separator:ac4d5e3d348db62e46ebba718edb36abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670481ed69704f2be0c2c24a304d3bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a670481ed69704f2be0c2c24a304d3bf5">OGR_G_ForceToLineString</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a670481ed69704f2be0c2c24a304d3bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to line string.  <a href="ogr__api_8h.html#a670481ed69704f2be0c2c24a304d3bf5">More...</a><br /></td></tr>
<tr class="separator:a670481ed69704f2be0c2c24a304d3bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea3d494951ab99e72b59cbd5318e8c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abea3d494951ab99e72b59cbd5318e8c4">OGR_G_ForceToMultiPolygon</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:abea3d494951ab99e72b59cbd5318e8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multipolygon.  <a href="ogr__api_8h.html#abea3d494951ab99e72b59cbd5318e8c4">More...</a><br /></td></tr>
<tr class="separator:abea3d494951ab99e72b59cbd5318e8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd1952b5cde54253746d9da1a2b0500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aedd1952b5cde54253746d9da1a2b0500">OGR_G_ForceToMultiPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:aedd1952b5cde54253746d9da1a2b0500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multipoint.  <a href="ogr__api_8h.html#aedd1952b5cde54253746d9da1a2b0500">More...</a><br /></td></tr>
<tr class="separator:aedd1952b5cde54253746d9da1a2b0500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d8424596b90664b7280a9e7c89dc96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac3d8424596b90664b7280a9e7c89dc96">OGR_G_ForceToMultiLineString</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ac3d8424596b90664b7280a9e7c89dc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to multilinestring.  <a href="ogr__api_8h.html#ac3d8424596b90664b7280a9e7c89dc96">More...</a><br /></td></tr>
<tr class="separator:ac3d8424596b90664b7280a9e7c89dc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5f995d159279739909196d45ba09e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4e5f995d159279739909196d45ba09e5">OGR_G_ForceTo</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> eTargetType, char **papszOptions)</td></tr>
<tr class="memdesc:a4e5f995d159279739909196d45ba09e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to another geometry type.  <a href="ogr__api_8h.html#a4e5f995d159279739909196d45ba09e5">More...</a><br /></td></tr>
<tr class="separator:a4e5f995d159279739909196d45ba09e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace05a6716d40b2f52fe929ab482ff3bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ace05a6716d40b2f52fe929ab482ff3bf">OGR_G_RemoveLowerDimensionSubGeoms</a> (const <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:ace05a6716d40b2f52fe929ab482ff3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection.  <a href="ogr__api_8h.html#ace05a6716d40b2f52fe929ab482ff3bf">More...</a><br /></td></tr>
<tr class="separator:ace05a6716d40b2f52fe929ab482ff3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b633e1acd208c258ad49f8d4fd4104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104">OGR_G_GetDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a94b633e1acd208c258ad49f8d4fd4104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of this geometry.  <a href="ogr__api_8h.html#a94b633e1acd208c258ad49f8d4fd4104">More...</a><br /></td></tr>
<tr class="separator:a94b633e1acd208c258ad49f8d4fd4104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5e78b0753339d1cdd282b0e151d28f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f">OGR_G_GetCoordinateDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a8a5e78b0753339d1cdd282b0e151d28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this geometry.  <a href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f">More...</a><br /></td></tr>
<tr class="separator:a8a5e78b0753339d1cdd282b0e151d28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4843a200c0c4e57bbdc99e509f68baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf">OGR_G_CoordinateDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ac4843a200c0c4e57bbdc99e509f68baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of the coordinates in this geometry.  <a href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf">More...</a><br /></td></tr>
<tr class="separator:ac4843a200c0c4e57bbdc99e509f68baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bcad9553f488f7d8b6c8674cf7771c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac6bcad9553f488f7d8b6c8674cf7771c">OGR_G_SetCoordinateDimension</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:ac6bcad9553f488f7d8b6c8674cf7771c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the coordinate dimension.  <a href="ogr__api_8h.html#ac6bcad9553f488f7d8b6c8674cf7771c">More...</a><br /></td></tr>
<tr class="separator:ac6bcad9553f488f7d8b6c8674cf7771c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d4c2fb8935e9ee9584f0243e4bd0ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af2d4c2fb8935e9ee9584f0243e4bd0ca">OGR_G_Is3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:af2d4c2fb8935e9ee9584f0243e4bd0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">See whether this geometry has Z coordinates.  <a href="ogr__api_8h.html#af2d4c2fb8935e9ee9584f0243e4bd0ca">More...</a><br /></td></tr>
<tr class="separator:af2d4c2fb8935e9ee9584f0243e4bd0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a8bf231d721ac04ed465d5208bac6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a84a8bf231d721ac04ed465d5208bac6e">OGR_G_IsMeasured</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a84a8bf231d721ac04ed465d5208bac6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See whether this geometry is measured.  <a href="ogr__api_8h.html#a84a8bf231d721ac04ed465d5208bac6e">More...</a><br /></td></tr>
<tr class="separator:a84a8bf231d721ac04ed465d5208bac6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c109c8afc2c614f206f8f610c7c4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a13c109c8afc2c614f206f8f610c7c4be">OGR_G_Set3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a13c109c8afc2c614f206f8f610c7c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the Z coordinate dimension.  <a href="ogr__api_8h.html#a13c109c8afc2c614f206f8f610c7c4be">More...</a><br /></td></tr>
<tr class="separator:a13c109c8afc2c614f206f8f610c7c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8840ed4e65bfbf50a6a52779305a78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8840ed4e65bfbf50a6a52779305a78f6">OGR_G_SetMeasured</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a8840ed4e65bfbf50a6a52779305a78f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add or remove the M coordinate dimension.  <a href="ogr__api_8h.html#a8840ed4e65bfbf50a6a52779305a78f6">More...</a><br /></td></tr>
<tr class="separator:a8840ed4e65bfbf50a6a52779305a78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1725918932da7d59f9ee72829ac171fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa">OGR_G_Clone</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a1725918932da7d59f9ee72829ac171fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of this object.  <a href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa">More...</a><br /></td></tr>
<tr class="separator:a1725918932da7d59f9ee72829ac171fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617a9c9ea85157661619a1d8f0a69cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9">OGR_G_GetEnvelope</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *)</td></tr>
<tr class="memdesc:a617a9c9ea85157661619a1d8f0a69cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.  <a href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9">More...</a><br /></td></tr>
<tr class="separator:a617a9c9ea85157661619a1d8f0a69cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a950633ac824042b0afdb88c670c5ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce">OGR_G_GetEnvelope3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *)</td></tr>
<tr class="memdesc:a9a950633ac824042b0afdb88c670c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure.  <a href="ogr__api_8h.html#a9a950633ac824042b0afdb88c670c5ce">More...</a><br /></td></tr>
<tr class="separator:a9a950633ac824042b0afdb88c670c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae523fe14c8c87dffcee706438ec2e81f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f">OGR_G_ImportFromWkb</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, const void *, int)</td></tr>
<tr class="memdesc:ae523fe14c8c87dffcee706438ec2e81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known binary data.  <a href="ogr__api_8h.html#ae523fe14c8c87dffcee706438ec2e81f">More...</a><br /></td></tr>
<tr class="separator:ae523fe14c8c87dffcee706438ec2e81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c94ae76c09774dba8725c24daeefd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6">OGR_G_ExportToWkb</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *)</td></tr>
<tr class="memdesc:ad5c94ae76c09774dba8725c24daeefd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry well known binary format.  <a href="ogr__api_8h.html#ad5c94ae76c09774dba8725c24daeefd6">More...</a><br /></td></tr>
<tr class="separator:ad5c94ae76c09774dba8725c24daeefd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622a18776e6d51515d0f2ff0ee211d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91">OGR_G_ExportToIsoWkb</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>, unsigned char *)</td></tr>
<tr class="memdesc:a622a18776e6d51515d0f2ff0ee211d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.  <a href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91">More...</a><br /></td></tr>
<tr class="separator:a622a18776e6d51515d0f2ff0ee211d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fd87e8fdaa144dc7b3fa7dfa1f1582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac0fd87e8fdaa144dc7b3fa7dfa1f1582">OGRwkbExportOptionsCreate</a> (void)</td></tr>
<tr class="memdesc:ac0fd87e8fdaa144dc7b3fa7dfa1f1582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry WKB export options.  <a href="ogr__api_8h.html#ac0fd87e8fdaa144dc7b3fa7dfa1f1582">More...</a><br /></td></tr>
<tr class="separator:ac0fd87e8fdaa144dc7b3fa7dfa1f1582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09772060693f83825a84fefccde55579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a09772060693f83825a84fefccde55579">OGRwkbExportOptionsDestroy</a> (<a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *)</td></tr>
<tr class="memdesc:a09772060693f83825a84fefccde55579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy object returned by <a class="el" href="ogr__api_8h.html#ac0fd87e8fdaa144dc7b3fa7dfa1f1582" title="Create geometry WKB export options.">OGRwkbExportOptionsCreate()</a>  <a href="ogr__api_8h.html#a09772060693f83825a84fefccde55579">More...</a><br /></td></tr>
<tr class="separator:a09772060693f83825a84fefccde55579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37004f0eb914340874e9da08975c76f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a37004f0eb914340874e9da08975c76f7">OGRwkbExportOptionsSetByteOrder</a> (<a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *, <a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>)</td></tr>
<tr class="memdesc:a37004f0eb914340874e9da08975c76f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the WKB byte order.  <a href="ogr__api_8h.html#a37004f0eb914340874e9da08975c76f7">More...</a><br /></td></tr>
<tr class="separator:a37004f0eb914340874e9da08975c76f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68b69a13ac7f162c8a240c2daa957a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab68b69a13ac7f162c8a240c2daa957a3">OGRwkbExportOptionsSetVariant</a> (<a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *, <a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>)</td></tr>
<tr class="memdesc:ab68b69a13ac7f162c8a240c2daa957a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the WKB variant.  <a href="ogr__api_8h.html#ab68b69a13ac7f162c8a240c2daa957a3">More...</a><br /></td></tr>
<tr class="separator:ab68b69a13ac7f162c8a240c2daa957a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45319b3639338ced05d17e543444c882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a45319b3639338ced05d17e543444c882">OGRwkbExportOptionsSetPrecision</a> (<a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *, <a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:a45319b3639338ced05d17e543444c882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set precision options.  <a href="ogr__api_8h.html#a45319b3639338ced05d17e543444c882">More...</a><br /></td></tr>
<tr class="separator:a45319b3639338ced05d17e543444c882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18ca8de10fb5fc90705d4e91791566f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae18ca8de10fb5fc90705d4e91791566f">OGR_G_ExportToWkbEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, unsigned char *, const <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *)</td></tr>
<tr class="memdesc:ae18ca8de10fb5fc90705d4e91791566f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known binary format.  <a href="ogr__api_8h.html#ae18ca8de10fb5fc90705d4e91791566f">More...</a><br /></td></tr>
<tr class="separator:ae18ca8de10fb5fc90705d4e91791566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7035a933b957a9d453184c154c237c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c">OGR_G_WkbSize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a5f7035a933b957a9d453184c154c237c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of related binary representation.  <a href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c">More...</a><br /></td></tr>
<tr class="separator:a5f7035a933b957a9d453184c154c237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db2efdc712cb6b3f15d45905e6f712"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a39db2efdc712cb6b3f15d45905e6f712">OGR_G_WkbSizeEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a39db2efdc712cb6b3f15d45905e6f712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size of related binary representation.  <a href="ogr__api_8h.html#a39db2efdc712cb6b3f15d45905e6f712">More...</a><br /></td></tr>
<tr class="separator:a39db2efdc712cb6b3f15d45905e6f712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4286ba243fb05a831a49f52aabcbc6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8">OGR_G_ImportFromWkt</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **)</td></tr>
<tr class="memdesc:a4286ba243fb05a831a49f52aabcbc6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign geometry from well known text data.  <a href="ogr__api_8h.html#a4286ba243fb05a831a49f52aabcbc6f8">More...</a><br /></td></tr>
<tr class="separator:a4286ba243fb05a831a49f52aabcbc6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc9310302e2dbfaab1690de9e2fd2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb">OGR_G_ExportToWkt</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **)</td></tr>
<tr class="memdesc:a3bc9310302e2dbfaab1690de9e2fd2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into well known text format.  <a href="ogr__api_8h.html#a3bc9310302e2dbfaab1690de9e2fd2fb">More...</a><br /></td></tr>
<tr class="separator:a3bc9310302e2dbfaab1690de9e2fd2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d988d220539479601e1a80a58864d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0d988d220539479601e1a80a58864d1e">OGR_G_ExportToIsoWkt</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **)</td></tr>
<tr class="memdesc:a0d988d220539479601e1a80a58864d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format.  <a href="ogr__api_8h.html#a0d988d220539479601e1a80a58864d1e">More...</a><br /></td></tr>
<tr class="separator:a0d988d220539479601e1a80a58864d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fae58102f5c4a4cf2526e5ca8369a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76">OGR_G_GetGeometryType</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a8fae58102f5c4a4cf2526e5ca8369a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type.  <a href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76">More...</a><br /></td></tr>
<tr class="separator:a8fae58102f5c4a4cf2526e5ca8369a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18121f835b2fb724a0c1a87beb1a437a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a">OGR_G_GetGeometryName</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a18121f835b2fb724a0c1a87beb1a437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch WKT name for geometry type.  <a href="ogr__api_8h.html#a18121f835b2fb724a0c1a87beb1a437a">More...</a><br /></td></tr>
<tr class="separator:a18121f835b2fb724a0c1a87beb1a437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a99330bd108940f8a33036c0f83119f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f">OGR_G_DumpReadable</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, FILE *, const char *)</td></tr>
<tr class="memdesc:a3a99330bd108940f8a33036c0f83119f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump geometry in well known text format to indicated output file.  <a href="ogr__api_8h.html#a3a99330bd108940f8a33036c0f83119f">More...</a><br /></td></tr>
<tr class="separator:a3a99330bd108940f8a33036c0f83119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb7354b55c7448b60b44cd9e36073b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8">OGR_G_FlattenTo2D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:afdb7354b55c7448b60b44cd9e36073b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert geometry to strictly 2D.  <a href="ogr__api_8h.html#afdb7354b55c7448b60b44cd9e36073b8">More...</a><br /></td></tr>
<tr class="separator:afdb7354b55c7448b60b44cd9e36073b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeb849dcfd4fdf4d6dab66e6ea697c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acfeb849dcfd4fdf4d6dab66e6ea697c0">OGR_G_CloseRings</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:acfeb849dcfd4fdf4d6dab66e6ea697c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force rings to be closed.  <a href="ogr__api_8h.html#acfeb849dcfd4fdf4d6dab66e6ea697c0">More...</a><br /></td></tr>
<tr class="separator:acfeb849dcfd4fdf4d6dab66e6ea697c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef37aa4d89f303fee679f97d32461d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aef37aa4d89f303fee679f97d32461d69">OGR_G_CreateFromGML</a> (const char *)</td></tr>
<tr class="memdesc:aef37aa4d89f303fee679f97d32461d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GML.  <a href="ogr__api_8h.html#aef37aa4d89f303fee679f97d32461d69">More...</a><br /></td></tr>
<tr class="separator:aef37aa4d89f303fee679f97d32461d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c473bd75c553d2bbae1aed480f8c34d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3c473bd75c553d2bbae1aed480f8c34d">OGR_G_ExportToGML</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a3c473bd75c553d2bbae1aed480f8c34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="ogr__api_8h.html#a3c473bd75c553d2bbae1aed480f8c34d">More...</a><br /></td></tr>
<tr class="separator:a3c473bd75c553d2bbae1aed480f8c34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fc1cec4a17a2926640f95c6bf7a442"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a06fc1cec4a17a2926640f95c6bf7a442">OGR_G_ExportToGMLEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **papszOptions)</td></tr>
<tr class="memdesc:a06fc1cec4a17a2926640f95c6bf7a442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format.  <a href="ogr__api_8h.html#a06fc1cec4a17a2926640f95c6bf7a442">More...</a><br /></td></tr>
<tr class="separator:a06fc1cec4a17a2926640f95c6bf7a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ec47f76c9890fa4576f01b1690f6a8"><td class="memItemLeft" align="right" valign="top"><a id="a92ec47f76c9890fa4576f01b1690f6a8"></a>
<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a92ec47f76c9890fa4576f01b1690f6a8">OGR_G_CreateFromGMLTree</a> (const <a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *)</td></tr>
<tr class="memdesc:a92ec47f76c9890fa4576f01b1690f6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create geometry from GML. <br /></td></tr>
<tr class="separator:a92ec47f76c9890fa4576f01b1690f6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e89d8743ea9595120870339da61808"><td class="memItemLeft" align="right" valign="top"><a id="af2e89d8743ea9595120870339da61808"></a>
<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af2e89d8743ea9595120870339da61808">OGR_G_ExportToGMLTree</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:af2e89d8743ea9595120870339da61808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GML format. <br /></td></tr>
<tr class="separator:af2e89d8743ea9595120870339da61808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420fc8fc38412167e8cfd94e965d50f7"><td class="memItemLeft" align="right" valign="top"><a id="a420fc8fc38412167e8cfd94e965d50f7"></a>
<a class="el" href="structCPLXMLNode.html">CPLXMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a420fc8fc38412167e8cfd94e965d50f7">OGR_G_ExportEnvelopeToGMLTree</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a420fc8fc38412167e8cfd94e965d50f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the envelope of a geometry as a gml:Box. <br /></td></tr>
<tr class="separator:a420fc8fc38412167e8cfd94e965d50f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b1389e05c84261a7b612aefedd0ed3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3">OGR_G_ExportToKML</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, const char *pszAltitudeMode)</td></tr>
<tr class="memdesc:a27b1389e05c84261a7b612aefedd0ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into KML format.  <a href="ogr__api_8h.html#a27b1389e05c84261a7b612aefedd0ed3">More...</a><br /></td></tr>
<tr class="separator:a27b1389e05c84261a7b612aefedd0ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebd5fa6a9b67ff6ce5a7e4cd0238a47"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">OGR_G_ExportToJson</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a9ebd5fa6a9b67ff6ce5a7e4cd0238a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="ogr__api_8h.html#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">More...</a><br /></td></tr>
<tr class="separator:a9ebd5fa6a9b67ff6ce5a7e4cd0238a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f1713300ac83c3cf31f40b419b9c0d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a97f1713300ac83c3cf31f40b419b9c0d">OGR_G_ExportToJsonEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, char **papszOptions)</td></tr>
<tr class="memdesc:a97f1713300ac83c3cf31f40b419b9c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry into GeoJSON format.  <a href="ogr__api_8h.html#a97f1713300ac83c3cf31f40b419b9c0d">More...</a><br /></td></tr>
<tr class="separator:a97f1713300ac83c3cf31f40b419b9c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4726f8a2f0012492bcb60a56c7dd90"><td class="memItemLeft" align="right" valign="top"><a id="aee4726f8a2f0012492bcb60a56c7dd90"></a>
<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aee4726f8a2f0012492bcb60a56c7dd90">OGR_G_CreateGeometryFromJson</a> (const char *)</td></tr>
<tr class="memdesc:aee4726f8a2f0012492bcb60a56c7dd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OGR geometry from a GeoJSON geometry object. <br /></td></tr>
<tr class="separator:aee4726f8a2f0012492bcb60a56c7dd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ae495b5ed78bc15d155d670a45435e"><td class="memItemLeft" align="right" valign="top"><a id="a37ae495b5ed78bc15d155d670a45435e"></a>
<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a37ae495b5ed78bc15d155d670a45435e">OGR_G_CreateGeometryFromEsriJson</a> (const char *)</td></tr>
<tr class="memdesc:a37ae495b5ed78bc15d155d670a45435e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a OGR geometry from a ESRI JSON geometry object. <br /></td></tr>
<tr class="separator:a37ae495b5ed78bc15d155d670a45435e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfbd5861e1cd20b372d090539fa4536"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536">OGR_G_AssignSpatialReference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>)</td></tr>
<tr class="memdesc:a4dfbd5861e1cd20b372d090539fa4536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign spatial reference to this object.  <a href="ogr__api_8h.html#a4dfbd5861e1cd20b372d090539fa4536">More...</a><br /></td></tr>
<tr class="separator:a4dfbd5861e1cd20b372d090539fa4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc393e40282eec3801fb4a4abc9e25bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf">OGR_G_GetSpatialReference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:abc393e40282eec3801fb4a4abc9e25bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns spatial reference system for geometry.  <a href="ogr__api_8h.html#abc393e40282eec3801fb4a4abc9e25bf">More...</a><br /></td></tr>
<tr class="separator:abc393e40282eec3801fb4a4abc9e25bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a5b3f954b11cfbf6e78807c28d6090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090">OGR_G_Transform</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>)</td></tr>
<tr class="memdesc:a59a5b3f954b11cfbf6e78807c28d6090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply arbitrary coordinate transformation to geometry.  <a href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090">More...</a><br /></td></tr>
<tr class="separator:a59a5b3f954b11cfbf6e78807c28d6090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43af4c2127cea0a5059692a62c0feb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63">OGR_G_TransformTo</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>)</td></tr>
<tr class="memdesc:a43af4c2127cea0a5059692a62c0feb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform geometry to new spatial reference system.  <a href="ogr__api_8h.html#a43af4c2127cea0a5059692a62c0feb63">More...</a><br /></td></tr>
<tr class="separator:a43af4c2127cea0a5059692a62c0feb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6c040db3eed60df29528eee8b67d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d6c040db3eed60df29528eee8b67d1d">OGR_GeomTransformer_Create</a> (<a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:a9d6c040db3eed60df29528eee8b67d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a geometry transformer.  <a href="ogr__api_8h.html#a9d6c040db3eed60df29528eee8b67d1d">More...</a><br /></td></tr>
<tr class="separator:a9d6c040db3eed60df29528eee8b67d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b248b82b3898573f8b6ff6fb87d5d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a64b248b82b3898573f8b6ff6fb87d5d8">OGR_GeomTransformer_Transform</a> (<a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a> hTransformer, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a64b248b82b3898573f8b6ff6fb87d5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a geometry.  <a href="ogr__api_8h.html#a64b248b82b3898573f8b6ff6fb87d5d8">More...</a><br /></td></tr>
<tr class="separator:a64b248b82b3898573f8b6ff6fb87d5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5729c801d758baee9dc23b95ac80f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae5729c801d758baee9dc23b95ac80f55">OGR_GeomTransformer_Destroy</a> (<a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a> hTransformer)</td></tr>
<tr class="memdesc:ae5729c801d758baee9dc23b95ac80f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a geometry transformer allocated with <a class="el" href="ogr__api_8h.html#a9d6c040db3eed60df29528eee8b67d1d" title="Create a geometry transformer.">OGR_GeomTransformer_Create()</a>  <a href="ogr__api_8h.html#ae5729c801d758baee9dc23b95ac80f55">More...</a><br /></td></tr>
<tr class="separator:ae5729c801d758baee9dc23b95ac80f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0453f97e9d4fc44e13787ad1a8439c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c">OGR_G_Simplify</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hThis, double tolerance)</td></tr>
<tr class="memdesc:a0453f97e9d4fc44e13787ad1a8439c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a simplified geometry.  <a href="ogr__api_8h.html#a0453f97e9d4fc44e13787ad1a8439c0c">More...</a><br /></td></tr>
<tr class="separator:a0453f97e9d4fc44e13787ad1a8439c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e19e9cfa01744db6a2e8eee710611b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6">OGR_G_SimplifyPreserveTopology</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hThis, double tolerance)</td></tr>
<tr class="memdesc:a8e19e9cfa01744db6a2e8eee710611b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the geometry while preserving topology.  <a href="ogr__api_8h.html#a8e19e9cfa01744db6a2e8eee710611b6">More...</a><br /></td></tr>
<tr class="separator:a8e19e9cfa01744db6a2e8eee710611b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf65b24716b3538cb883de3fa0d35a8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acf65b24716b3538cb883de3fa0d35a8a">OGR_G_DelaunayTriangulation</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hThis, double dfTolerance, int bOnlyEdges)</td></tr>
<tr class="memdesc:acf65b24716b3538cb883de3fa0d35a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Delaunay triangulation of the vertices of the geometry.  <a href="ogr__api_8h.html#acf65b24716b3538cb883de3fa0d35a8a">More...</a><br /></td></tr>
<tr class="separator:acf65b24716b3538cb883de3fa0d35a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9f08c8d63bc0e726cb20c201c86423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423">OGR_G_Segmentize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, double dfMaxLength)</td></tr>
<tr class="memdesc:ade9f08c8d63bc0e726cb20c201c86423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the geometry such it has no segment longer then the given distance.  <a href="ogr__api_8h.html#ade9f08c8d63bc0e726cb20c201c86423">More...</a><br /></td></tr>
<tr class="separator:ade9f08c8d63bc0e726cb20c201c86423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaed6926b75cd33a42b284c10def6e87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87">OGR_G_Intersects</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:acaed6926b75cd33a42b284c10def6e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do these features intersect?  <a href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87">More...</a><br /></td></tr>
<tr class="separator:acaed6926b75cd33a42b284c10def6e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaed0c4fb6f08abc280f91619e2e47d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3">OGR_G_Equals</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:abaed0c4fb6f08abc280f91619e2e47d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if two geometries are equivalent.  <a href="ogr__api_8h.html#abaed0c4fb6f08abc280f91619e2e47d3">More...</a><br /></td></tr>
<tr class="separator:abaed0c4fb6f08abc280f91619e2e47d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980d65f3d82d5a5442c5141efe3f503"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503">OGR_G_Disjoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7980d65f3d82d5a5442c5141efe3f503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for disjointness.  <a href="ogr__api_8h.html#a7980d65f3d82d5a5442c5141efe3f503">More...</a><br /></td></tr>
<tr class="separator:a7980d65f3d82d5a5442c5141efe3f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67616eb88f479eba50f9783c8494d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9">OGR_G_Touches</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a6f67616eb88f479eba50f9783c8494d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for touching.  <a href="ogr__api_8h.html#a6f67616eb88f479eba50f9783c8494d9">More...</a><br /></td></tr>
<tr class="separator:a6f67616eb88f479eba50f9783c8494d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af82e14406879c08841331b2a4cfe7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c">OGR_G_Crosses</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7af82e14406879c08841331b2a4cfe7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for crossing.  <a href="ogr__api_8h.html#a7af82e14406879c08841331b2a4cfe7c">More...</a><br /></td></tr>
<tr class="separator:a7af82e14406879c08841331b2a4cfe7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ba9e516ccae381ae7240cc9684eb72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72">OGR_G_Within</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a80ba9e516ccae381ae7240cc9684eb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="ogr__api_8h.html#a80ba9e516ccae381ae7240cc9684eb72">More...</a><br /></td></tr>
<tr class="separator:a80ba9e516ccae381ae7240cc9684eb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87e37380f0320faddbe5e67e23312f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8">OGR_G_Contains</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ad87e37380f0320faddbe5e67e23312f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for containment.  <a href="ogr__api_8h.html#ad87e37380f0320faddbe5e67e23312f8">More...</a><br /></td></tr>
<tr class="separator:ad87e37380f0320faddbe5e67e23312f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07acfe1bef39cd2cd1ad4a5ec26f2ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">OGR_G_Overlaps</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a07acfe1bef39cd2cd1ad4a5ec26f2ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for overlap.  <a href="ogr__api_8h.html#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">More...</a><br /></td></tr>
<tr class="separator:a07acfe1bef39cd2cd1ad4a5ec26f2ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95447f722f907b7143a1fc19005dd20b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b">OGR_G_Boundary</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a95447f722f907b7143a1fc19005dd20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute boundary.  <a href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b">More...</a><br /></td></tr>
<tr class="separator:a95447f722f907b7143a1fc19005dd20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a93026cfae8ee6ce25546dba1b2df7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d">OGR_G_ConvexHull</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7a93026cfae8ee6ce25546dba1b2df7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convex hull.  <a href="ogr__api_8h.html#a7a93026cfae8ee6ce25546dba1b2df7d">More...</a><br /></td></tr>
<tr class="separator:a7a93026cfae8ee6ce25546dba1b2df7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f11850c5ed2f86b99e4682178c6797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a32f11850c5ed2f86b99e4682178c6797">OGR_G_ConcaveHull</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double dfRatio, bool bAllowHoles)</td></tr>
<tr class="memdesc:a32f11850c5ed2f86b99e4682178c6797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute "concave hull" of a geometry.  <a href="ogr__api_8h.html#a32f11850c5ed2f86b99e4682178c6797">More...</a><br /></td></tr>
<tr class="separator:a32f11850c5ed2f86b99e4682178c6797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ad99b74f10fe63cdf81d8674edfc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a398ad99b74f10fe63cdf81d8674edfc2">OGR_G_Buffer</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double dfDist, int nQuadSegs)</td></tr>
<tr class="memdesc:a398ad99b74f10fe63cdf81d8674edfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <a href="ogr__api_8h.html#a398ad99b74f10fe63cdf81d8674edfc2">More...</a><br /></td></tr>
<tr class="separator:a398ad99b74f10fe63cdf81d8674edfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6daaf8d57da28ab6c45b8a8b3094901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6daaf8d57da28ab6c45b8a8b3094901">OGR_G_BufferEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double dfDist, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> papszOptions)</td></tr>
<tr class="memdesc:aa6daaf8d57da28ab6c45b8a8b3094901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute buffer of geometry.  <a href="ogr__api_8h.html#aa6daaf8d57da28ab6c45b8a8b3094901">More...</a><br /></td></tr>
<tr class="separator:aa6daaf8d57da28ab6c45b8a8b3094901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a271b5c7b72994120e7a6bbc7e7e5cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb">OGR_G_Intersection</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a5a271b5c7b72994120e7a6bbc7e7e5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute intersection.  <a href="ogr__api_8h.html#a5a271b5c7b72994120e7a6bbc7e7e5cb">More...</a><br /></td></tr>
<tr class="separator:a5a271b5c7b72994120e7a6bbc7e7e5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58f2cfbdb2497659d2eabea73d3b8a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0">OGR_G_Union</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:af58f2cfbdb2497659d2eabea73d3b8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union.  <a href="ogr__api_8h.html#af58f2cfbdb2497659d2eabea73d3b8a0">More...</a><br /></td></tr>
<tr class="separator:af58f2cfbdb2497659d2eabea73d3b8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb45d7d6ca9641be5f0773f1d60aa0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f">OGR_G_UnionCascaded</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a2bb45d7d6ca9641be5f0773f1d60aa0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute union using cascading.  <a href="ogr__api_8h.html#a2bb45d7d6ca9641be5f0773f1d60aa0f">More...</a><br /></td></tr>
<tr class="separator:a2bb45d7d6ca9641be5f0773f1d60aa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e284189448b23bc3dae1ad7ab54b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae4e284189448b23bc3dae1ad7ab54b50">OGR_G_UnaryUnion</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ae4e284189448b23bc3dae1ad7ab54b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the union of all components of a single geometry.  <a href="ogr__api_8h.html#ae4e284189448b23bc3dae1ad7ab54b50">More...</a><br /></td></tr>
<tr class="separator:ae4e284189448b23bc3dae1ad7ab54b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89dc63f138aee453cf8ff3e2b1c0833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">OGR_G_PointOnSurface</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:af89dc63f138aee453cf8ff3e2b1c0833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a point guaranteed to lie on the surface.  <a href="ogr__api_8h.html#af89dc63f138aee453cf8ff3e2b1c0833">More...</a><br /></td></tr>
<tr class="separator:af89dc63f138aee453cf8ff3e2b1c0833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497977bec6ecd9dade7a9694f776be64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64">OGR_G_Difference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a497977bec6ecd9dade7a9694f776be64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute difference.  <a href="ogr__api_8h.html#a497977bec6ecd9dade7a9694f776be64">More...</a><br /></td></tr>
<tr class="separator:a497977bec6ecd9dade7a9694f776be64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b047fca89d06a08a5c34f210c4c97d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5">OGR_G_SymDifference</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a2b047fca89d06a08a5c34f210c4c97d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symmetric difference.  <a href="ogr__api_8h.html#a2b047fca89d06a08a5c34f210c4c97d5">More...</a><br /></td></tr>
<tr class="separator:a2b047fca89d06a08a5c34f210c4c97d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01002a9fd4175832af965930f069401"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401">OGR_G_Distance</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ab01002a9fd4175832af965930f069401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two geometries.  <a href="ogr__api_8h.html#ab01002a9fd4175832af965930f069401">More...</a><br /></td></tr>
<tr class="separator:ab01002a9fd4175832af965930f069401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7313a805a15bf78a26c52ff1bc6242e2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7313a805a15bf78a26c52ff1bc6242e2">OGR_G_Distance3D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7313a805a15bf78a26c52ff1bc6242e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3D distance between two geometries.  <a href="ogr__api_8h.html#a7313a805a15bf78a26c52ff1bc6242e2">More...</a><br /></td></tr>
<tr class="separator:a7313a805a15bf78a26c52ff1bc6242e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb038c3271dbf41ac7ebc02fad3907f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5eb038c3271dbf41ac7ebc02fad3907f">OGR_G_Length</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a5eb038c3271dbf41ac7ebc02fad3907f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute length of a geometry.  <a href="ogr__api_8h.html#a5eb038c3271dbf41ac7ebc02fad3907f">More...</a><br /></td></tr>
<tr class="separator:a5eb038c3271dbf41ac7ebc02fad3907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a849c584cd22a199bcfb9b34b9a1a8f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a849c584cd22a199bcfb9b34b9a1a8f">OGR_G_Area</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a2a849c584cd22a199bcfb9b34b9a1a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geometry area.  <a href="ogr__api_8h.html#a2a849c584cd22a199bcfb9b34b9a1a8f">More...</a><br /></td></tr>
<tr class="separator:a2a849c584cd22a199bcfb9b34b9a1a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc3e4fe81effd5f56368ce8756cd5f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aafc3e4fe81effd5f56368ce8756cd5f3">OGR_G_GeodesicArea</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:aafc3e4fe81effd5f56368ce8756cd5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geometry area, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry.  <a href="ogr__api_8h.html#aafc3e4fe81effd5f56368ce8756cd5f3">More...</a><br /></td></tr>
<tr class="separator:aafc3e4fe81effd5f56368ce8756cd5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a4e8c234bf9c2452363531d315e8c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a04a4e8c234bf9c2452363531d315e8c9">OGR_G_IsClockwise</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a04a4e8c234bf9c2452363531d315e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the ring has clockwise winding (or less than 2 points)  <a href="ogr__api_8h.html#a04a4e8c234bf9c2452363531d315e8c9">More...</a><br /></td></tr>
<tr class="separator:a04a4e8c234bf9c2452363531d315e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f5a19a81628af7f9cc59a37378cb2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">OGR_G_Centroid</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a23f5a19a81628af7f9cc59a37378cb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometry centroid.  <a href="ogr__api_8h.html#a23f5a19a81628af7f9cc59a37378cb2b">More...</a><br /></td></tr>
<tr class="separator:a23f5a19a81628af7f9cc59a37378cb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadec1c54cea3139fce7b5866e41fc9b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aadec1c54cea3139fce7b5866e41fc9b8">OGR_G_Value</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double dfDistance)</td></tr>
<tr class="memdesc:aadec1c54cea3139fce7b5866e41fc9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch point at given distance along curve.  <a href="ogr__api_8h.html#aadec1c54cea3139fce7b5866e41fc9b8">More...</a><br /></td></tr>
<tr class="separator:aadec1c54cea3139fce7b5866e41fc9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc83b0a3052b8fbe2ed77a86323bf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2">OGR_G_Empty</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a90cc83b0a3052b8fbe2ed77a86323bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear geometry information.  <a href="ogr__api_8h.html#a90cc83b0a3052b8fbe2ed77a86323bf2">More...</a><br /></td></tr>
<tr class="separator:a90cc83b0a3052b8fbe2ed77a86323bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737b0c4d73928e7406d69c658209dbbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a737b0c4d73928e7406d69c658209dbbf">OGR_G_IsEmpty</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a737b0c4d73928e7406d69c658209dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is empty.  <a href="ogr__api_8h.html#a737b0c4d73928e7406d69c658209dbbf">More...</a><br /></td></tr>
<tr class="separator:a737b0c4d73928e7406d69c658209dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df68924f3b41fd377c5b4aa6631a00b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b">OGR_G_IsValid</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a4df68924f3b41fd377c5b4aa6631a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is valid.  <a href="ogr__api_8h.html#a4df68924f3b41fd377c5b4aa6631a00b">More...</a><br /></td></tr>
<tr class="separator:a4df68924f3b41fd377c5b4aa6631a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e24b3b68c6fc20ed8a315451bd61514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4e24b3b68c6fc20ed8a315451bd61514">OGR_G_MakeValid</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a4e24b3b68c6fc20ed8a315451bd61514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to make an invalid geometry valid without losing vertices.  <a href="ogr__api_8h.html#a4e24b3b68c6fc20ed8a315451bd61514">More...</a><br /></td></tr>
<tr class="separator:a4e24b3b68c6fc20ed8a315451bd61514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a819ea6e9634201501cc062f192c922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a819ea6e9634201501cc062f192c922">OGR_G_MakeValidEx</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:a3a819ea6e9634201501cc062f192c922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to make an invalid geometry valid without losing vertices.  <a href="ogr__api_8h.html#a3a819ea6e9634201501cc062f192c922">More...</a><br /></td></tr>
<tr class="separator:a3a819ea6e9634201501cc062f192c922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbc131cab986a87e0db5b8b4dda91e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affbc131cab986a87e0db5b8b4dda91e3">OGR_G_Normalize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:affbc131cab986a87e0db5b8b4dda91e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to bring geometry into normalized/canonical form.  <a href="ogr__api_8h.html#affbc131cab986a87e0db5b8b4dda91e3">More...</a><br /></td></tr>
<tr class="separator:affbc131cab986a87e0db5b8b4dda91e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb66472d7e302d16aacf0d66c01ac73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73">OGR_G_IsSimple</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a3cb66472d7e302d16aacf0d66c01ac73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the geometry is simple.  <a href="ogr__api_8h.html#a3cb66472d7e302d16aacf0d66c01ac73">More...</a><br /></td></tr>
<tr class="separator:a3cb66472d7e302d16aacf0d66c01ac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e99b4792042aca861866cb29bdf826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826">OGR_G_IsRing</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ab9e99b4792042aca861866cb29bdf826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the geometry is a ring.  <a href="ogr__api_8h.html#ab9e99b4792042aca861866cb29bdf826">More...</a><br /></td></tr>
<tr class="separator:ab9e99b4792042aca861866cb29bdf826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90133f7d05c95ae681274cce4481c74f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a90133f7d05c95ae681274cce4481c74f">OGR_G_SetPrecision</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double dfGridSize, int nFlags)</td></tr>
<tr class="memdesc:a90133f7d05c95ae681274cce4481c74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the geometry's precision, rounding all its coordinates to the precision grid, and making sure the geometry is still valid.  <a href="ogr__api_8h.html#a90133f7d05c95ae681274cce4481c74f">More...</a><br /></td></tr>
<tr class="separator:a90133f7d05c95ae681274cce4481c74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673c6c4745d5092fb250ae5342bc1b3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b">OGR_G_Polygonize</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a673c6c4745d5092fb250ae5342bc1b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polygonizes a set of sparse edges.  <a href="ogr__api_8h.html#a673c6c4745d5092fb250ae5342bc1b3b">More...</a><br /></td></tr>
<tr class="separator:a673c6c4745d5092fb250ae5342bc1b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43cbe83609bc7b43739d67858846c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aec43cbe83609bc7b43739d67858846c1">OGR_G_GetPointCount</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:aec43cbe83609bc7b43739d67858846c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of points from a Point or a LineString/LinearRing geometry.  <a href="ogr__api_8h.html#aec43cbe83609bc7b43739d67858846c1">More...</a><br /></td></tr>
<tr class="separator:aec43cbe83609bc7b43739d67858846c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c22d91b27d7a42c225a7dfde28f09c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c22d91b27d7a42c225a7dfde28f09c4">OGR_G_GetPoints</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride)</td></tr>
<tr class="memdesc:a6c22d91b27d7a42c225a7dfde28f09c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all points of line string.  <a href="ogr__api_8h.html#a6c22d91b27d7a42c225a7dfde28f09c4">More...</a><br /></td></tr>
<tr class="separator:a6c22d91b27d7a42c225a7dfde28f09c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce63762b79f4d882e1498981a4c26ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0ce63762b79f4d882e1498981a4c26ba">OGR_G_GetPointsZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, void *pabyX, int nXStride, void *pabyY, int nYStride, void *pabyZ, int nZStride, void *pabyM, int nMStride)</td></tr>
<tr class="memdesc:a0ce63762b79f4d882e1498981a4c26ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all points of line string.  <a href="ogr__api_8h.html#a0ce63762b79f4d882e1498981a4c26ba">More...</a><br /></td></tr>
<tr class="separator:a0ce63762b79f4d882e1498981a4c26ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354146161d0a087b63ab6e350bae4d86"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a354146161d0a087b63ab6e350bae4d86">OGR_G_GetX</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a354146161d0a087b63ab6e350bae4d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the x coordinate of a point from a Point or a LineString/LinearRing geometry.  <a href="ogr__api_8h.html#a354146161d0a087b63ab6e350bae4d86">More...</a><br /></td></tr>
<tr class="separator:a354146161d0a087b63ab6e350bae4d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8405350c9aea2ab7d0f759f0b09b926f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8405350c9aea2ab7d0f759f0b09b926f">OGR_G_GetY</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a8405350c9aea2ab7d0f759f0b09b926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the x coordinate of a point from a Point or a LineString/LinearRing geometry.  <a href="ogr__api_8h.html#a8405350c9aea2ab7d0f759f0b09b926f">More...</a><br /></td></tr>
<tr class="separator:a8405350c9aea2ab7d0f759f0b09b926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8c6aeb013325f33b8e642003fc17ad"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1d8c6aeb013325f33b8e642003fc17ad">OGR_G_GetZ</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a1d8c6aeb013325f33b8e642003fc17ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the z coordinate of a point from a Point or a LineString/LinearRing geometry.  <a href="ogr__api_8h.html#a1d8c6aeb013325f33b8e642003fc17ad">More...</a><br /></td></tr>
<tr class="separator:a1d8c6aeb013325f33b8e642003fc17ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fa1c4594aa103068870ef4b4ef094f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a49fa1c4594aa103068870ef4b4ef094f">OGR_G_GetM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a49fa1c4594aa103068870ef4b4ef094f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the m coordinate of a point from a geometry.  <a href="ogr__api_8h.html#a49fa1c4594aa103068870ef4b4ef094f">More...</a><br /></td></tr>
<tr class="separator:a49fa1c4594aa103068870ef4b4ef094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b897ffcd88a83832964c3735fa1dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">OGR_G_GetPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double *, double *, double *)</td></tr>
<tr class="memdesc:a67b897ffcd88a83832964c3735fa1dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a point in line string or a point geometry.  <a href="ogr__api_8h.html#a67b897ffcd88a83832964c3735fa1dcb">More...</a><br /></td></tr>
<tr class="separator:a67b897ffcd88a83832964c3735fa1dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362999cdf708959829209e9d885d923d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a362999cdf708959829209e9d885d923d">OGR_G_GetPointZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double *, double *, double *, double *)</td></tr>
<tr class="memdesc:a362999cdf708959829209e9d885d923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a point in line string or a point geometry.  <a href="ogr__api_8h.html#a362999cdf708959829209e9d885d923d">More...</a><br /></td></tr>
<tr class="separator:a362999cdf708959829209e9d885d923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f7bff0d685b2713504bd89b14d0fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4f4f7bff0d685b2713504bd89b14d0fc">OGR_G_SetPointCount</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, int nNewPointCount)</td></tr>
<tr class="memdesc:a4f4f7bff0d685b2713504bd89b14d0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of points in a geometry.  <a href="ogr__api_8h.html#a4f4f7bff0d685b2713504bd89b14d0fc">More...</a><br /></td></tr>
<tr class="separator:a4f4f7bff0d685b2713504bd89b14d0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303fb1a2a94363c15f9e61dc46b710e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a303fb1a2a94363c15f9e61dc46b710e8">OGR_G_SetPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double, double)</td></tr>
<tr class="memdesc:a303fb1a2a94363c15f9e61dc46b710e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="ogr__api_8h.html#a303fb1a2a94363c15f9e61dc46b710e8">More...</a><br /></td></tr>
<tr class="separator:a303fb1a2a94363c15f9e61dc46b710e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14b9730d6f9fc829fe6be9bc2a5ec48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab14b9730d6f9fc829fe6be9bc2a5ec48">OGR_G_SetPoint_2D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double)</td></tr>
<tr class="memdesc:ab14b9730d6f9fc829fe6be9bc2a5ec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="ogr__api_8h.html#ab14b9730d6f9fc829fe6be9bc2a5ec48">More...</a><br /></td></tr>
<tr class="separator:ab14b9730d6f9fc829fe6be9bc2a5ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ce9b54d1e821bd020a7a6731d2f529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab4ce9b54d1e821bd020a7a6731d2f529">OGR_G_SetPointM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double, double)</td></tr>
<tr class="memdesc:ab4ce9b54d1e821bd020a7a6731d2f529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="ogr__api_8h.html#ab4ce9b54d1e821bd020a7a6731d2f529">More...</a><br /></td></tr>
<tr class="separator:ab4ce9b54d1e821bd020a7a6731d2f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034b6b1bae3843345cbfc78e07fa7075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a034b6b1bae3843345cbfc78e07fa7075">OGR_G_SetPointZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int iPoint, double, double, double, double)</td></tr>
<tr class="memdesc:a034b6b1bae3843345cbfc78e07fa7075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the location of a vertex in a point or linestring geometry.  <a href="ogr__api_8h.html#a034b6b1bae3843345cbfc78e07fa7075">More...</a><br /></td></tr>
<tr class="separator:a034b6b1bae3843345cbfc78e07fa7075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2702d812663bc767e3a8f8832fda089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa2702d812663bc767e3a8f8832fda089">OGR_G_AddPoint</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double, double)</td></tr>
<tr class="memdesc:aa2702d812663bc767e3a8f8832fda089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="ogr__api_8h.html#aa2702d812663bc767e3a8f8832fda089">More...</a><br /></td></tr>
<tr class="separator:aa2702d812663bc767e3a8f8832fda089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280275c1492d6426cfe0a918d4725374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a280275c1492d6426cfe0a918d4725374">OGR_G_AddPoint_2D</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double)</td></tr>
<tr class="memdesc:a280275c1492d6426cfe0a918d4725374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="ogr__api_8h.html#a280275c1492d6426cfe0a918d4725374">More...</a><br /></td></tr>
<tr class="separator:a280275c1492d6426cfe0a918d4725374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16370d0b3feb2505fa5f3a2acfffbf17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a16370d0b3feb2505fa5f3a2acfffbf17">OGR_G_AddPointM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double, double)</td></tr>
<tr class="memdesc:a16370d0b3feb2505fa5f3a2acfffbf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="ogr__api_8h.html#a16370d0b3feb2505fa5f3a2acfffbf17">More...</a><br /></td></tr>
<tr class="separator:a16370d0b3feb2505fa5f3a2acfffbf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01e19ca7b9951a5201b345ea130325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adf01e19ca7b9951a5201b345ea130325">OGR_G_AddPointZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, double, double, double, double)</td></tr>
<tr class="memdesc:adf01e19ca7b9951a5201b345ea130325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a point to a geometry (line string or point).  <a href="ogr__api_8h.html#adf01e19ca7b9951a5201b345ea130325">More...</a><br /></td></tr>
<tr class="separator:adf01e19ca7b9951a5201b345ea130325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51438701454d7e86988efc62b25d6aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a51438701454d7e86988efc62b25d6aeb">OGR_G_SetPoints</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, int nPointsIn, const void *pabyX, int nXStride, const void *pabyY, int nYStride, const void *pabyZ, int nZStride)</td></tr>
<tr class="memdesc:a51438701454d7e86988efc62b25d6aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all points in a point or a line string geometry.  <a href="ogr__api_8h.html#a51438701454d7e86988efc62b25d6aeb">More...</a><br /></td></tr>
<tr class="separator:a51438701454d7e86988efc62b25d6aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54402dc365f496b29ad1f01261e4576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac54402dc365f496b29ad1f01261e4576">OGR_G_SetPointsZM</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, int nPointsIn, const void *pabyX, int nXStride, const void *pabyY, int nYStride, const void *pabyZ, int nZStride, const void *pabyM, int nMStride)</td></tr>
<tr class="memdesc:ac54402dc365f496b29ad1f01261e4576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign all points in a point or a line string geometry.  <a href="ogr__api_8h.html#ac54402dc365f496b29ad1f01261e4576">More...</a><br /></td></tr>
<tr class="separator:ac54402dc365f496b29ad1f01261e4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cacbe8ef1bbacdcee7ad7c3d74ed593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cacbe8ef1bbacdcee7ad7c3d74ed593">OGR_G_SwapXY</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a4cacbe8ef1bbacdcee7ad7c3d74ed593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap x and y coordinates.  <a href="ogr__api_8h.html#a4cacbe8ef1bbacdcee7ad7c3d74ed593">More...</a><br /></td></tr>
<tr class="separator:a4cacbe8ef1bbacdcee7ad7c3d74ed593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa07ddf969f97f6444de6ae5128d842"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1fa07ddf969f97f6444de6ae5128d842">OGR_G_GetGeometryCount</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a1fa07ddf969f97f6444de6ae5128d842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the number of elements in a geometry or number of geometries in container.  <a href="ogr__api_8h.html#a1fa07ddf969f97f6444de6ae5128d842">More...</a><br /></td></tr>
<tr class="separator:a1fa07ddf969f97f6444de6ae5128d842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bac93150529a5c98811db29e289dd66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6bac93150529a5c98811db29e289dd66">OGR_G_GetGeometryRef</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int)</td></tr>
<tr class="memdesc:a6bac93150529a5c98811db29e289dd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry from a geometry container.  <a href="ogr__api_8h.html#a6bac93150529a5c98811db29e289dd66">More...</a><br /></td></tr>
<tr class="separator:a6bac93150529a5c98811db29e289dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15e130614cb4c66fc99bb93dc6b3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4a15e130614cb4c66fc99bb93dc6b3b5">OGR_G_AddGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a4a15e130614cb4c66fc99bb93dc6b3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a geometry to a geometry container.  <a href="ogr__api_8h.html#a4a15e130614cb4c66fc99bb93dc6b3b5">More...</a><br /></td></tr>
<tr class="separator:a4a15e130614cb4c66fc99bb93dc6b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56cae8305396a9c5b690d8356e39c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aff56cae8305396a9c5b690d8356e39c9">OGR_G_AddGeometryDirectly</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:aff56cae8305396a9c5b690d8356e39c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a geometry directly to an existing geometry container.  <a href="ogr__api_8h.html#aff56cae8305396a9c5b690d8356e39c9">More...</a><br /></td></tr>
<tr class="separator:aff56cae8305396a9c5b690d8356e39c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ea024bb659e48d3297404e53800237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a54ea024bb659e48d3297404e53800237">OGR_G_RemoveGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int, int)</td></tr>
<tr class="memdesc:a54ea024bb659e48d3297404e53800237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a geometry from an exiting geometry container.  <a href="ogr__api_8h.html#a54ea024bb659e48d3297404e53800237">More...</a><br /></td></tr>
<tr class="separator:a54ea024bb659e48d3297404e53800237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f8e7d05f06a1fe69ea9638085e5e26"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af4f8e7d05f06a1fe69ea9638085e5e26">OGR_G_HasCurveGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, int bLookForNonLinear)</td></tr>
<tr class="memdesc:af4f8e7d05f06a1fe69ea9638085e5e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if this geometry is or has curve geometry.  <a href="ogr__api_8h.html#af4f8e7d05f06a1fe69ea9638085e5e26">More...</a><br /></td></tr>
<tr class="separator:af4f8e7d05f06a1fe69ea9638085e5e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a6941c76bd4da7fdf2dca081d07e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a540a6941c76bd4da7fdf2dca081d07e5">OGR_G_GetLinearGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, double dfMaxAngleStepSizeDegrees, char **papszOptions)</td></tr>
<tr class="memdesc:a540a6941c76bd4da7fdf2dca081d07e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return, possibly approximate, linear version of this geometry.  <a href="ogr__api_8h.html#a540a6941c76bd4da7fdf2dca081d07e5">More...</a><br /></td></tr>
<tr class="separator:a540a6941c76bd4da7fdf2dca081d07e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a8713301c4f28c30aa7bd034411402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a21a8713301c4f28c30aa7bd034411402">OGR_G_GetCurveGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom, char **papszOptions)</td></tr>
<tr class="memdesc:a21a8713301c4f28c30aa7bd034411402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return curve version of this geometry.  <a href="ogr__api_8h.html#a21a8713301c4f28c30aa7bd034411402">More...</a><br /></td></tr>
<tr class="separator:a21a8713301c4f28c30aa7bd034411402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f64386be8d675e8da33d289ccc9892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">OGRBuildPolygonFromEdges</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hLinesAsCollection, int bBestEffort, int bAutoClose, double dfTolerance, <a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *peErr)</td></tr>
<tr class="memdesc:a74f64386be8d675e8da33d289ccc9892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a ring from a bunch of arcs.  <a href="ogr__api_8h.html#a74f64386be8d675e8da33d289ccc9892">More...</a><br /></td></tr>
<tr class="separator:a74f64386be8d675e8da33d289ccc9892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31febe0b845d7cc0052767e6257e7349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a31febe0b845d7cc0052767e6257e7349">OGRSetNonLinearGeometriesEnabledFlag</a> (int bFlag)</td></tr>
<tr class="memdesc:a31febe0b845d7cc0052767e6257e7349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag to enable/disable returning non-linear geometries in the C API.  <a href="ogr__api_8h.html#a31febe0b845d7cc0052767e6257e7349">More...</a><br /></td></tr>
<tr class="separator:a31febe0b845d7cc0052767e6257e7349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f6cfab316f5f22962bcd85216c4684"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7f6cfab316f5f22962bcd85216c4684">OGRGetNonLinearGeometriesEnabledFlag</a> (void)</td></tr>
<tr class="memdesc:af7f6cfab316f5f22962bcd85216c4684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flag to enable/disable returning non-linear geometries in the C API.  <a href="ogr__api_8h.html#af7f6cfab316f5f22962bcd85216c4684">More...</a><br /></td></tr>
<tr class="separator:af7f6cfab316f5f22962bcd85216c4684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ea15e982aaebea0fdada8eb3248d64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a82ea15e982aaebea0fdada8eb3248d64">OGRHasPreparedGeometrySupport</a> (void)</td></tr>
<tr class="memdesc:a82ea15e982aaebea0fdada8eb3248d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if GEOS has prepared geometry support.  <a href="ogr__api_8h.html#a82ea15e982aaebea0fdada8eb3248d64">More...</a><br /></td></tr>
<tr class="separator:a82ea15e982aaebea0fdada8eb3248d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70e09598881642379f42d7d7f3281a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad70e09598881642379f42d7d7f3281a9">OGRCreatePreparedGeometry</a> (<a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:ad70e09598881642379f42d7d7f3281a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a prepared geometry.  <a href="ogr__api_8h.html#ad70e09598881642379f42d7d7f3281a9">More...</a><br /></td></tr>
<tr class="separator:ad70e09598881642379f42d7d7f3281a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd20f8ac4f660a63d0378ef5a8047727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abd20f8ac4f660a63d0378ef5a8047727">OGRDestroyPreparedGeometry</a> (<a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a> hPreparedGeom)</td></tr>
<tr class="memdesc:abd20f8ac4f660a63d0378ef5a8047727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a prepared geometry.  <a href="ogr__api_8h.html#abd20f8ac4f660a63d0378ef5a8047727">More...</a><br /></td></tr>
<tr class="separator:abd20f8ac4f660a63d0378ef5a8047727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d8dbcfc8ba66adcc26181f8a8337d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade5d8dbcfc8ba66adcc26181f8a8337d">OGRPreparedGeometryIntersects</a> (<a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a> hPreparedGeom, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hOtherGeom)</td></tr>
<tr class="memdesc:ade5d8dbcfc8ba66adcc26181f8a8337d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a prepared geometry intersects with a geometry.  <a href="ogr__api_8h.html#ade5d8dbcfc8ba66adcc26181f8a8337d">More...</a><br /></td></tr>
<tr class="separator:ade5d8dbcfc8ba66adcc26181f8a8337d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb67db2345c1599239a5f46b57bf4ea2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adb67db2345c1599239a5f46b57bf4ea2">OGRPreparedGeometryContains</a> (<a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a> hPreparedGeom, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hOtherGeom)</td></tr>
<tr class="memdesc:adb67db2345c1599239a5f46b57bf4ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a prepared geometry contains a geometry.  <a href="ogr__api_8h.html#adb67db2345c1599239a5f46b57bf4ea2">More...</a><br /></td></tr>
<tr class="separator:adb67db2345c1599239a5f46b57bf4ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1ffd4d1f9f68aa76f660dc4f82e492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afb1ffd4d1f9f68aa76f660dc4f82e492">OGR_Fld_Create</a> (const char *, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr class="memdesc:afb1ffd4d1f9f68aa76f660dc4f82e492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field definition.  <a href="ogr__api_8h.html#afb1ffd4d1f9f68aa76f660dc4f82e492">More...</a><br /></td></tr>
<tr class="separator:afb1ffd4d1f9f68aa76f660dc4f82e492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455fa4a2c2451b1748facb6b7126a822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a455fa4a2c2451b1748facb6b7126a822">OGR_Fld_Destroy</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a455fa4a2c2451b1748facb6b7126a822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a field definition.  <a href="ogr__api_8h.html#a455fa4a2c2451b1748facb6b7126a822">More...</a><br /></td></tr>
<tr class="separator:a455fa4a2c2451b1748facb6b7126a822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6599fa42bad3aba26574ae3260c6984d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6599fa42bad3aba26574ae3260c6984d">OGR_Fld_SetName</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a6599fa42bad3aba26574ae3260c6984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the name of this field.  <a href="ogr__api_8h.html#a6599fa42bad3aba26574ae3260c6984d">More...</a><br /></td></tr>
<tr class="separator:a6599fa42bad3aba26574ae3260c6984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7640a6b6a47a95d83415f9271ffe30"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8d7640a6b6a47a95d83415f9271ffe30">OGR_Fld_GetNameRef</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a8d7640a6b6a47a95d83415f9271ffe30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch name of this field.  <a href="ogr__api_8h.html#a8d7640a6b6a47a95d83415f9271ffe30">More...</a><br /></td></tr>
<tr class="separator:a8d7640a6b6a47a95d83415f9271ffe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158cc56e4591cb18ebba61c2ec16ac3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a158cc56e4591cb18ebba61c2ec16ac3f">OGR_Fld_SetAlternativeName</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a158cc56e4591cb18ebba61c2ec16ac3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the alternative name (or "alias") for this field.  <a href="ogr__api_8h.html#a158cc56e4591cb18ebba61c2ec16ac3f">More...</a><br /></td></tr>
<tr class="separator:a158cc56e4591cb18ebba61c2ec16ac3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c6791d020eab96730a9ab3ecca6f84"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a74c6791d020eab96730a9ab3ecca6f84">OGR_Fld_GetAlternativeNameRef</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a74c6791d020eab96730a9ab3ecca6f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the alternative name (or "alias") for this field.  <a href="ogr__api_8h.html#a74c6791d020eab96730a9ab3ecca6f84">More...</a><br /></td></tr>
<tr class="separator:a74c6791d020eab96730a9ab3ecca6f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d150dfc678e0a2a7f5241ba38c5611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad8d150dfc678e0a2a7f5241ba38c5611">OGR_Fld_GetType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:ad8d150dfc678e0a2a7f5241ba38c5611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch type of this field.  <a href="ogr__api_8h.html#ad8d150dfc678e0a2a7f5241ba38c5611">More...</a><br /></td></tr>
<tr class="separator:ad8d150dfc678e0a2a7f5241ba38c5611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76195990f814eb93e821c01ce0599a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a76195990f814eb93e821c01ce0599a50">OGR_Fld_SetType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr class="memdesc:a76195990f814eb93e821c01ce0599a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of this field.  <a href="ogr__api_8h.html#a76195990f814eb93e821c01ce0599a50">More...</a><br /></td></tr>
<tr class="separator:a76195990f814eb93e821c01ce0599a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef13952aa38f83b0dc1da047870511f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3ef13952aa38f83b0dc1da047870511f">OGR_Fld_GetSubType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a3ef13952aa38f83b0dc1da047870511f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch subtype of this field.  <a href="ogr__api_8h.html#a3ef13952aa38f83b0dc1da047870511f">More...</a><br /></td></tr>
<tr class="separator:a3ef13952aa38f83b0dc1da047870511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83497e3ce74c6abb615a234791850c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab83497e3ce74c6abb615a234791850c1">OGR_Fld_SetSubType</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>)</td></tr>
<tr class="memdesc:ab83497e3ce74c6abb615a234791850c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subtype of this field.  <a href="ogr__api_8h.html#ab83497e3ce74c6abb615a234791850c1">More...</a><br /></td></tr>
<tr class="separator:ab83497e3ce74c6abb615a234791850c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf8a09826e47763e6bf667af0dae1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0cf8a09826e47763e6bf667af0dae1a7">OGR_Fld_GetJustify</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a0cf8a09826e47763e6bf667af0dae1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the justification for this field.  <a href="ogr__api_8h.html#a0cf8a09826e47763e6bf667af0dae1a7">More...</a><br /></td></tr>
<tr class="separator:a0cf8a09826e47763e6bf667af0dae1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4809f2fe957002b8e18aacc1bdca240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae4809f2fe957002b8e18aacc1bdca240">OGR_Fld_SetJustify</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>)</td></tr>
<tr class="memdesc:ae4809f2fe957002b8e18aacc1bdca240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the justification for this field.  <a href="ogr__api_8h.html#ae4809f2fe957002b8e18aacc1bdca240">More...</a><br /></td></tr>
<tr class="separator:ae4809f2fe957002b8e18aacc1bdca240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6500186e3f22761a615428c55bba0ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6500186e3f22761a615428c55bba0ce">OGR_Fld_GetWidth</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:aa6500186e3f22761a615428c55bba0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the formatting width for this field.  <a href="ogr__api_8h.html#aa6500186e3f22761a615428c55bba0ce">More...</a><br /></td></tr>
<tr class="separator:aa6500186e3f22761a615428c55bba0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7bf7c14a299448efac58f7bf364326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1d7bf7c14a299448efac58f7bf364326">OGR_Fld_SetWidth</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:a1d7bf7c14a299448efac58f7bf364326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the formatting width for this field in characters.  <a href="ogr__api_8h.html#a1d7bf7c14a299448efac58f7bf364326">More...</a><br /></td></tr>
<tr class="separator:a1d7bf7c14a299448efac58f7bf364326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120dd56ee23070922e4d84ed06b06e27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a120dd56ee23070922e4d84ed06b06e27">OGR_Fld_GetPrecision</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a120dd56ee23070922e4d84ed06b06e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the formatting precision for this field.  <a href="ogr__api_8h.html#a120dd56ee23070922e4d84ed06b06e27">More...</a><br /></td></tr>
<tr class="separator:a120dd56ee23070922e4d84ed06b06e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13890f01f7d7e57bcd07e23f3e2947da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a13890f01f7d7e57bcd07e23f3e2947da">OGR_Fld_SetPrecision</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:a13890f01f7d7e57bcd07e23f3e2947da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the formatting precision for this field in characters.  <a href="ogr__api_8h.html#a13890f01f7d7e57bcd07e23f3e2947da">More...</a><br /></td></tr>
<tr class="separator:a13890f01f7d7e57bcd07e23f3e2947da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae573548454787d6f0552e469e15fc3d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae573548454787d6f0552e469e15fc3d9">OGR_Fld_GetTZFlag</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:ae573548454787d6f0552e469e15fc3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time zone flag.  <a href="ogr__api_8h.html#ae573548454787d6f0552e469e15fc3d9">More...</a><br /></td></tr>
<tr class="separator:ae573548454787d6f0552e469e15fc3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad684a6c2079c558d5e0579a3f758b5ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad684a6c2079c558d5e0579a3f758b5ea">OGR_Fld_SetTZFlag</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:ad684a6c2079c558d5e0579a3f758b5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the formatting precision for this field in characters.  <a href="ogr__api_8h.html#ad684a6c2079c558d5e0579a3f758b5ea">More...</a><br /></td></tr>
<tr class="separator:ad684a6c2079c558d5e0579a3f758b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5922e599fe8746b81adf251be6b5ecf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5922e599fe8746b81adf251be6b5ecf0">OGR_Fld_Set</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, const char *, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>, int, int, <a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>)</td></tr>
<tr class="memdesc:a5922e599fe8746b81adf251be6b5ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set defining parameters for a field in one call.  <a href="ogr__api_8h.html#a5922e599fe8746b81adf251be6b5ecf0">More...</a><br /></td></tr>
<tr class="separator:a5922e599fe8746b81adf251be6b5ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bec35ae5a4c232ad850315bdc2b675"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a29bec35ae5a4c232ad850315bdc2b675">OGR_Fld_IsIgnored</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a29bec35ae5a4c232ad850315bdc2b675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field should be omitted when fetching features.  <a href="ogr__api_8h.html#a29bec35ae5a4c232ad850315bdc2b675">More...</a><br /></td></tr>
<tr class="separator:a29bec35ae5a4c232ad850315bdc2b675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf9aa9767cd28c90dc66ed2a7a7332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeddf9aa9767cd28c90dc66ed2a7a7332">OGR_Fld_SetIgnored</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:aeddf9aa9767cd28c90dc66ed2a7a7332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field should be omitted when fetching features.  <a href="ogr__api_8h.html#aeddf9aa9767cd28c90dc66ed2a7a7332">More...</a><br /></td></tr>
<tr class="separator:aeddf9aa9767cd28c90dc66ed2a7a7332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bfc414977d37ee22edefd38c1f414b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a57bfc414977d37ee22edefd38c1f414b">OGR_Fld_IsNullable</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a57bfc414977d37ee22edefd38c1f414b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field can receive null values.  <a href="ogr__api_8h.html#a57bfc414977d37ee22edefd38c1f414b">More...</a><br /></td></tr>
<tr class="separator:a57bfc414977d37ee22edefd38c1f414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a35def2d6766804a59f0b4c24e457d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a35def2d6766804a59f0b4c24e457d5">OGR_Fld_SetNullable</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:a9a35def2d6766804a59f0b4c24e457d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field can receive null values.  <a href="ogr__api_8h.html#a9a35def2d6766804a59f0b4c24e457d5">More...</a><br /></td></tr>
<tr class="separator:a9a35def2d6766804a59f0b4c24e457d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff65c05d498c568bd72d0d08e9544ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6ff65c05d498c568bd72d0d08e9544ce">OGR_Fld_IsUnique</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a6ff65c05d498c568bd72d0d08e9544ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field has a unique constraint.  <a href="ogr__api_8h.html#a6ff65c05d498c568bd72d0d08e9544ce">More...</a><br /></td></tr>
<tr class="separator:a6ff65c05d498c568bd72d0d08e9544ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6779229ca8cd4459538915674d67a6c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6779229ca8cd4459538915674d67a6c5">OGR_Fld_SetUnique</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:a6779229ca8cd4459538915674d67a6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field has a unique constraint.  <a href="ogr__api_8h.html#a6779229ca8cd4459538915674d67a6c5">More...</a><br /></td></tr>
<tr class="separator:a6779229ca8cd4459538915674d67a6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc96ddb37f8b8076e711e48ee9ead62"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aacc96ddb37f8b8076e711e48ee9ead62">OGR_Fld_GetDefault</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:aacc96ddb37f8b8076e711e48ee9ead62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default field value.  <a href="ogr__api_8h.html#aacc96ddb37f8b8076e711e48ee9ead62">More...</a><br /></td></tr>
<tr class="separator:aacc96ddb37f8b8076e711e48ee9ead62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0268ee60f240e6fa668b7c612354f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa0268ee60f240e6fa668b7c612354f80">OGR_Fld_SetDefault</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, const char *)</td></tr>
<tr class="memdesc:aa0268ee60f240e6fa668b7c612354f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default field value.  <a href="ogr__api_8h.html#aa0268ee60f240e6fa668b7c612354f80">More...</a><br /></td></tr>
<tr class="separator:aa0268ee60f240e6fa668b7c612354f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf08ca1607bdc678f2ae166ad0f27e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4bf08ca1607bdc678f2ae166ad0f27e2">OGR_Fld_IsDefaultDriverSpecific</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a4bf08ca1607bdc678f2ae166ad0f27e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the default value is driver specific.  <a href="ogr__api_8h.html#a4bf08ca1607bdc678f2ae166ad0f27e2">More...</a><br /></td></tr>
<tr class="separator:a4bf08ca1607bdc678f2ae166ad0f27e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11064c2d8444dff4b87f44626849f4b9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11064c2d8444dff4b87f44626849f4b9">OGR_Fld_GetDomainName</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a11064c2d8444dff4b87f44626849f4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the field domain for this field.  <a href="ogr__api_8h.html#a11064c2d8444dff4b87f44626849f4b9">More...</a><br /></td></tr>
<tr class="separator:a11064c2d8444dff4b87f44626849f4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c92a9d0dabad1e1b578e8712059d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a475c92a9d0dabad1e1b578e8712059d9">OGR_Fld_SetDomainName</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, const char *)</td></tr>
<tr class="memdesc:a475c92a9d0dabad1e1b578e8712059d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the field domain for this field.  <a href="ogr__api_8h.html#a475c92a9d0dabad1e1b578e8712059d9">More...</a><br /></td></tr>
<tr class="separator:a475c92a9d0dabad1e1b578e8712059d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c22d085f7ffae07b22c8d26c77794a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a80c22d085f7ffae07b22c8d26c77794a">OGR_Fld_GetComment</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a80c22d085f7ffae07b22c8d26c77794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the (optional) comment for this field.  <a href="ogr__api_8h.html#a80c22d085f7ffae07b22c8d26c77794a">More...</a><br /></td></tr>
<tr class="separator:a80c22d085f7ffae07b22c8d26c77794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc1e58b1b86ea322e4f440f61bc5a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affc1e58b1b86ea322e4f440f61bc5a82">OGR_Fld_SetComment</a> (<a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hDefn, const char *)</td></tr>
<tr class="memdesc:affc1e58b1b86ea322e4f440f61bc5a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the comment for this field.  <a href="ogr__api_8h.html#affc1e58b1b86ea322e4f440f61bc5a82">More...</a><br /></td></tr>
<tr class="separator:affc1e58b1b86ea322e4f440f61bc5a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e61b89ae2d799cf5e217d01ef7b415"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af1e61b89ae2d799cf5e217d01ef7b415">OGR_GetFieldTypeName</a> (<a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>)</td></tr>
<tr class="memdesc:af1e61b89ae2d799cf5e217d01ef7b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch human readable name for a field type.  <a href="ogr__api_8h.html#af1e61b89ae2d799cf5e217d01ef7b415">More...</a><br /></td></tr>
<tr class="separator:af1e61b89ae2d799cf5e217d01ef7b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9611cba58f204544ecad73fd8defe3f3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9611cba58f204544ecad73fd8defe3f3">OGR_GetFieldSubTypeName</a> (<a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>)</td></tr>
<tr class="memdesc:a9611cba58f204544ecad73fd8defe3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch human readable name for a field subtype.  <a href="ogr__api_8h.html#a9611cba58f204544ecad73fd8defe3f3">More...</a><br /></td></tr>
<tr class="separator:a9611cba58f204544ecad73fd8defe3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3caffcd90d58c859cb51adef4c6c5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3f3caffcd90d58c859cb51adef4c6c5d">OGR_AreTypeSubTypeCompatible</a> (<a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> eType, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> eSubType)</td></tr>
<tr class="memdesc:a3f3caffcd90d58c859cb51adef4c6c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if type and subtype are compatible.  <a href="ogr__api_8h.html#a3f3caffcd90d58c859cb51adef4c6c5d">More...</a><br /></td></tr>
<tr class="separator:a3f3caffcd90d58c859cb51adef4c6c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add28d22dc63336e5f2a9d543e792982f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#add28d22dc63336e5f2a9d543e792982f">OGR_GFld_Create</a> (const char *, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:add28d22dc63336e5f2a9d543e792982f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field geometry definition.  <a href="ogr__api_8h.html#add28d22dc63336e5f2a9d543e792982f">More...</a><br /></td></tr>
<tr class="separator:add28d22dc63336e5f2a9d543e792982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e65993ea2b8b907e43ffa8b106871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f3e65993ea2b8b907e43ffa8b106871">OGR_GFld_Destroy</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a0f3e65993ea2b8b907e43ffa8b106871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a geometry field definition.  <a href="ogr__api_8h.html#a0f3e65993ea2b8b907e43ffa8b106871">More...</a><br /></td></tr>
<tr class="separator:a0f3e65993ea2b8b907e43ffa8b106871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9b9d56381cae346c5129943641f628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c9b9d56381cae346c5129943641f628">OGR_GFld_SetName</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a6c9b9d56381cae346c5129943641f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the name of this field.  <a href="ogr__api_8h.html#a6c9b9d56381cae346c5129943641f628">More...</a><br /></td></tr>
<tr class="separator:a6c9b9d56381cae346c5129943641f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9914366a6cc3b4169a3359c2b1ef614"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad9914366a6cc3b4169a3359c2b1ef614">OGR_GFld_GetNameRef</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:ad9914366a6cc3b4169a3359c2b1ef614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch name of this field.  <a href="ogr__api_8h.html#ad9914366a6cc3b4169a3359c2b1ef614">More...</a><br /></td></tr>
<tr class="separator:ad9914366a6cc3b4169a3359c2b1ef614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f4350c2e90c6e67df37f68d244a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d">OGR_GFld_GetType</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a323f4350c2e90c6e67df37f68d244a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry type of this field.  <a href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d">More...</a><br /></td></tr>
<tr class="separator:a323f4350c2e90c6e67df37f68d244a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3691474967ca5f0c9789e0626d55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affb3691474967ca5f0c9789e0626d55f">OGR_GFld_SetType</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:affb3691474967ca5f0c9789e0626d55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the geometry type of this field.  <a href="ogr__api_8h.html#affb3691474967ca5f0c9789e0626d55f">More...</a><br /></td></tr>
<tr class="separator:affb3691474967ca5f0c9789e0626d55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7927b11a85659d8ce6da8857f52b05c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7927b11a85659d8ce6da8857f52b05c4">OGR_GFld_GetSpatialRef</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a7927b11a85659d8ce6da8857f52b05c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch spatial reference system of this field.  <a href="ogr__api_8h.html#a7927b11a85659d8ce6da8857f52b05c4">More...</a><br /></td></tr>
<tr class="separator:a7927b11a85659d8ce6da8857f52b05c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa717acc8f4f5f33825334fe72edc2be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa717acc8f4f5f33825334fe72edc2be9">OGR_GFld_SetSpatialRef</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSRS)</td></tr>
<tr class="memdesc:aa717acc8f4f5f33825334fe72edc2be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the spatial reference of this field.  <a href="ogr__api_8h.html#aa717acc8f4f5f33825334fe72edc2be9">More...</a><br /></td></tr>
<tr class="separator:aa717acc8f4f5f33825334fe72edc2be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfbda2b68e11227611ff74ee0105d47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9bfbda2b68e11227611ff74ee0105d47">OGR_GFld_IsNullable</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:a9bfbda2b68e11227611ff74ee0105d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this geometry field can receive null values.  <a href="ogr__api_8h.html#a9bfbda2b68e11227611ff74ee0105d47">More...</a><br /></td></tr>
<tr class="separator:a9bfbda2b68e11227611ff74ee0105d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1">OGR_GFld_SetNullable</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this geometry field can receive null values.  <a href="ogr__api_8h.html#aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1">More...</a><br /></td></tr>
<tr class="separator:aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab232798830d8dcae0742d83948e33d1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab232798830d8dcae0742d83948e33d1a">OGR_GFld_IsIgnored</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn)</td></tr>
<tr class="memdesc:ab232798830d8dcae0742d83948e33d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this field should be omitted when fetching features.  <a href="ogr__api_8h.html#ab232798830d8dcae0742d83948e33d1a">More...</a><br /></td></tr>
<tr class="separator:ab232798830d8dcae0742d83948e33d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a4e5e2af01140209e9d2814869eb41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af3a4e5e2af01140209e9d2814869eb41">OGR_GFld_SetIgnored</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hDefn, int)</td></tr>
<tr class="memdesc:af3a4e5e2af01140209e9d2814869eb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether this field should be omitted when fetching features.  <a href="ogr__api_8h.html#af3a4e5e2af01140209e9d2814869eb41">More...</a><br /></td></tr>
<tr class="separator:af3a4e5e2af01140209e9d2814869eb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ed8172ddb4962001be2e37b774e80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a06ed8172ddb4962001be2e37b774e80d">OGR_GFld_GetCoordinatePrecision</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>)</td></tr>
<tr class="memdesc:a06ed8172ddb4962001be2e37b774e80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coordinate precision associated to this geometry field.  <a href="ogr__api_8h.html#a06ed8172ddb4962001be2e37b774e80d">More...</a><br /></td></tr>
<tr class="separator:a06ed8172ddb4962001be2e37b774e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad0d8a54fc213c10791b559de0fe5c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afad0d8a54fc213c10791b559de0fe5c7">OGR_GFld_SetCoordinatePrecision</a> (<a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>, <a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>)</td></tr>
<tr class="memdesc:afad0d8a54fc213c10791b559de0fe5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set coordinate precision associated to this geometry field.  <a href="ogr__api_8h.html#afad0d8a54fc213c10791b559de0fe5c7">More...</a><br /></td></tr>
<tr class="separator:afad0d8a54fc213c10791b559de0fe5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8049bf2d58da5381c9350a6159ea6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5a8049bf2d58da5381c9350a6159ea6c">OGR_FD_Create</a> (const char *)</td></tr>
<tr class="memdesc:a5a8049bf2d58da5381c9350a6159ea6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new feature definition object to hold the field definitions.  <a href="ogr__api_8h.html#a5a8049bf2d58da5381c9350a6159ea6c">More...</a><br /></td></tr>
<tr class="separator:a5a8049bf2d58da5381c9350a6159ea6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d5cbb660cce8467a210caa4d68a011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a59d5cbb660cce8467a210caa4d68a011">OGR_FD_Destroy</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a59d5cbb660cce8467a210caa4d68a011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a feature definition object and release all memory associated with it.  <a href="ogr__api_8h.html#a59d5cbb660cce8467a210caa4d68a011">More...</a><br /></td></tr>
<tr class="separator:a59d5cbb660cce8467a210caa4d68a011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0755b0360414095e15eaf2c1496f8c47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0755b0360414095e15eaf2c1496f8c47">OGR_FD_Release</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a0755b0360414095e15eaf2c1496f8c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference, and destroy if unreferenced.  <a href="ogr__api_8h.html#a0755b0360414095e15eaf2c1496f8c47">More...</a><br /></td></tr>
<tr class="separator:a0755b0360414095e15eaf2c1496f8c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f309bf10e5b76cc083848b710babb8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a20f309bf10e5b76cc083848b710babb8">OGR_FD_GetName</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a20f309bf10e5b76cc083848b710babb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> passed as an argument.  <a href="ogr__api_8h.html#a20f309bf10e5b76cc083848b710babb8">More...</a><br /></td></tr>
<tr class="separator:a20f309bf10e5b76cc083848b710babb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586a14271a457387a2b5c0097a02c8da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a586a14271a457387a2b5c0097a02c8da">OGR_FD_GetFieldCount</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a586a14271a457387a2b5c0097a02c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of fields on the passed feature definition.  <a href="ogr__api_8h.html#a586a14271a457387a2b5c0097a02c8da">More...</a><br /></td></tr>
<tr class="separator:a586a14271a457387a2b5c0097a02c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484456df86a01284769d0afe3beaa4f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a484456df86a01284769d0afe3beaa4f6">OGR_FD_GetFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, int)</td></tr>
<tr class="memdesc:a484456df86a01284769d0afe3beaa4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field definition of the passed feature definition.  <a href="ogr__api_8h.html#a484456df86a01284769d0afe3beaa4f6">More...</a><br /></td></tr>
<tr class="separator:a484456df86a01284769d0afe3beaa4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54c3271dce0562209d78ae6eaae330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1e54c3271dce0562209d78ae6eaae330">OGR_FD_GetFieldIndex</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, const char *)</td></tr>
<tr class="memdesc:a1e54c3271dce0562209d78ae6eaae330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find field by name.  <a href="ogr__api_8h.html#a1e54c3271dce0562209d78ae6eaae330">More...</a><br /></td></tr>
<tr class="separator:a1e54c3271dce0562209d78ae6eaae330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a798e8d03299403418a7c87862f1acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a798e8d03299403418a7c87862f1acb">OGR_FD_AddFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, <a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>)</td></tr>
<tr class="memdesc:a2a798e8d03299403418a7c87862f1acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new field definition to the passed feature definition.  <a href="ogr__api_8h.html#a2a798e8d03299403418a7c87862f1acb">More...</a><br /></td></tr>
<tr class="separator:a2a798e8d03299403418a7c87862f1acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6283475163d911204f5ff45098c8479e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6283475163d911204f5ff45098c8479e">OGR_FD_DeleteFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hDefn, int iField)</td></tr>
<tr class="memdesc:a6283475163d911204f5ff45098c8479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing field definition.  <a href="ogr__api_8h.html#a6283475163d911204f5ff45098c8479e">More...</a><br /></td></tr>
<tr class="separator:a6283475163d911204f5ff45098c8479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c8060c508310620870bd89969418ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa4c8060c508310620870bd89969418ac">OGR_FD_ReorderFieldDefns</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hDefn, const int *panMap)</td></tr>
<tr class="memdesc:aa4c8060c508310620870bd89969418ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the field definitions in the array of the feature definition.  <a href="ogr__api_8h.html#aa4c8060c508310620870bd89969418ac">More...</a><br /></td></tr>
<tr class="separator:aa4c8060c508310620870bd89969418ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0b3a6b6062122e4f4316d194d2a1cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf">OGR_FD_GetGeomType</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:add0b3a6b6062122e4f4316d194d2a1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the geometry base type of the passed feature definition.  <a href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf">More...</a><br /></td></tr>
<tr class="separator:add0b3a6b6062122e4f4316d194d2a1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca3a84b54ac36c5f68a03821f1fa78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11ca3a84b54ac36c5f68a03821f1fa78">OGR_FD_SetGeomType</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>)</td></tr>
<tr class="memdesc:a11ca3a84b54ac36c5f68a03821f1fa78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the base geometry type for the passed layer (the same as the feature definition).  <a href="ogr__api_8h.html#a11ca3a84b54ac36c5f68a03821f1fa78">More...</a><br /></td></tr>
<tr class="separator:a11ca3a84b54ac36c5f68a03821f1fa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1208985f67db526136dbe74f490c8d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad1208985f67db526136dbe74f490c8d3">OGR_FD_IsGeometryIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:ad1208985f67db526136dbe74f490c8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the geometry can be omitted when fetching features.  <a href="ogr__api_8h.html#ad1208985f67db526136dbe74f490c8d3">More...</a><br /></td></tr>
<tr class="separator:ad1208985f67db526136dbe74f490c8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc85e1ba2378679e4ce6bf3523bf8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1bbc85e1ba2378679e4ce6bf3523bf8e">OGR_FD_SetGeometryIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, int)</td></tr>
<tr class="memdesc:a1bbc85e1ba2378679e4ce6bf3523bf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the geometry can be omitted when fetching features.  <a href="ogr__api_8h.html#a1bbc85e1ba2378679e4ce6bf3523bf8e">More...</a><br /></td></tr>
<tr class="separator:a1bbc85e1ba2378679e4ce6bf3523bf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9490e3e5d25b780723ad3f0ab3302eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa9490e3e5d25b780723ad3f0ab3302eb">OGR_FD_IsStyleIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:aa9490e3e5d25b780723ad3f0ab3302eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the style can be omitted when fetching features.  <a href="ogr__api_8h.html#aa9490e3e5d25b780723ad3f0ab3302eb">More...</a><br /></td></tr>
<tr class="separator:aa9490e3e5d25b780723ad3f0ab3302eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09218e9ef9e49abcdd0b76858a514b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6c09218e9ef9e49abcdd0b76858a514b">OGR_FD_SetStyleIgnored</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>, int)</td></tr>
<tr class="memdesc:a6c09218e9ef9e49abcdd0b76858a514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the style can be omitted when fetching features.  <a href="ogr__api_8h.html#a6c09218e9ef9e49abcdd0b76858a514b">More...</a><br /></td></tr>
<tr class="separator:a6c09218e9ef9e49abcdd0b76858a514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6763104e7fafcab1b52d9b0f275e19e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6763104e7fafcab1b52d9b0f275e19e8">OGR_FD_Reference</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a6763104e7fafcab1b52d9b0f275e19e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference count by one.  <a href="ogr__api_8h.html#a6763104e7fafcab1b52d9b0f275e19e8">More...</a><br /></td></tr>
<tr class="separator:a6763104e7fafcab1b52d9b0f275e19e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107635936c90c7f4347d7b3f9fb06e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a107635936c90c7f4347d7b3f9fb06e6d">OGR_FD_Dereference</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a107635936c90c7f4347d7b3f9fb06e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference count by one.  <a href="ogr__api_8h.html#a107635936c90c7f4347d7b3f9fb06e6d">More...</a><br /></td></tr>
<tr class="separator:a107635936c90c7f4347d7b3f9fb06e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e8867edeaf1a6f98e6ff284835811"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9e4e8867edeaf1a6f98e6ff284835811">OGR_FD_GetReferenceCount</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a9e4e8867edeaf1a6f98e6ff284835811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch current reference count.  <a href="ogr__api_8h.html#a9e4e8867edeaf1a6f98e6ff284835811">More...</a><br /></td></tr>
<tr class="separator:a9e4e8867edeaf1a6f98e6ff284835811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b34027b691ea40e20b911290f863303"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0b34027b691ea40e20b911290f863303">OGR_FD_GetGeomFieldCount</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn)</td></tr>
<tr class="memdesc:a0b34027b691ea40e20b911290f863303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of geometry fields on the passed feature definition.  <a href="ogr__api_8h.html#a0b34027b691ea40e20b911290f863303">More...</a><br /></td></tr>
<tr class="separator:a0b34027b691ea40e20b911290f863303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82275ef1d2655817f6fe582f885c92c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a82275ef1d2655817f6fe582f885c92c7">OGR_FD_GetGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, int i)</td></tr>
<tr class="memdesc:a82275ef1d2655817f6fe582f885c92c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch geometry field definition of the passed feature definition.  <a href="ogr__api_8h.html#a82275ef1d2655817f6fe582f885c92c7">More...</a><br /></td></tr>
<tr class="separator:a82275ef1d2655817f6fe582f885c92c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be97ea100c50bdaad8a1d3c30e7b14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a69be97ea100c50bdaad8a1d3c30e7b14">OGR_FD_GetGeomFieldIndex</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, const char *pszName)</td></tr>
<tr class="memdesc:a69be97ea100c50bdaad8a1d3c30e7b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find geometry field by name.  <a href="ogr__api_8h.html#a69be97ea100c50bdaad8a1d3c30e7b14">More...</a><br /></td></tr>
<tr class="separator:a69be97ea100c50bdaad8a1d3c30e7b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa080fdbe88c1829c1b7adcce208ec4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa080fdbe88c1829c1b7adcce208ec4b8">OGR_FD_AddGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, <a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hGFldDefn)</td></tr>
<tr class="memdesc:aa080fdbe88c1829c1b7adcce208ec4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new field definition to the passed feature definition.  <a href="ogr__api_8h.html#aa080fdbe88c1829c1b7adcce208ec4b8">More...</a><br /></td></tr>
<tr class="separator:aa080fdbe88c1829c1b7adcce208ec4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb650102be3837fc220b086b17f4462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1fb650102be3837fc220b086b17f4462">OGR_FD_DeleteGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, int iGeomField)</td></tr>
<tr class="memdesc:a1fb650102be3837fc220b086b17f4462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing geometry field definition.  <a href="ogr__api_8h.html#a1fb650102be3837fc220b086b17f4462">More...</a><br /></td></tr>
<tr class="separator:a1fb650102be3837fc220b086b17f4462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07056d514160c26724f3a2d5319185f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab07056d514160c26724f3a2d5319185f">OGR_FD_IsSame</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hFDefn, <a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> hOtherFDefn)</td></tr>
<tr class="memdesc:ab07056d514160c26724f3a2d5319185f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the feature definition is identical to the other one.  <a href="ogr__api_8h.html#ab07056d514160c26724f3a2d5319185f">More...</a><br /></td></tr>
<tr class="separator:ab07056d514160c26724f3a2d5319185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d820fd7da6a079048c0d21e26fc9e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0d820fd7da6a079048c0d21e26fc9e47">OGR_F_Create</a> (<a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>)</td></tr>
<tr class="memdesc:a0d820fd7da6a079048c0d21e26fc9e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature factory.  <a href="ogr__api_8h.html#a0d820fd7da6a079048c0d21e26fc9e47">More...</a><br /></td></tr>
<tr class="separator:a0d820fd7da6a079048c0d21e26fc9e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fb8126aa932f4b4acdaca5ea99bbbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb">OGR_F_Destroy</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a16fb8126aa932f4b4acdaca5ea99bbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy feature.  <a href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb">More...</a><br /></td></tr>
<tr class="separator:a16fb8126aa932f4b4acdaca5ea99bbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123dfa431bf655aafd2dbd42247dd7be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a123dfa431bf655aafd2dbd42247dd7be">OGR_F_GetDefnRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a123dfa431bf655aafd2dbd42247dd7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch feature definition.  <a href="ogr__api_8h.html#a123dfa431bf655aafd2dbd42247dd7be">More...</a><br /></td></tr>
<tr class="separator:a123dfa431bf655aafd2dbd42247dd7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad391d3197728bb6d12a6b0c2e2661aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad391d3197728bb6d12a6b0c2e2661aa4">OGR_F_SetGeometryDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:ad391d3197728bb6d12a6b0c2e2661aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry.  <a href="ogr__api_8h.html#ad391d3197728bb6d12a6b0c2e2661aa4">More...</a><br /></td></tr>
<tr class="separator:ad391d3197728bb6d12a6b0c2e2661aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c524f5c01a6a4b4e50e351d03299f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b9c524f5c01a6a4b4e50e351d03299f">OGR_F_SetGeometry</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a7b9c524f5c01a6a4b4e50e351d03299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry.  <a href="ogr__api_8h.html#a7b9c524f5c01a6a4b4e50e351d03299f">More...</a><br /></td></tr>
<tr class="separator:a7b9c524f5c01a6a4b4e50e351d03299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf9596756aeacec4da502383c378f5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c">OGR_F_GetGeometryRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a1bf9596756aeacec4da502383c378f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a handle to feature geometry.  <a href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c">More...</a><br /></td></tr>
<tr class="separator:a1bf9596756aeacec4da502383c378f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6a61d39a67b1990ce92bd65de4bc6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5a6a61d39a67b1990ce92bd65de4bc6f">OGR_F_StealGeometry</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a5a6a61d39a67b1990ce92bd65de4bc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take away ownership of geometry.  <a href="ogr__api_8h.html#a5a6a61d39a67b1990ce92bd65de4bc6f">More...</a><br /></td></tr>
<tr class="separator:a5a6a61d39a67b1990ce92bd65de4bc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077f5a70f6fe091e3004bfd4dd952cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af077f5a70f6fe091e3004bfd4dd952cb">OGR_F_StealGeometryEx</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int iGeomField)</td></tr>
<tr class="memdesc:af077f5a70f6fe091e3004bfd4dd952cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take away ownership of geometry.  <a href="ogr__api_8h.html#af077f5a70f6fe091e3004bfd4dd952cb">More...</a><br /></td></tr>
<tr class="separator:af077f5a70f6fe091e3004bfd4dd952cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0adfd518b71571d9ce8d976fab320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a90c0adfd518b71571d9ce8d976fab320">OGR_F_Clone</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a90c0adfd518b71571d9ce8d976fab320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate feature.  <a href="ogr__api_8h.html#a90c0adfd518b71571d9ce8d976fab320">More...</a><br /></td></tr>
<tr class="separator:a90c0adfd518b71571d9ce8d976fab320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6a502ec0b70f3de50e7184a087a264"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b6a502ec0b70f3de50e7184a087a264">OGR_F_Equal</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a8b6a502ec0b70f3de50e7184a087a264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if two features are the same.  <a href="ogr__api_8h.html#a8b6a502ec0b70f3de50e7184a087a264">More...</a><br /></td></tr>
<tr class="separator:a8b6a502ec0b70f3de50e7184a087a264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c1440956ee56c0c160394bccf96990"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af6c1440956ee56c0c160394bccf96990">OGR_F_GetFieldCount</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:af6c1440956ee56c0c160394bccf96990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of fields on this feature This will always be the same as the field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.  <a href="ogr__api_8h.html#af6c1440956ee56c0c160394bccf96990">More...</a><br /></td></tr>
<tr class="separator:af6c1440956ee56c0c160394bccf96990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8fc7fd6ecca789ad90db6d28391623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6f8fc7fd6ecca789ad90db6d28391623">OGR_F_GetFieldDefnRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a6f8fc7fd6ecca789ad90db6d28391623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch definition for this field.  <a href="ogr__api_8h.html#a6f8fc7fd6ecca789ad90db6d28391623">More...</a><br /></td></tr>
<tr class="separator:a6f8fc7fd6ecca789ad90db6d28391623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a6b93ab97204b94f5c2b358f8f98e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9a8a6b93ab97204b94f5c2b358f8f98e">OGR_F_GetFieldIndex</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:a9a8a6b93ab97204b94f5c2b358f8f98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the field index given field name.  <a href="ogr__api_8h.html#a9a8a6b93ab97204b94f5c2b358f8f98e">More...</a><br /></td></tr>
<tr class="separator:a9a8a6b93ab97204b94f5c2b358f8f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb018a9030ed76353ae26082deaaef11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11">OGR_F_IsFieldSet</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:abb018a9030ed76353ae26082deaaef11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field has ever been assigned a value or not.  <a href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11">More...</a><br /></td></tr>
<tr class="separator:abb018a9030ed76353ae26082deaaef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70b7675a003141e63f9603c752ee22e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e">OGR_F_UnsetField</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:aa70b7675a003141e63f9603c752ee22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a field, marking it as unset.  <a href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e">More...</a><br /></td></tr>
<tr class="separator:aa70b7675a003141e63f9603c752ee22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d08c0ac3b9624955e682a9a2afe2b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa4d08c0ac3b9624955e682a9a2afe2b1">OGR_F_IsFieldNull</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:aa4d08c0ac3b9624955e682a9a2afe2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field is null.  <a href="ogr__api_8h.html#aa4d08c0ac3b9624955e682a9a2afe2b1">More...</a><br /></td></tr>
<tr class="separator:aa4d08c0ac3b9624955e682a9a2afe2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf414eb3a145bcd7203fca727f7a2ead"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adf414eb3a145bcd7203fca727f7a2ead">OGR_F_IsFieldSetAndNotNull</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:adf414eb3a145bcd7203fca727f7a2ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a field is set and not null.  <a href="ogr__api_8h.html#adf414eb3a145bcd7203fca727f7a2ead">More...</a><br /></td></tr>
<tr class="separator:adf414eb3a145bcd7203fca727f7a2ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090a6a8d699d4eed977ce9fcf028137a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a090a6a8d699d4eed977ce9fcf028137a">OGR_F_SetFieldNull</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a090a6a8d699d4eed977ce9fcf028137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a field, marking it as null.  <a href="ogr__api_8h.html#a090a6a8d699d4eed977ce9fcf028137a">More...</a><br /></td></tr>
<tr class="separator:a090a6a8d699d4eed977ce9fcf028137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7043e9dfadbdeca8059ace336875d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7043e9dfadbdeca8059ace336875d4c">OGR_F_GetRawFieldRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:af7043e9dfadbdeca8059ace336875d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a handle to the internal field value given the index.  <a href="ogr__api_8h.html#af7043e9dfadbdeca8059ace336875d4c">More...</a><br /></td></tr>
<tr class="separator:af7043e9dfadbdeca8059ace336875d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23095c63fc350d712940bdbf440bbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae23095c63fc350d712940bdbf440bbcb">OGR_RawField_IsUnset</a> (const <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:ae23095c63fc350d712940bdbf440bbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a raw field is unset.  <a href="ogr__api_8h.html#ae23095c63fc350d712940bdbf440bbcb">More...</a><br /></td></tr>
<tr class="separator:ae23095c63fc350d712940bdbf440bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a401e6dbd5577396b567791cf85115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa9a401e6dbd5577396b567791cf85115">OGR_RawField_IsNull</a> (const <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:aa9a401e6dbd5577396b567791cf85115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a raw field is null.  <a href="ogr__api_8h.html#aa9a401e6dbd5577396b567791cf85115">More...</a><br /></td></tr>
<tr class="separator:aa9a401e6dbd5577396b567791cf85115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaac3d8e8d01fa83a52dd2d95aac0cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acaac3d8e8d01fa83a52dd2d95aac0cc3">OGR_RawField_SetUnset</a> (<a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:acaac3d8e8d01fa83a52dd2d95aac0cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw field as unset.  <a href="ogr__api_8h.html#acaac3d8e8d01fa83a52dd2d95aac0cc3">More...</a><br /></td></tr>
<tr class="separator:acaac3d8e8d01fa83a52dd2d95aac0cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6c613c24de0e11fe259e86160157d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acf6c613c24de0e11fe259e86160157d3">OGR_RawField_SetNull</a> (<a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:acf6c613c24de0e11fe259e86160157d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw field as null.  <a href="ogr__api_8h.html#acf6c613c24de0e11fe259e86160157d3">More...</a><br /></td></tr>
<tr class="separator:acf6c613c24de0e11fe259e86160157d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb4d2c0001af379e396021ecbdaf275"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#acfb4d2c0001af379e396021ecbdaf275">OGR_F_GetFieldAsInteger</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:acfb4d2c0001af379e396021ecbdaf275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as integer.  <a href="ogr__api_8h.html#acfb4d2c0001af379e396021ecbdaf275">More...</a><br /></td></tr>
<tr class="separator:acfb4d2c0001af379e396021ecbdaf275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e190099fd6ee40e206bf4bf74d3b784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0e190099fd6ee40e206bf4bf74d3b784">OGR_F_GetFieldAsInteger64</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a0e190099fd6ee40e206bf4bf74d3b784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as integer 64 bit.  <a href="ogr__api_8h.html#a0e190099fd6ee40e206bf4bf74d3b784">More...</a><br /></td></tr>
<tr class="separator:a0e190099fd6ee40e206bf4bf74d3b784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62252a0d4538c695d41956a96cdc6978"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a62252a0d4538c695d41956a96cdc6978">OGR_F_GetFieldAsDouble</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a62252a0d4538c695d41956a96cdc6978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a double.  <a href="ogr__api_8h.html#a62252a0d4538c695d41956a96cdc6978">More...</a><br /></td></tr>
<tr class="separator:a62252a0d4538c695d41956a96cdc6978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42acfd1f4b49dddc1c308462ae800c26"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a42acfd1f4b49dddc1c308462ae800c26">OGR_F_GetFieldAsString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a42acfd1f4b49dddc1c308462ae800c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a string.  <a href="ogr__api_8h.html#a42acfd1f4b49dddc1c308462ae800c26">More...</a><br /></td></tr>
<tr class="separator:a42acfd1f4b49dddc1c308462ae800c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1800a44ab7cce67ccec3c61b947548c4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1800a44ab7cce67ccec3c61b947548c4">OGR_F_GetFieldAsISO8601DateTime</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:a1800a44ab7cce67ccec3c61b947548c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch OFTDateTime field value as a ISO8601 representation.  <a href="ogr__api_8h.html#a1800a44ab7cce67ccec3c61b947548c4">More...</a><br /></td></tr>
<tr class="separator:a1800a44ab7cce67ccec3c61b947548c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac671852e05692c584b493b2acbd6b8ce"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac671852e05692c584b493b2acbd6b8ce">OGR_F_GetFieldAsIntegerList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:ac671852e05692c584b493b2acbd6b8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of integers.  <a href="ogr__api_8h.html#ac671852e05692c584b493b2acbd6b8ce">More...</a><br /></td></tr>
<tr class="separator:ac671852e05692c584b493b2acbd6b8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df79763bd50aeef2581454bcab51ce6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9df79763bd50aeef2581454bcab51ce6">OGR_F_GetFieldAsInteger64List</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:a9df79763bd50aeef2581454bcab51ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of 64 bit integers.  <a href="ogr__api_8h.html#a9df79763bd50aeef2581454bcab51ce6">More...</a><br /></td></tr>
<tr class="separator:a9df79763bd50aeef2581454bcab51ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a27f74a38506ac492ec8b6e00eb58c9"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4a27f74a38506ac492ec8b6e00eb58c9">OGR_F_GetFieldAsDoubleList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:a4a27f74a38506ac492ec8b6e00eb58c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of doubles.  <a href="ogr__api_8h.html#a4a27f74a38506ac492ec8b6e00eb58c9">More...</a><br /></td></tr>
<tr class="separator:a4a27f74a38506ac492ec8b6e00eb58c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e55ba4a06d4c4a392206518b390ac38"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3e55ba4a06d4c4a392206518b390ac38">OGR_F_GetFieldAsStringList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:a3e55ba4a06d4c4a392206518b390ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as a list of strings.  <a href="ogr__api_8h.html#a3e55ba4a06d4c4a392206518b390ac38">More...</a><br /></td></tr>
<tr class="separator:a3e55ba4a06d4c4a392206518b390ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72727f2f59d1defa01cedfb884df1a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a72727f2f59d1defa01cedfb884df1a09">OGR_F_GetFieldAsBinary</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *)</td></tr>
<tr class="memdesc:a72727f2f59d1defa01cedfb884df1a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as binary.  <a href="ogr__api_8h.html#a72727f2f59d1defa01cedfb884df1a09">More...</a><br /></td></tr>
<tr class="separator:a72727f2f59d1defa01cedfb884df1a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ca681bb6099eb8c18004d1f7112d95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a47ca681bb6099eb8c18004d1f7112d95">OGR_F_GetFieldAsDateTime</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int *, int *, int *, int *, int *, int *, int *)</td></tr>
<tr class="memdesc:a47ca681bb6099eb8c18004d1f7112d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as date and time.  <a href="ogr__api_8h.html#a47ca681bb6099eb8c18004d1f7112d95">More...</a><br /></td></tr>
<tr class="separator:a47ca681bb6099eb8c18004d1f7112d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748995fa28574b25f6b723013a405a8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a748995fa28574b25f6b723013a405a8f">OGR_F_GetFieldAsDateTimeEx</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField, int *pnYear, int *pnMonth, int *pnDay, int *pnHour, int *pnMinute, float *pfSecond, int *pnTZFlag)</td></tr>
<tr class="memdesc:a748995fa28574b25f6b723013a405a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch field value as date and time.  <a href="ogr__api_8h.html#a748995fa28574b25f6b723013a405a8f">More...</a><br /></td></tr>
<tr class="separator:a748995fa28574b25f6b723013a405a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902fb7c7fe459aacf0b2c26b8e6d1ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad902fb7c7fe459aacf0b2c26b8e6d1ee">OGR_F_SetFieldInteger</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int)</td></tr>
<tr class="memdesc:ad902fb7c7fe459aacf0b2c26b8e6d1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to integer value.  <a href="ogr__api_8h.html#ad902fb7c7fe459aacf0b2c26b8e6d1ee">More...</a><br /></td></tr>
<tr class="separator:ad902fb7c7fe459aacf0b2c26b8e6d1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c95abf476d0ad250eb7499627f0e3b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1c95abf476d0ad250eb7499627f0e3b1">OGR_F_SetFieldInteger64</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:a1c95abf476d0ad250eb7499627f0e3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to 64 bit integer value.  <a href="ogr__api_8h.html#a1c95abf476d0ad250eb7499627f0e3b1">More...</a><br /></td></tr>
<tr class="separator:a1c95abf476d0ad250eb7499627f0e3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28aa13b1b7c88f07066c36286d13b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d28aa13b1b7c88f07066c36286d13b9">OGR_F_SetFieldDouble</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, double)</td></tr>
<tr class="memdesc:a9d28aa13b1b7c88f07066c36286d13b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to double value.  <a href="ogr__api_8h.html#a9d28aa13b1b7c88f07066c36286d13b9">More...</a><br /></td></tr>
<tr class="separator:a9d28aa13b1b7c88f07066c36286d13b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a3e8b4a08f9558807389bcdde85bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad1a3e8b4a08f9558807389bcdde85bab">OGR_F_SetFieldString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, const char *)</td></tr>
<tr class="memdesc:ad1a3e8b4a08f9558807389bcdde85bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to string value.  <a href="ogr__api_8h.html#ad1a3e8b4a08f9558807389bcdde85bab">More...</a><br /></td></tr>
<tr class="separator:ad1a3e8b4a08f9558807389bcdde85bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c8595693b4e94f3be5f796e6f7c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a984c8595693b4e94f3be5f796e6f7c92">OGR_F_SetFieldIntegerList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const int *)</td></tr>
<tr class="memdesc:a984c8595693b4e94f3be5f796e6f7c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of integers value.  <a href="ogr__api_8h.html#a984c8595693b4e94f3be5f796e6f7c92">More...</a><br /></td></tr>
<tr class="separator:a984c8595693b4e94f3be5f796e6f7c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7538949a9e8b85920381809fadbe897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af7538949a9e8b85920381809fadbe897">OGR_F_SetFieldInteger64List</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> *)</td></tr>
<tr class="memdesc:af7538949a9e8b85920381809fadbe897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of 64 bit integers value.  <a href="ogr__api_8h.html#af7538949a9e8b85920381809fadbe897">More...</a><br /></td></tr>
<tr class="separator:af7538949a9e8b85920381809fadbe897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a56d01128bf247016c139faed157be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a83a56d01128bf247016c139faed157be">OGR_F_SetFieldDoubleList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const double *)</td></tr>
<tr class="memdesc:a83a56d01128bf247016c139faed157be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of doubles value.  <a href="ogr__api_8h.html#a83a56d01128bf247016c139faed157be">More...</a><br /></td></tr>
<tr class="separator:a83a56d01128bf247016c139faed157be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35dd76723ae1acc91135054e64d7598e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a35dd76723ae1acc91135054e64d7598e">OGR_F_SetFieldStringList</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:a35dd76723ae1acc91135054e64d7598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to list of strings value.  <a href="ogr__api_8h.html#a35dd76723ae1acc91135054e64d7598e">More...</a><br /></td></tr>
<tr class="separator:a35dd76723ae1acc91135054e64d7598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5422da1e04dae4fa2248155575a54f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5422da1e04dae4fa2248155575a54f4b">OGR_F_SetFieldRaw</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, const <a class="el" href="unionOGRField.html">OGRField</a> *)</td></tr>
<tr class="memdesc:a5422da1e04dae4fa2248155575a54f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field.  <a href="ogr__api_8h.html#a5422da1e04dae4fa2248155575a54f4b">More...</a><br /></td></tr>
<tr class="separator:a5422da1e04dae4fa2248155575a54f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348b1423e9ae34290f2e32f3bdf8154b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a348b1423e9ae34290f2e32f3bdf8154b">OGR_F_SetFieldBinary</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, const void *)</td></tr>
<tr class="memdesc:a348b1423e9ae34290f2e32f3bdf8154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to binary data.  <a href="ogr__api_8h.html#a348b1423e9ae34290f2e32f3bdf8154b">More...</a><br /></td></tr>
<tr class="separator:a348b1423e9ae34290f2e32f3bdf8154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627970180a20e2a4b1c7ae694923fd73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a627970180a20e2a4b1c7ae694923fd73">OGR_F_SetFieldDateTime</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, int, int, int, int, int, int)</td></tr>
<tr class="memdesc:a627970180a20e2a4b1c7ae694923fd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to datetime.  <a href="ogr__api_8h.html#a627970180a20e2a4b1c7ae694923fd73">More...</a><br /></td></tr>
<tr class="separator:a627970180a20e2a4b1c7ae694923fd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e1bc23b8a31553550775a212075da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a71e1bc23b8a31553550775a212075da3">OGR_F_SetFieldDateTimeEx</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, int, int, int, int, int, float, int)</td></tr>
<tr class="memdesc:a71e1bc23b8a31553550775a212075da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set field to datetime.  <a href="ogr__api_8h.html#a71e1bc23b8a31553550775a212075da3">More...</a><br /></td></tr>
<tr class="separator:a71e1bc23b8a31553550775a212075da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7975076d4ab247189487c0fd50d8365c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7975076d4ab247189487c0fd50d8365c">OGR_F_GetGeomFieldCount</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat)</td></tr>
<tr class="memdesc:a7975076d4ab247189487c0fd50d8365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.  <a href="ogr__api_8h.html#a7975076d4ab247189487c0fd50d8365c">More...</a><br /></td></tr>
<tr class="separator:a7975076d4ab247189487c0fd50d8365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c3d59a3854dad80c4257e788c5d881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a11c3d59a3854dad80c4257e788c5d881">OGR_F_GetGeomFieldDefnRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField)</td></tr>
<tr class="memdesc:a11c3d59a3854dad80c4257e788c5d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch definition for this geometry field.  <a href="ogr__api_8h.html#a11c3d59a3854dad80c4257e788c5d881">More...</a><br /></td></tr>
<tr class="separator:a11c3d59a3854dad80c4257e788c5d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546acd0aad47128b1f178a8d01765e63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a546acd0aad47128b1f178a8d01765e63">OGR_F_GetGeomFieldIndex</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, const char *pszName)</td></tr>
<tr class="memdesc:a546acd0aad47128b1f178a8d01765e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the geometry field index given geometry field name.  <a href="ogr__api_8h.html#a546acd0aad47128b1f178a8d01765e63">More...</a><br /></td></tr>
<tr class="separator:a546acd0aad47128b1f178a8d01765e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">OGR_F_GetGeomFieldRef</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField)</td></tr>
<tr class="memdesc:a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a handle to feature geometry.  <a href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">More...</a><br /></td></tr>
<tr class="separator:a37aa8b53b1fc8816c5b7bcbbcb6a46ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01530e163973979cfd8248e3ecbf2640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a01530e163973979cfd8248e3ecbf2640">OGR_F_SetGeomFieldDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a01530e163973979cfd8248e3ecbf2640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry of a specified geometry field.  <a href="ogr__api_8h.html#a01530e163973979cfd8248e3ecbf2640">More...</a><br /></td></tr>
<tr class="separator:a01530e163973979cfd8248e3ecbf2640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75b18930385432110aa8d3461854cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad75b18930385432110aa8d3461854cce">OGR_F_SetGeomField</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int iField, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:ad75b18930385432110aa8d3461854cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature geometry of a specified geometry field.  <a href="ogr__api_8h.html#ad75b18930385432110aa8d3461854cce">More...</a><br /></td></tr>
<tr class="separator:ad75b18930385432110aa8d3461854cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc99defd1fb1f8f71ff89c38982f2103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc99defd1fb1f8f71ff89c38982f2103">OGR_F_GetFID</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:afc99defd1fb1f8f71ff89c38982f2103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get feature identifier.  <a href="ogr__api_8h.html#afc99defd1fb1f8f71ff89c38982f2103">More...</a><br /></td></tr>
<tr class="separator:afc99defd1fb1f8f71ff89c38982f2103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf24e93da4c03360d1d2e01664596e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#adf24e93da4c03360d1d2e01664596e29">OGR_F_SetFID</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:adf24e93da4c03360d1d2e01664596e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the feature identifier.  <a href="ogr__api_8h.html#adf24e93da4c03360d1d2e01664596e29">More...</a><br /></td></tr>
<tr class="separator:adf24e93da4c03360d1d2e01664596e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d330f942798fcbaaf27e5807fb567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae38d330f942798fcbaaf27e5807fb567">OGR_F_DumpReadable</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, FILE *)</td></tr>
<tr class="memdesc:ae38d330f942798fcbaaf27e5807fb567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this feature in a human readable form.  <a href="ogr__api_8h.html#ae38d330f942798fcbaaf27e5807fb567">More...</a><br /></td></tr>
<tr class="separator:ae38d330f942798fcbaaf27e5807fb567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace01c50d673661f76d1c8f2a2424577d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ace01c50d673661f76d1c8f2a2424577d">OGR_F_DumpReadableAsString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>)</td></tr>
<tr class="memdesc:ace01c50d673661f76d1c8f2a2424577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this feature in a human readable form.  <a href="ogr__api_8h.html#ace01c50d673661f76d1c8f2a2424577d">More...</a><br /></td></tr>
<tr class="separator:ace01c50d673661f76d1c8f2a2424577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f7057a7a3764c526a4a59e2b587fba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba">OGR_F_SetFrom</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int)</td></tr>
<tr class="memdesc:ad7f7057a7a3764c526a4a59e2b587fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one feature from another.  <a href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba">More...</a><br /></td></tr>
<tr class="separator:ad7f7057a7a3764c526a4a59e2b587fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1b7383891a47387a9b48cb02918fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9c1b7383891a47387a9b48cb02918fde">OGR_F_SetFromWithMap</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int, const int *)</td></tr>
<tr class="memdesc:a9c1b7383891a47387a9b48cb02918fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one feature from another.  <a href="ogr__api_8h.html#a9c1b7383891a47387a9b48cb02918fde">More...</a><br /></td></tr>
<tr class="separator:a9c1b7383891a47387a9b48cb02918fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fb5f53d99ccf46280e4c38afe4a5a5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a10fb5f53d99ccf46280e4c38afe4a5a5">OGR_F_GetStyleString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a10fb5f53d99ccf46280e4c38afe4a5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch style string for this feature.  <a href="ogr__api_8h.html#a10fb5f53d99ccf46280e4c38afe4a5a5">More...</a><br /></td></tr>
<tr class="separator:a10fb5f53d99ccf46280e4c38afe4a5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe436a7a48ad5bbfb3aa34f44791a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68">OGR_F_SetStyleString</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:afbe436a7a48ad5bbfb3aa34f44791a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature style string.  <a href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68">More...</a><br /></td></tr>
<tr class="separator:afbe436a7a48ad5bbfb3aa34f44791a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1ab2f6fb7937a8b927e4c1d3fd057c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c">OGR_F_SetStyleStringDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, char *)</td></tr>
<tr class="memdesc:abc1ab2f6fb7937a8b927e4c1d3fd057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature style string.  <a href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c">More...</a><br /></td></tr>
<tr class="separator:abc1ab2f6fb7937a8b927e4c1d3fd057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3bde7b0fe8c5db80d747c5e89d028"><td class="memItemLeft" align="right" valign="top"><a id="a82f3bde7b0fe8c5db80d747c5e89d028"></a>
<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a82f3bde7b0fe8c5db80d747c5e89d028">OGR_F_GetStyleTable</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a82f3bde7b0fe8c5db80d747c5e89d028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return style table. <br /></td></tr>
<tr class="separator:a82f3bde7b0fe8c5db80d747c5e89d028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a936b7f094f4d1047704417465a7279"><td class="memItemLeft" align="right" valign="top"><a id="a2a936b7f094f4d1047704417465a7279"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a2a936b7f094f4d1047704417465a7279">OGR_F_SetStyleTableDirectly</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:a2a936b7f094f4d1047704417465a7279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table and take ownership. <br /></td></tr>
<tr class="separator:a2a936b7f094f4d1047704417465a7279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10c6fd7cce64e03433af2e2ec52676c"><td class="memItemLeft" align="right" valign="top"><a id="aa10c6fd7cce64e03433af2e2ec52676c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa10c6fd7cce64e03433af2e2ec52676c">OGR_F_SetStyleTable</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:aa10c6fd7cce64e03433af2e2ec52676c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table. <br /></td></tr>
<tr class="separator:aa10c6fd7cce64e03433af2e2ec52676c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3737dec6492741cd11c1767e04edec1f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3737dec6492741cd11c1767e04edec1f">OGR_F_GetNativeData</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a3737dec6492741cd11c1767e04edec1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the native data for the feature.  <a href="ogr__api_8h.html#a3737dec6492741cd11c1767e04edec1f">More...</a><br /></td></tr>
<tr class="separator:a3737dec6492741cd11c1767e04edec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0f1eb5d248e1d2131b877026cb2a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeb0f1eb5d248e1d2131b877026cb2a8a">OGR_F_SetNativeData</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:aeb0f1eb5d248e1d2131b877026cb2a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the native data for the feature.  <a href="ogr__api_8h.html#aeb0f1eb5d248e1d2131b877026cb2a8a">More...</a><br /></td></tr>
<tr class="separator:aeb0f1eb5d248e1d2131b877026cb2a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfe5e7897623a97a2bdc0ec32323fa6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6">OGR_F_GetNativeMediaType</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:abcfe5e7897623a97a2bdc0ec32323fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the native media type for the feature.  <a href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6">More...</a><br /></td></tr>
<tr class="separator:abcfe5e7897623a97a2bdc0ec32323fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5e7ec78caaa3d0c65acb662fa6161d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5e5e7ec78caaa3d0c65acb662fa6161d">OGR_F_SetNativeMediaType</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, const char *)</td></tr>
<tr class="memdesc:a5e5e7ec78caaa3d0c65acb662fa6161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the native media type for the feature.  <a href="ogr__api_8h.html#a5e5e7ec78caaa3d0c65acb662fa6161d">More...</a><br /></td></tr>
<tr class="separator:a5e5e7ec78caaa3d0c65acb662fa6161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac705f1d608d5e33d03851a7639fdfa1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac705f1d608d5e33d03851a7639fdfa1f">OGR_F_FillUnsetWithDefault</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat, int bNotNullableOnly, char **papszOptions)</td></tr>
<tr class="memdesc:ac705f1d608d5e33d03851a7639fdfa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill unset fields with default values that might be defined.  <a href="ogr__api_8h.html#ac705f1d608d5e33d03851a7639fdfa1f">More...</a><br /></td></tr>
<tr class="separator:ac705f1d608d5e33d03851a7639fdfa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab798c73a20f4b311026232badda9701d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab798c73a20f4b311026232badda9701d">OGR_F_Validate</a> (<a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int nValidateFlags, int bEmitError)</td></tr>
<tr class="memdesc:ab798c73a20f4b311026232badda9701d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate that a feature meets constraints of its schema.  <a href="ogr__api_8h.html#ab798c73a20f4b311026232badda9701d">More...</a><br /></td></tr>
<tr class="separator:ab798c73a20f4b311026232badda9701d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b56883e79d620e4cf585e64f323787b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5b56883e79d620e4cf585e64f323787b">OGR_FldDomain_Destroy</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a5b56883e79d620e4cf585e64f323787b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a field domain.  <a href="ogr__api_8h.html#a5b56883e79d620e4cf585e64f323787b">More...</a><br /></td></tr>
<tr class="separator:a5b56883e79d620e4cf585e64f323787b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e017419012b470cf99305d2ebe2b46"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a84e017419012b470cf99305d2ebe2b46">OGR_FldDomain_GetName</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a84e017419012b470cf99305d2ebe2b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the field domain.  <a href="ogr__api_8h.html#a84e017419012b470cf99305d2ebe2b46">More...</a><br /></td></tr>
<tr class="separator:a84e017419012b470cf99305d2ebe2b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e9dd1549466905307cb4127cb2f96"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a416e9dd1549466905307cb4127cb2f96">OGR_FldDomain_GetDescription</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a416e9dd1549466905307cb4127cb2f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of the field domain.  <a href="ogr__api_8h.html#a416e9dd1549466905307cb4127cb2f96">More...</a><br /></td></tr>
<tr class="separator:a416e9dd1549466905307cb4127cb2f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059d2f1f33bba149c21aafc5ceb44e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a45135d27c2151b4e9a812c4c805750f0">OGRFieldDomainType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a059d2f1f33bba149c21aafc5ceb44e81">OGR_FldDomain_GetDomainType</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a059d2f1f33bba149c21aafc5ceb44e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the field domain.  <a href="ogr__api_8h.html#a059d2f1f33bba149c21aafc5ceb44e81">More...</a><br /></td></tr>
<tr class="separator:a059d2f1f33bba149c21aafc5ceb44e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af620d05baaca2f877571a4404d668289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af620d05baaca2f877571a4404d668289">OGR_FldDomain_GetFieldType</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:af620d05baaca2f877571a4404d668289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field type of the field domain.  <a href="ogr__api_8h.html#af620d05baaca2f877571a4404d668289">More...</a><br /></td></tr>
<tr class="separator:af620d05baaca2f877571a4404d668289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d137f7095dcbed598b12ae4c301662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a62d137f7095dcbed598b12ae4c301662">OGR_FldDomain_GetFieldSubType</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a62d137f7095dcbed598b12ae4c301662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field subtype of the field domain.  <a href="ogr__api_8h.html#a62d137f7095dcbed598b12ae4c301662">More...</a><br /></td></tr>
<tr class="separator:a62d137f7095dcbed598b12ae4c301662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73426f344716dc6ac29e8768d186dcde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#af913e138a8606cc7a201acc434a53317">OGRFieldDomainSplitPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a73426f344716dc6ac29e8768d186dcde">OGR_FldDomain_GetSplitPolicy</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a73426f344716dc6ac29e8768d186dcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the split policy of the field domain.  <a href="ogr__api_8h.html#a73426f344716dc6ac29e8768d186dcde">More...</a><br /></td></tr>
<tr class="separator:a73426f344716dc6ac29e8768d186dcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee9d25a1607b86020a83e6f3447131e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0ee9d25a1607b86020a83e6f3447131e">OGR_FldDomain_SetSplitPolicy</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>, <a class="el" href="ogr__core_8h.html#af913e138a8606cc7a201acc434a53317">OGRFieldDomainSplitPolicy</a>)</td></tr>
<tr class="memdesc:a0ee9d25a1607b86020a83e6f3447131e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the split policy of the field domain.  <a href="ogr__api_8h.html#a0ee9d25a1607b86020a83e6f3447131e">More...</a><br /></td></tr>
<tr class="separator:a0ee9d25a1607b86020a83e6f3447131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a34a6a061992272a0ab8ed7c16e4433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a367cf2b3c8f40c3892e37a09fe1805c7">OGRFieldDomainMergePolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a34a6a061992272a0ab8ed7c16e4433">OGR_FldDomain_GetMergePolicy</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a3a34a6a061992272a0ab8ed7c16e4433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the merge policy of the field domain.  <a href="ogr__api_8h.html#a3a34a6a061992272a0ab8ed7c16e4433">More...</a><br /></td></tr>
<tr class="separator:a3a34a6a061992272a0ab8ed7c16e4433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58e909e596ebb4c787d0bb7ab0c5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b58e909e596ebb4c787d0bb7ab0c5ab">OGR_FldDomain_SetMergePolicy</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>, <a class="el" href="ogr__core_8h.html#a367cf2b3c8f40c3892e37a09fe1805c7">OGRFieldDomainMergePolicy</a>)</td></tr>
<tr class="memdesc:a7b58e909e596ebb4c787d0bb7ab0c5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the merge policy of the field domain.  <a href="ogr__api_8h.html#a7b58e909e596ebb4c787d0bb7ab0c5ab">More...</a><br /></td></tr>
<tr class="separator:a7b58e909e596ebb4c787d0bb7ab0c5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b54eadd367432591534133073cafcb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5b54eadd367432591534133073cafcb6">OGR_CodedFldDomain_Create</a> (const char *pszName, const char *pszDescription, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> eFieldType, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> eFieldSubType, const <a class="el" href="structOGRCodedValue.html">OGRCodedValue</a> *enumeration)</td></tr>
<tr class="memdesc:a5b54eadd367432591534133073cafcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new coded field domain.  <a href="ogr__api_8h.html#a5b54eadd367432591534133073cafcb6">More...</a><br /></td></tr>
<tr class="separator:a5b54eadd367432591534133073cafcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971b4162d07e5640467f26dc4489c104"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structOGRCodedValue.html">OGRCodedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a971b4162d07e5640467f26dc4489c104">OGR_CodedFldDomain_GetEnumeration</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:a971b4162d07e5640467f26dc4489c104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enumeration as (code, value) pairs.  <a href="ogr__api_8h.html#a971b4162d07e5640467f26dc4489c104">More...</a><br /></td></tr>
<tr class="separator:a971b4162d07e5640467f26dc4489c104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a860f0e94cfc2bb1997ca532ee40a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af5a860f0e94cfc2bb1997ca532ee40a8">OGR_RangeFldDomain_Create</a> (const char *pszName, const char *pszDescription, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> eFieldType, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> eFieldSubType, const <a class="el" href="unionOGRField.html">OGRField</a> *psMin, bool bMinIsInclusive, const <a class="el" href="unionOGRField.html">OGRField</a> *psMax, bool bMaxIsInclusive)</td></tr>
<tr class="memdesc:af5a860f0e94cfc2bb1997ca532ee40a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new range field domain.  <a href="ogr__api_8h.html#af5a860f0e94cfc2bb1997ca532ee40a8">More...</a><br /></td></tr>
<tr class="separator:af5a860f0e94cfc2bb1997ca532ee40a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d587e32614ff09117cb2b1d9aa217"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a464d587e32614ff09117cb2b1d9aa217">OGR_RangeFldDomain_GetMin</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>, bool *pbIsInclusiveOut)</td></tr>
<tr class="memdesc:a464d587e32614ff09117cb2b1d9aa217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum value.  <a href="ogr__api_8h.html#a464d587e32614ff09117cb2b1d9aa217">More...</a><br /></td></tr>
<tr class="separator:a464d587e32614ff09117cb2b1d9aa217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e498eb7b31e2e4bda104286b019bf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a60e498eb7b31e2e4bda104286b019bf0">OGR_RangeFldDomain_GetMax</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>, bool *pbIsInclusiveOut)</td></tr>
<tr class="memdesc:a60e498eb7b31e2e4bda104286b019bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum value.  <a href="ogr__api_8h.html#a60e498eb7b31e2e4bda104286b019bf0">More...</a><br /></td></tr>
<tr class="separator:a60e498eb7b31e2e4bda104286b019bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a595da83840038ef5c93ccef61a3f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3a595da83840038ef5c93ccef61a3f77">OGR_GlobFldDomain_Create</a> (const char *pszName, const char *pszDescription, <a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> eFieldType, <a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> eFieldSubType, const char *pszGlob)</td></tr>
<tr class="memdesc:a3a595da83840038ef5c93ccef61a3f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new glob field domain.  <a href="ogr__api_8h.html#a3a595da83840038ef5c93ccef61a3f77">More...</a><br /></td></tr>
<tr class="separator:a3a595da83840038ef5c93ccef61a3f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef323febaec609ab88b7d4d3ef03a3b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afef323febaec609ab88b7d4d3ef03a3b">OGR_GlobFldDomain_GetGlob</a> (<a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>)</td></tr>
<tr class="memdesc:afef323febaec609ab88b7d4d3ef03a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the glob expression.  <a href="ogr__api_8h.html#afef323febaec609ab88b7d4d3ef03a3b">More...</a><br /></td></tr>
<tr class="separator:afef323febaec609ab88b7d4d3ef03a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88facf4f8e8b32278101d52ae094255c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c">OGR_L_GetName</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a88facf4f8e8b32278101d52ae094255c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer name.  <a href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c">More...</a><br /></td></tr>
<tr class="separator:a88facf4f8e8b32278101d52ae094255c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adea8ce1ca795ce0a6a76505f90f078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078">OGR_L_GetGeomType</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a0adea8ce1ca795ce0a6a76505f90f078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the layer geometry type.  <a href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078">More...</a><br /></td></tr>
<tr class="separator:a0adea8ce1ca795ce0a6a76505f90f078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3e553be67cbec0a7794abdc0260ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structOGRGeometryTypeCounter.html">OGRGeometryTypeCounter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a61c3e553be67cbec0a7794abdc0260ec">OGR_L_GetGeometryTypes</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, int iGeomField, int nFlags, int *pnEntryCount, GDALProgressFunc pfnProgress, void *pProgressData)</td></tr>
<tr class="memdesc:a61c3e553be67cbec0a7794abdc0260ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get actual geometry types found in features.  <a href="ogr__api_8h.html#a61c3e553be67cbec0a7794abdc0260ec">More...</a><br /></td></tr>
<tr class="separator:a61c3e553be67cbec0a7794abdc0260ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d61f311c9f8c172ad118659358c60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a">OGR_L_GetSpatialFilter</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a36d61f311c9f8c172ad118659358c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current spatial filter for this layer.  <a href="ogr__api_8h.html#a36d61f311c9f8c172ad118659358c60a">More...</a><br /></td></tr>
<tr class="separator:a36d61f311c9f8c172ad118659358c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678d1735bc82533614ac005691d1138c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c">OGR_L_SetSpatialFilter</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>)</td></tr>
<tr class="memdesc:a678d1735bc82533614ac005691d1138c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="ogr__api_8h.html#a678d1735bc82533614ac005691d1138c">More...</a><br /></td></tr>
<tr class="separator:a678d1735bc82533614ac005691d1138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cba569e0779a02a95327f041d9f7a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13">OGR_L_SetSpatialFilterRect</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, double, double, double, double)</td></tr>
<tr class="memdesc:a5cba569e0779a02a95327f041d9f7a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="ogr__api_8h.html#a5cba569e0779a02a95327f041d9f7a13">More...</a><br /></td></tr>
<tr class="separator:a5cba569e0779a02a95327f041d9f7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c8a1a968542d389f86ed1b4edd5823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823">OGR_L_SetSpatialFilterEx</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iGeomField, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> hGeom)</td></tr>
<tr class="memdesc:a00c8a1a968542d389f86ed1b4edd5823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new spatial filter.  <a href="ogr__api_8h.html#a00c8a1a968542d389f86ed1b4edd5823">More...</a><br /></td></tr>
<tr class="separator:a00c8a1a968542d389f86ed1b4edd5823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489241dfe65d6e089809d3258c4f79f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5">OGR_L_SetSpatialFilterRectEx</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iGeomField, double dfMinX, double dfMinY, double dfMaxX, double dfMaxY)</td></tr>
<tr class="memdesc:a489241dfe65d6e089809d3258c4f79f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new rectangular spatial filter.  <a href="ogr__api_8h.html#a489241dfe65d6e089809d3258c4f79f5">More...</a><br /></td></tr>
<tr class="separator:a489241dfe65d6e089809d3258c4f79f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4000d426bf26ad7cc7d4012634c93f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09">OGR_L_SetAttributeFilter</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *)</td></tr>
<tr class="memdesc:a4000d426bf26ad7cc7d4012634c93f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new attribute query.  <a href="ogr__api_8h.html#a4000d426bf26ad7cc7d4012634c93f09">More...</a><br /></td></tr>
<tr class="separator:a4000d426bf26ad7cc7d4012634c93f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0383004bf637171648a9d03a80f15a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4">OGR_L_ResetReading</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:ab0383004bf637171648a9d03a80f15a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset feature reading to start on the first feature.  <a href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4">More...</a><br /></td></tr>
<tr class="separator:ab0383004bf637171648a9d03a80f15a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6708c067521ab7b7f9c4ec0ebe221b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">OGR_L_GetNextFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a6708c067521ab7b7f9c4ec0ebe221b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next available feature from this layer.  <a href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">More...</a><br /></td></tr>
<tr class="separator:a6708c067521ab7b7f9c4ec0ebe221b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a545922d32601d007b9aad76357dd09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8a545922d32601d007b9aad76357dd09">OGR_L_GetArrowStream</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, struct ArrowArrayStream *out_stream, char **papszOptions)</td></tr>
<tr class="memdesc:a8a545922d32601d007b9aad76357dd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a Arrow C stream.  <a href="ogr__api_8h.html#a8a545922d32601d007b9aad76357dd09">More...</a><br /></td></tr>
<tr class="separator:a8a545922d32601d007b9aad76357dd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe072d5f6595a0cddd1cddbeb38416fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abe072d5f6595a0cddd1cddbeb38416fb">OGR_L_IsArrowSchemaSupported</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, const struct ArrowSchema *schema, char **papszOptions, char **ppszErrorMsg)</td></tr>
<tr class="memdesc:abe072d5f6595a0cddd1cddbeb38416fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the provided ArrowSchema is supported for writing.  <a href="ogr__api_8h.html#abe072d5f6595a0cddd1cddbeb38416fb">More...</a><br /></td></tr>
<tr class="separator:abe072d5f6595a0cddd1cddbeb38416fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea1ddbc6c9dacc75986ea77ba1f56fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aaea1ddbc6c9dacc75986ea77ba1f56fc">OGR_L_CreateFieldFromArrowSchema</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, const struct ArrowSchema *schema, char **papszOptions)</td></tr>
<tr class="memdesc:aaea1ddbc6c9dacc75986ea77ba1f56fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a field from an ArrowSchema.  <a href="ogr__api_8h.html#aaea1ddbc6c9dacc75986ea77ba1f56fc">More...</a><br /></td></tr>
<tr class="separator:aaea1ddbc6c9dacc75986ea77ba1f56fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53afc03673f67f4023108147d44989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afd53afc03673f67f4023108147d44989">OGR_L_WriteArrowBatch</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, const struct ArrowSchema *schema, struct ArrowArray *array, char **papszOptions)</td></tr>
<tr class="memdesc:afd53afc03673f67f4023108147d44989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a batch of rows from an ArrowArray.  <a href="ogr__api_8h.html#afd53afc03673f67f4023108147d44989">More...</a><br /></td></tr>
<tr class="separator:afd53afc03673f67f4023108147d44989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4427a82ea3de3bed7acff19b6e8e33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b4427a82ea3de3bed7acff19b6e8e33">OGR_L_SetNextByIndex</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:a8b4427a82ea3de3bed7acff19b6e8e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move read cursor to the nIndex'th feature in the current resultset.  <a href="ogr__api_8h.html#a8b4427a82ea3de3bed7acff19b6e8e33">More...</a><br /></td></tr>
<tr class="separator:a8b4427a82ea3de3bed7acff19b6e8e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d378c5092db944966398de8d1ac964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a29d378c5092db944966398de8d1ac964">OGR_L_GetFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:a29d378c5092db944966398de8d1ac964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a feature by its identifier.  <a href="ogr__api_8h.html#a29d378c5092db944966398de8d1ac964">More...</a><br /></td></tr>
<tr class="separator:a29d378c5092db944966398de8d1ac964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b380520d0999422987f06b6e31b9b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00">OGR_L_SetFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a5b380520d0999422987f06b6e31b9b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite/replace an existing feature.  <a href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00">More...</a><br /></td></tr>
<tr class="separator:a5b380520d0999422987f06b6e31b9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301d319111285a47fe6cda6e079214f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8">OGR_L_CreateFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a301d319111285a47fe6cda6e079214f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and write a new feature within a layer.  <a href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8">More...</a><br /></td></tr>
<tr class="separator:a301d319111285a47fe6cda6e079214f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5acdeffac0c7a8ee33ac3a55db18949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae5acdeffac0c7a8ee33ac3a55db18949">OGR_L_DeleteFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>)</td></tr>
<tr class="memdesc:ae5acdeffac0c7a8ee33ac3a55db18949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete feature from layer.  <a href="ogr__api_8h.html#ae5acdeffac0c7a8ee33ac3a55db18949">More...</a><br /></td></tr>
<tr class="separator:ae5acdeffac0c7a8ee33ac3a55db18949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fab9d73c63f923b185e4bf965208bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3">OGR_L_UpsertFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>)</td></tr>
<tr class="memdesc:a6fab9d73c63f923b185e4bf965208bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite/replace an existing feature or create a new feature within a layer.  <a href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3">More...</a><br /></td></tr>
<tr class="separator:a6fab9d73c63f923b185e4bf965208bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897b3d8c8c11a3947fd5eb9a27b47da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2">OGR_L_UpdateFeature</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>, int nUpdatedFieldsCount, const int *panUpdatedFieldsIdx, int nUpdatedGeomFieldsCount, const int *panUpdatedGeomFieldsIdx, bool bUpdateStyleString)</td></tr>
<tr class="memdesc:a897b3d8c8c11a3947fd5eb9a27b47da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update (part of) an existing feature.  <a href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2">More...</a><br /></td></tr>
<tr class="separator:a897b3d8c8c11a3947fd5eb9a27b47da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b67ea4ab5892c6720460dc7f66eca2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d">OGR_L_GetLayerDefn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a7b67ea4ab5892c6720460dc7f66eca2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the schema information for this layer.  <a href="ogr__api_8h.html#a7b67ea4ab5892c6720460dc7f66eca2d">More...</a><br /></td></tr>
<tr class="separator:a7b67ea4ab5892c6720460dc7f66eca2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2a10085f410aa84172eba413408c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39">OGR_L_GetSpatialRef</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a8b2a10085f410aa84172eba413408c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the spatial reference system for this layer.  <a href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39">More...</a><br /></td></tr>
<tr class="separator:a8b2a10085f410aa84172eba413408c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1841a38e9dc7a6f2047fdc1c463ef808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a1841a38e9dc7a6f2047fdc1c463ef808">OGR_L_GetSupportedSRSList</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, int iGeomField, int *pnCount)</td></tr>
<tr class="memdesc:a1841a38e9dc7a6f2047fdc1c463ef808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of SRS supported.  <a href="ogr__api_8h.html#a1841a38e9dc7a6f2047fdc1c463ef808">More...</a><br /></td></tr>
<tr class="separator:a1841a38e9dc7a6f2047fdc1c463ef808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250f26d915e09dc32622663ba76e9a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a250f26d915e09dc32622663ba76e9a16">OGR_L_SetActiveSRS</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, int iGeomField, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> hSRS)</td></tr>
<tr class="memdesc:a250f26d915e09dc32622663ba76e9a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the active SRS.  <a href="ogr__api_8h.html#a250f26d915e09dc32622663ba76e9a16">More...</a><br /></td></tr>
<tr class="separator:a250f26d915e09dc32622663ba76e9a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3cef62be82ec4f811a89b1855cbd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5">OGR_L_FindFieldIndex</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *, int bExactMatch)</td></tr>
<tr class="memdesc:affc3cef62be82ec4f811a89b1855cbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of field in a layer.  <a href="ogr__api_8h.html#affc3cef62be82ec4f811a89b1855cbd5">More...</a><br /></td></tr>
<tr class="separator:affc3cef62be82ec4f811a89b1855cbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08524b6961e52e1561308d2b0c598fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2">OGR_L_GetFeatureCount</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int)</td></tr>
<tr class="memdesc:a08524b6961e52e1561308d2b0c598fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the feature count in this layer.  <a href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2">More...</a><br /></td></tr>
<tr class="separator:a08524b6961e52e1561308d2b0c598fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c495581900c8301dff91d8cd3ee12f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f">OGR_L_GetExtent</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *, int)</td></tr>
<tr class="memdesc:aa6c495581900c8301dff91d8cd3ee12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer.  <a href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f">More...</a><br /></td></tr>
<tr class="separator:aa6c495581900c8301dff91d8cd3ee12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dbfd4443c80dca0d93574f0c00d376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376">OGR_L_GetExtentEx</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iGeomField, <a class="el" href="classOGREnvelope.html">OGREnvelope</a> *psExtent, int bForce)</td></tr>
<tr class="memdesc:ac3dbfd4443c80dca0d93574f0c00d376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the extent of this layer, on the specified geometry field.  <a href="ogr__api_8h.html#ac3dbfd4443c80dca0d93574f0c00d376">More...</a><br /></td></tr>
<tr class="separator:ac3dbfd4443c80dca0d93574f0c00d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed5833946cd34e49517eaedad17874d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aeed5833946cd34e49517eaedad17874d">OGR_L_GetExtent3D</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, int iGeomField, <a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *psExtent3D, int bForce)</td></tr>
<tr class="memdesc:aeed5833946cd34e49517eaedad17874d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the 3D extent of this layer, on the specified geometry field.  <a href="ogr__api_8h.html#aeed5833946cd34e49517eaedad17874d">More...</a><br /></td></tr>
<tr class="separator:aeed5833946cd34e49517eaedad17874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480adc8b839b04597f49583371d366fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd">OGR_L_TestCapability</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *)</td></tr>
<tr class="memdesc:a480adc8b839b04597f49583371d366fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this layer supported the named capability.  <a href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd">More...</a><br /></td></tr>
<tr class="separator:a480adc8b839b04597f49583371d366fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab585ef1166c61c4819f7fd46ee4a275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275">OGR_L_CreateField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>, int)</td></tr>
<tr class="memdesc:aab585ef1166c61c4819f7fd46ee4a275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new field on a layer.  <a href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275">More...</a><br /></td></tr>
<tr class="separator:aab585ef1166c61c4819f7fd46ee4a275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6908931c4f3ad364fef8d6e831363bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc">OGR_L_CreateGeomField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, <a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hFieldDefn, int bForce)</td></tr>
<tr class="memdesc:af6908931c4f3ad364fef8d6e831363bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new geometry field on a layer.  <a href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc">More...</a><br /></td></tr>
<tr class="separator:af6908931c4f3ad364fef8d6e831363bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc861413683418eba5d31e487da2f9e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2">OGR_L_DeleteField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iField)</td></tr>
<tr class="memdesc:afc861413683418eba5d31e487da2f9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing field on a layer.  <a href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2">More...</a><br /></td></tr>
<tr class="separator:afc861413683418eba5d31e487da2f9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc576cb39e1dd4a1f074125199245bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb">OGR_L_ReorderFields</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int *panMap)</td></tr>
<tr class="memdesc:a4cc576cb39e1dd4a1f074125199245bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder all the fields of a layer.  <a href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb">More...</a><br /></td></tr>
<tr class="separator:a4cc576cb39e1dd4a1f074125199245bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20a3796ee63935285976ee425878927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927">OGR_L_ReorderField</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iOldFieldPos, int iNewFieldPos)</td></tr>
<tr class="memdesc:ad20a3796ee63935285976ee425878927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder an existing field on a layer.  <a href="ogr__api_8h.html#ad20a3796ee63935285976ee425878927">More...</a><br /></td></tr>
<tr class="separator:ad20a3796ee63935285976ee425878927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679904d97c1084f309706ac3c6228cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec">OGR_L_AlterFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iField, <a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> hNewFieldDefn, int nFlags)</td></tr>
<tr class="memdesc:a679904d97c1084f309706ac3c6228cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the definition of an existing field on a layer.  <a href="ogr__api_8h.html#a679904d97c1084f309706ac3c6228cec">More...</a><br /></td></tr>
<tr class="separator:a679904d97c1084f309706ac3c6228cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d73a820734d51982ab964e6d57e7d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d73a820734d51982ab964e6d57e7d4f">OGR_L_AlterGeomFieldDefn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, int iField, <a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> hNewGeomFieldDefn, int nFlags)</td></tr>
<tr class="memdesc:a9d73a820734d51982ab964e6d57e7d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the definition of an existing geometry field on a layer.  <a href="ogr__api_8h.html#a9d73a820734d51982ab964e6d57e7d4f">More...</a><br /></td></tr>
<tr class="separator:a9d73a820734d51982ab964e6d57e7d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8180ea56ca7f677eb5da05c8cfcb77be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a8180ea56ca7f677eb5da05c8cfcb77be">OGR_L_StartTransaction</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a8180ea56ca7f677eb5da05c8cfcb77be"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, StartTransaction creates a transaction.  <a href="ogr__api_8h.html#a8180ea56ca7f677eb5da05c8cfcb77be">More...</a><br /></td></tr>
<tr class="separator:a8180ea56ca7f677eb5da05c8cfcb77be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6135ef3b16c3cc974682365783603cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6135ef3b16c3cc974682365783603cc6">OGR_L_CommitTransaction</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a6135ef3b16c3cc974682365783603cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, CommitTransaction commits a transaction.  <a href="ogr__api_8h.html#a6135ef3b16c3cc974682365783603cc6">More...</a><br /></td></tr>
<tr class="separator:a6135ef3b16c3cc974682365783603cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823a6c351dccf751777f67801dd7f9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5">OGR_L_RollbackTransaction</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a823a6c351dccf751777f67801dd7f9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction.  <a href="ogr__api_8h.html#a823a6c351dccf751777f67801dd7f9c5">More...</a><br /></td></tr>
<tr class="separator:a823a6c351dccf751777f67801dd7f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e14b2016b5542ca1a7b54929ee719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a952e14b2016b5542ca1a7b54929ee719">OGR_L_Rename</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> hLayer, const char *pszNewName)</td></tr>
<tr class="memdesc:a952e14b2016b5542ca1a7b54929ee719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename layer.  <a href="ogr__api_8h.html#a952e14b2016b5542ca1a7b54929ee719">More...</a><br /></td></tr>
<tr class="separator:a952e14b2016b5542ca1a7b54929ee719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d845a6cf6652756925530418905471a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a">OGR_L_SyncToDisk</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:a9d845a6cf6652756925530418905471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending changes to disk.  <a href="ogr__api_8h.html#a9d845a6cf6652756925530418905471a">More...</a><br /></td></tr>
<tr class="separator:a9d845a6cf6652756925530418905471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeb6e1258f113c6c45c8d6a43c8cfa5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5">OGR_L_GetFIDColumn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:abfeb6e1258f113c6c45c8d6a43c8cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the FID column, or "" if not supported.  <a href="ogr__api_8h.html#abfeb6e1258f113c6c45c8d6a43c8cfa5">More...</a><br /></td></tr>
<tr class="separator:abfeb6e1258f113c6c45c8d6a43c8cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060e07e277cebd1d8504c449d97b29f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f">OGR_L_GetGeometryColumn</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:ab060e07e277cebd1d8504c449d97b29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the name of the underlying database column being used as the geometry column, or "" if not supported.  <a href="ogr__api_8h.html#ab060e07e277cebd1d8504c449d97b29f">More...</a><br /></td></tr>
<tr class="separator:ab060e07e277cebd1d8504c449d97b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceae9ba8158efda9d1bd016022c627ca"><td class="memItemLeft" align="right" valign="top"><a id="aceae9ba8158efda9d1bd016022c627ca"></a>
<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aceae9ba8158efda9d1bd016022c627ca">OGR_L_GetStyleTable</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:aceae9ba8158efda9d1bd016022c627ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get style table. <br /></td></tr>
<tr class="separator:aceae9ba8158efda9d1bd016022c627ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b700a54fb41ade2b3b090b2e0ef4be"><td class="memItemLeft" align="right" valign="top"><a id="ab6b700a54fb41ade2b3b090b2e0ef4be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab6b700a54fb41ade2b3b090b2e0ef4be">OGR_L_SetStyleTableDirectly</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:ab6b700a54fb41ade2b3b090b2e0ef4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table (and take ownership) <br /></td></tr>
<tr class="separator:ab6b700a54fb41ade2b3b090b2e0ef4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5965608098528549e585895cb62e92"><td class="memItemLeft" align="right" valign="top"><a id="a9c5965608098528549e585895cb62e92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9c5965608098528549e585895cb62e92">OGR_L_SetStyleTable</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:a9c5965608098528549e585895cb62e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table. <br /></td></tr>
<tr class="separator:a9c5965608098528549e585895cb62e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d43f1474201356bed2e6f92e7d37154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154">OGR_L_SetIgnoredFields</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char **)</td></tr>
<tr class="memdesc:a6d43f1474201356bed2e6f92e7d37154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set which fields can be omitted when retrieving features from the layer.  <a href="ogr__api_8h.html#a6d43f1474201356bed2e6f92e7d37154">More...</a><br /></td></tr>
<tr class="separator:a6d43f1474201356bed2e6f92e7d37154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c353cc32c9dd02967a7bed1450d2524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524">OGR_L_Intersection</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a5c353cc32c9dd02967a7bed1450d2524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two layers.  <a href="ogr__api_8h.html#a5c353cc32c9dd02967a7bed1450d2524">More...</a><br /></td></tr>
<tr class="separator:a5c353cc32c9dd02967a7bed1450d2524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8edb8696c2b046370e29efdd73787f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7">OGR_L_Union</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:ac8edb8696c2b046370e29efdd73787f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two layers.  <a href="ogr__api_8h.html#ac8edb8696c2b046370e29efdd73787f7">More...</a><br /></td></tr>
<tr class="separator:ac8edb8696c2b046370e29efdd73787f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03249311ff4c88b2fac5f728be63b549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549">OGR_L_SymDifference</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a03249311ff4c88b2fac5f728be63b549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrical difference of two layers.  <a href="ogr__api_8h.html#a03249311ff4c88b2fac5f728be63b549">More...</a><br /></td></tr>
<tr class="separator:a03249311ff4c88b2fac5f728be63b549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67948074f2e2942cebdd0f90bbec8aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9">OGR_L_Identity</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a67948074f2e2942cebdd0f90bbec8aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify the features of this layer with the ones from the identity layer.  <a href="ogr__api_8h.html#a67948074f2e2942cebdd0f90bbec8aa9">More...</a><br /></td></tr>
<tr class="separator:a67948074f2e2942cebdd0f90bbec8aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b478c971619145dee7d8d8deeac702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702">OGR_L_Update</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a87b478c971619145dee7d8d8deeac702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update this layer with features from the update layer.  <a href="ogr__api_8h.html#a87b478c971619145dee7d8d8deeac702">More...</a><br /></td></tr>
<tr class="separator:a87b478c971619145dee7d8d8deeac702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12dcd5dc6dc5f930218573658f1b5c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2">OGR_L_Clip</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:ae12dcd5dc6dc5f930218573658f1b5c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip off areas that are not covered by the method layer.  <a href="ogr__api_8h.html#ae12dcd5dc6dc5f930218573658f1b5c2">More...</a><br /></td></tr>
<tr class="separator:ae12dcd5dc6dc5f930218573658f1b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c47bbeae70e609f4e51a239784285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285">OGR_L_Erase</a> (<a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, char **, GDALProgressFunc, void *)</td></tr>
<tr class="memdesc:a0f8c47bbeae70e609f4e51a239784285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove areas that are covered by the method layer.  <a href="ogr__api_8h.html#a0f8c47bbeae70e609f4e51a239784285">More...</a><br /></td></tr>
<tr class="separator:a0f8c47bbeae70e609f4e51a239784285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4823e7c3513cd9d57254364de9a1d021"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021">OGR_DS_Destroy</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a4823e7c3513cd9d57254364de9a1d021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes opened datasource and releases allocated resources.  <a href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021">More...</a><br /></td></tr>
<tr class="separator:a4823e7c3513cd9d57254364de9a1d021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8cc826474b55371b1b4e24a24ba1db"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aea8cc826474b55371b1b4e24a24ba1db">OGR_DS_GetName</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:aea8cc826474b55371b1b4e24a24ba1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the data source.  <a href="ogr__api_8h.html#aea8cc826474b55371b1b4e24a24ba1db">More...</a><br /></td></tr>
<tr class="separator:aea8cc826474b55371b1b4e24a24ba1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da541cb655ab631df729e71da2e762"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762">OGR_DS_GetLayerCount</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:ac6da541cb655ab631df729e71da2e762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of layers in this data source.  <a href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762">More...</a><br /></td></tr>
<tr class="separator:ac6da541cb655ab631df729e71da2e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03998029f904d1c3b12de40114e7503e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03998029f904d1c3b12de40114e7503e">OGR_DS_GetLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, int)</td></tr>
<tr class="memdesc:a03998029f904d1c3b12de40114e7503e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a layer by index.  <a href="ogr__api_8h.html#a03998029f904d1c3b12de40114e7503e">More...</a><br /></td></tr>
<tr class="separator:a03998029f904d1c3b12de40114e7503e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74af4912b67bf2a7b6e3230711a40d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a74af4912b67bf2a7b6e3230711a40d0e">OGR_DS_GetLayerByName</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *)</td></tr>
<tr class="memdesc:a74af4912b67bf2a7b6e3230711a40d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a layer by name.  <a href="ogr__api_8h.html#a74af4912b67bf2a7b6e3230711a40d0e">More...</a><br /></td></tr>
<tr class="separator:a74af4912b67bf2a7b6e3230711a40d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85827a79cd2ddb5a55126e785bee427d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a85827a79cd2ddb5a55126e785bee427d">OGR_DS_DeleteLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, int)</td></tr>
<tr class="memdesc:a85827a79cd2ddb5a55126e785bee427d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the indicated layer from the datasource.  <a href="ogr__api_8h.html#a85827a79cd2ddb5a55126e785bee427d">More...</a><br /></td></tr>
<tr class="separator:a85827a79cd2ddb5a55126e785bee427d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def9c0aa6f6f60ab96369203330e326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5def9c0aa6f6f60ab96369203330e326">OGR_DS_GetDriver</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a5def9c0aa6f6f60ab96369203330e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the driver that the dataset was opened with.  <a href="ogr__api_8h.html#a5def9c0aa6f6f60ab96369203330e326">More...</a><br /></td></tr>
<tr class="separator:a5def9c0aa6f6f60ab96369203330e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d383a37fbeaea58acaea11717f320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *, <a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>, <a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>, char **)</td></tr>
<tr class="memdesc:a424d383a37fbeaea58acaea11717f320"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type.  <a href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">More...</a><br /></td></tr>
<tr class="separator:a424d383a37fbeaea58acaea11717f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d34530517b618696c97b73de31df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a628d34530517b618696c97b73de31df7">OGR_DS_CopyLayer</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>, const char *, char **)</td></tr>
<tr class="memdesc:a628d34530517b618696c97b73de31df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate an existing layer.  <a href="ogr__api_8h.html#a628d34530517b618696c97b73de31df7">More...</a><br /></td></tr>
<tr class="separator:a628d34530517b618696c97b73de31df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fefab726442fa71ab5ef74fe8549a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *)</td></tr>
<tr class="memdesc:ad0fefab726442fa71ab5ef74fe8549a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if capability is available.  <a href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">More...</a><br /></td></tr>
<tr class="separator:ad0fefab726442fa71ab5ef74fe8549a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9892ecb0bf61add295bd9decdb13797a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a">OGR_DS_ExecuteSQL</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *, <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>, const char *)</td></tr>
<tr class="memdesc:a9892ecb0bf61add295bd9decdb13797a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute an SQL statement against the data store.  <a href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a">More...</a><br /></td></tr>
<tr class="separator:a9892ecb0bf61add295bd9decdb13797a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7b521a05c1207e298a2b9dbf4a1181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181">OGR_DS_ReleaseResultSet</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>)</td></tr>
<tr class="memdesc:afc7b521a05c1207e298a2b9dbf4a1181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release results of <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a>.  <a href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181">More...</a><br /></td></tr>
<tr class="separator:afc7b521a05c1207e298a2b9dbf4a1181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ab189c06d9f5f26e21b134928f882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a139ab189c06d9f5f26e21b134928f882">OGR_DS_SyncToDisk</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a139ab189c06d9f5f26e21b134928f882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending changes to disk.  <a href="ogr__api_8h.html#a139ab189c06d9f5f26e21b134928f882">More...</a><br /></td></tr>
<tr class="separator:a139ab189c06d9f5f26e21b134928f882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6164ac434dcd9660089c97fd59bab558"><td class="memItemLeft" align="right" valign="top"><a id="a6164ac434dcd9660089c97fd59bab558"></a>
<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a6164ac434dcd9660089c97fd59bab558">OGR_DS_GetStyleTable</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:a6164ac434dcd9660089c97fd59bab558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get style table. <br /></td></tr>
<tr class="separator:a6164ac434dcd9660089c97fd59bab558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf553bb35c9f1707b3c727af166c8a0a"><td class="memItemLeft" align="right" valign="top"><a id="aaf553bb35c9f1707b3c727af166c8a0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aaf553bb35c9f1707b3c727af166c8a0a">OGR_DS_SetStyleTableDirectly</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:aaf553bb35c9f1707b3c727af166c8a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table (and take ownership) <br /></td></tr>
<tr class="separator:aaf553bb35c9f1707b3c727af166c8a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03947d4ec069a83526274780c8a6f48b"><td class="memItemLeft" align="right" valign="top"><a id="a03947d4ec069a83526274780c8a6f48b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a03947d4ec069a83526274780c8a6f48b">OGR_DS_SetStyleTable</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, <a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>)</td></tr>
<tr class="memdesc:a03947d4ec069a83526274780c8a6f48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set style table. <br /></td></tr>
<tr class="separator:a03947d4ec069a83526274780c8a6f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd11ea603491207a89c75b6b9480e091"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afd11ea603491207a89c75b6b9480e091">OGR_Dr_GetName</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>)</td></tr>
<tr class="memdesc:afd11ea603491207a89c75b6b9480e091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch name of driver (file format).  <a href="ogr__api_8h.html#afd11ea603491207a89c75b6b9480e091">More...</a><br /></td></tr>
<tr class="separator:afd11ea603491207a89c75b6b9480e091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35488a77aae79835b8b753095cebc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#abd35488a77aae79835b8b753095cebc7">OGR_Dr_Open</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *, int)</td></tr>
<tr class="memdesc:abd35488a77aae79835b8b753095cebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to open file with this driver.  <a href="ogr__api_8h.html#abd35488a77aae79835b8b753095cebc7">More...</a><br /></td></tr>
<tr class="separator:abd35488a77aae79835b8b753095cebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9010219bbc2e32627064ed860048d979"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a9010219bbc2e32627064ed860048d979">OGR_Dr_TestCapability</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *)</td></tr>
<tr class="memdesc:a9010219bbc2e32627064ed860048d979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if capability is available.  <a href="ogr__api_8h.html#a9010219bbc2e32627064ed860048d979">More...</a><br /></td></tr>
<tr class="separator:a9010219bbc2e32627064ed860048d979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a9c68495afce08505b8bbe36c1b96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a09a9c68495afce08505b8bbe36c1b96e">OGR_Dr_CreateDataSource</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *, char **)</td></tr>
<tr class="memdesc:a09a9c68495afce08505b8bbe36c1b96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts to create a new data source based on the passed driver.  <a href="ogr__api_8h.html#a09a9c68495afce08505b8bbe36c1b96e">More...</a><br /></td></tr>
<tr class="separator:a09a9c68495afce08505b8bbe36c1b96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2104c8a76634f8841e3312295e717b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa2104c8a76634f8841e3312295e717b2">OGR_Dr_CopyDataSource</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, <a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>, const char *, char **)</td></tr>
<tr class="memdesc:aa2104c8a76634f8841e3312295e717b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a new datasource by copying all the layers from the source datasource.  <a href="ogr__api_8h.html#aa2104c8a76634f8841e3312295e717b2">More...</a><br /></td></tr>
<tr class="separator:aa2104c8a76634f8841e3312295e717b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2314e22acd846e7e31ff5a5c5ec27f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4d2314e22acd846e7e31ff5a5c5ec27f">OGR_Dr_DeleteDataSource</a> (<a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>, const char *)</td></tr>
<tr class="memdesc:a4d2314e22acd846e7e31ff5a5c5ec27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a datasource.  <a href="ogr__api_8h.html#a4d2314e22acd846e7e31ff5a5c5ec27f">More...</a><br /></td></tr>
<tr class="separator:a4d2314e22acd846e7e31ff5a5c5ec27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123bb02ac8c5cfe143e132f627531125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a123bb02ac8c5cfe143e132f627531125">OGROpen</a> (const char *, int, <a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *)</td></tr>
<tr class="memdesc:a123bb02ac8c5cfe143e132f627531125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file / data source with one of the registered drivers.  <a href="ogr__api_8h.html#a123bb02ac8c5cfe143e132f627531125">More...</a><br /></td></tr>
<tr class="separator:a123bb02ac8c5cfe143e132f627531125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0a37e24d4acaa8b394a0e07d7de432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aff0a37e24d4acaa8b394a0e07d7de432">OGROpenShared</a> (const char *, int, <a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *)</td></tr>
<tr class="memdesc:aff0a37e24d4acaa8b394a0e07d7de432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with <a class="el" href="ogr__api_8h.html#aff0a37e24d4acaa8b394a0e07d7de432" title="Open a file / data source with one of the registered drivers if not already opened,...">OGROpenShared()</a>  <a href="ogr__api_8h.html#aff0a37e24d4acaa8b394a0e07d7de432">More...</a><br /></td></tr>
<tr class="separator:aff0a37e24d4acaa8b394a0e07d7de432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3abed0c3b232fe55a580726536fe6fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad3abed0c3b232fe55a580726536fe6fa">OGRReleaseDataSource</a> (<a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>)</td></tr>
<tr class="memdesc:ad3abed0c3b232fe55a580726536fe6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource.  <a href="ogr__api_8h.html#ad3abed0c3b232fe55a580726536fe6fa">More...</a><br /></td></tr>
<tr class="separator:ad3abed0c3b232fe55a580726536fe6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f6d2bbd269b56a61d1c1841dac2575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad0f6d2bbd269b56a61d1c1841dac2575">OGRGetDriverCount</a> (void)</td></tr>
<tr class="memdesc:ad0f6d2bbd269b56a61d1c1841dac2575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the number of registered drivers.  <a href="ogr__api_8h.html#ad0f6d2bbd269b56a61d1c1841dac2575">More...</a><br /></td></tr>
<tr class="separator:ad0f6d2bbd269b56a61d1c1841dac2575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8080605cad5aeef9519c38fe160b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a3f8080605cad5aeef9519c38fe160b51">OGRGetDriver</a> (int)</td></tr>
<tr class="memdesc:a3f8080605cad5aeef9519c38fe160b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the indicated driver.  <a href="ogr__api_8h.html#a3f8080605cad5aeef9519c38fe160b51">More...</a><br /></td></tr>
<tr class="separator:a3f8080605cad5aeef9519c38fe160b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814db7e2212b9bbb0fd8c361bee11fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae814db7e2212b9bbb0fd8c361bee11fe">OGRGetDriverByName</a> (const char *)</td></tr>
<tr class="memdesc:ae814db7e2212b9bbb0fd8c361bee11fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the indicated driver.  <a href="ogr__api_8h.html#ae814db7e2212b9bbb0fd8c361bee11fe">More...</a><br /></td></tr>
<tr class="separator:ae814db7e2212b9bbb0fd8c361bee11fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae904632d0bc86ba5501921ca594e18da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae904632d0bc86ba5501921ca594e18da">OGRRegisterAll</a> (void)</td></tr>
<tr class="memdesc:ae904632d0bc86ba5501921ca594e18da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register all drivers.  <a href="ogr__api_8h.html#ae904632d0bc86ba5501921ca594e18da">More...</a><br /></td></tr>
<tr class="separator:ae904632d0bc86ba5501921ca594e18da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5a052ed1046ec85236fe4a92733e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ae5d5a052ed1046ec85236fe4a92733e2">OGRCleanupAll</a> (void)</td></tr>
<tr class="memdesc:ae5d5a052ed1046ec85236fe4a92733e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean-up all drivers (including raster ones starting with GDAL 2.0.  <a href="ogr__api_8h.html#ae5d5a052ed1046ec85236fe4a92733e2">More...</a><br /></td></tr>
<tr class="separator:ae5d5a052ed1046ec85236fe4a92733e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30cc732f956f17bbd13995bc648cb0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ab30cc732f956f17bbd13995bc648cb0a">OGR_SM_Create</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:ab30cc732f956f17bbd13995bc648cb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRStyleMgr.html" title="This class represents a style manager.">OGRStyleMgr</a> factory.  <a href="ogr__api_8h.html#ab30cc732f956f17bbd13995bc648cb0a">More...</a><br /></td></tr>
<tr class="separator:ab30cc732f956f17bbd13995bc648cb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474fca7d9327da916305ec1276a57443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a474fca7d9327da916305ec1276a57443">OGR_SM_Destroy</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM)</td></tr>
<tr class="memdesc:a474fca7d9327da916305ec1276a57443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Style Manager.  <a href="ogr__api_8h.html#a474fca7d9327da916305ec1276a57443">More...</a><br /></td></tr>
<tr class="separator:a474fca7d9327da916305ec1276a57443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca737ee6586ce8078b52108707b0b6a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afca737ee6586ce8078b52108707b0b6a">OGR_SM_InitFromFeature</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, <a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> hFeat)</td></tr>
<tr class="memdesc:afca737ee6586ce8078b52108707b0b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize style manager from the style string of a feature.  <a href="ogr__api_8h.html#afca737ee6586ce8078b52108707b0b6a">More...</a><br /></td></tr>
<tr class="separator:afca737ee6586ce8078b52108707b0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade49bffec1e796ddf4419f5cbe34fda8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ade49bffec1e796ddf4419f5cbe34fda8">OGR_SM_InitStyleString</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, const char *pszStyleString)</td></tr>
<tr class="memdesc:ade49bffec1e796ddf4419f5cbe34fda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize style manager from the style string.  <a href="ogr__api_8h.html#ade49bffec1e796ddf4419f5cbe34fda8">More...</a><br /></td></tr>
<tr class="separator:ade49bffec1e796ddf4419f5cbe34fda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad272704a535c0fa8cfd7b097eb4968dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad272704a535c0fa8cfd7b097eb4968dc">OGR_SM_GetPartCount</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, const char *pszStyleString)</td></tr>
<tr class="memdesc:ad272704a535c0fa8cfd7b097eb4968dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of parts in a style.  <a href="ogr__api_8h.html#ad272704a535c0fa8cfd7b097eb4968dc">More...</a><br /></td></tr>
<tr class="separator:ad272704a535c0fa8cfd7b097eb4968dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4e04abb6e3c59ed570c62dffc4164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a61d4e04abb6e3c59ed570c62dffc4164">OGR_SM_GetPart</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, int nPartId, const char *pszStyleString)</td></tr>
<tr class="memdesc:a61d4e04abb6e3c59ed570c62dffc4164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a part (style tool) from the current style.  <a href="ogr__api_8h.html#a61d4e04abb6e3c59ed570c62dffc4164">More...</a><br /></td></tr>
<tr class="separator:a61d4e04abb6e3c59ed570c62dffc4164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358ec087124f355fca02bf33a1e0027"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af358ec087124f355fca02bf33a1e0027">OGR_SM_AddPart</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, <a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:af358ec087124f355fca02bf33a1e0027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a part (style tool) to the current style.  <a href="ogr__api_8h.html#af358ec087124f355fca02bf33a1e0027">More...</a><br /></td></tr>
<tr class="separator:af358ec087124f355fca02bf33a1e0027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358c1558e61951b2e1e338ead8401ad8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a358c1558e61951b2e1e338ead8401ad8">OGR_SM_AddStyle</a> (<a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> hSM, const char *pszStyleName, const char *pszStyleString)</td></tr>
<tr class="memdesc:a358c1558e61951b2e1e338ead8401ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a style to the current style table.  <a href="ogr__api_8h.html#a358c1558e61951b2e1e338ead8401ad8">More...</a><br /></td></tr>
<tr class="separator:a358c1558e61951b2e1e338ead8401ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb15db531e15a484e7bda8e88383ea3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afb15db531e15a484e7bda8e88383ea3a">OGR_ST_Create</a> (<a class="el" href="ogr__core_8h.html#a999df73d8937a8c3f553103956352817">OGRSTClassId</a> eClassId)</td></tr>
<tr class="memdesc:afb15db531e15a484e7bda8e88383ea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> factory.  <a href="ogr__api_8h.html#afb15db531e15a484e7bda8e88383ea3a">More...</a><br /></td></tr>
<tr class="separator:afb15db531e15a484e7bda8e88383ea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ecf398ee062f3f5a297f70244497a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a">OGR_ST_Destroy</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:a5d1ecf398ee062f3f5a297f70244497a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Style Tool.  <a href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a">More...</a><br /></td></tr>
<tr class="separator:a5d1ecf398ee062f3f5a297f70244497a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8d0ee36b82c9d1d8d1a0e9b36f2d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#a999df73d8937a8c3f553103956352817">OGRSTClassId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">OGR_ST_GetType</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:aae8d0ee36b82c9d1d8d1a0e9b36f2d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine type of Style Tool.  <a href="ogr__api_8h.html#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">More...</a><br /></td></tr>
<tr class="separator:aae8d0ee36b82c9d1d8d1a0e9b36f2d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb52e40f289848d1f228849b6dae2463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__core_8h.html#aac601656ab03334951883a7041fc0482">OGRSTUnitId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#afb52e40f289848d1f228849b6dae2463">OGR_ST_GetUnit</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:afb52e40f289848d1f228849b6dae2463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool units.  <a href="ogr__api_8h.html#afb52e40f289848d1f228849b6dae2463">More...</a><br /></td></tr>
<tr class="separator:afb52e40f289848d1f228849b6dae2463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c5b94e6ca32cd53c6a7a9ebc73012c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac9c5b94e6ca32cd53c6a7a9ebc73012c">OGR_ST_SetUnit</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, <a class="el" href="ogr__core_8h.html#aac601656ab03334951883a7041fc0482">OGRSTUnitId</a> eUnit, double dfGroundPaperScale)</td></tr>
<tr class="memdesc:ac9c5b94e6ca32cd53c6a7a9ebc73012c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool units.  <a href="ogr__api_8h.html#ac9c5b94e6ca32cd53c6a7a9ebc73012c">More...</a><br /></td></tr>
<tr class="separator:ac9c5b94e6ca32cd53c6a7a9ebc73012c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecadf5738c3b96093605b352a95869f1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aecadf5738c3b96093605b352a95869f1">OGR_ST_GetParamStr</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int *bValueIsNull)</td></tr>
<tr class="memdesc:aecadf5738c3b96093605b352a95869f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool parameter value as string.  <a href="ogr__api_8h.html#aecadf5738c3b96093605b352a95869f1">More...</a><br /></td></tr>
<tr class="separator:aecadf5738c3b96093605b352a95869f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4168832561881cb75dcc7c35935cdd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad4168832561881cb75dcc7c35935cdd3">OGR_ST_GetParamNum</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int *bValueIsNull)</td></tr>
<tr class="memdesc:ad4168832561881cb75dcc7c35935cdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool parameter value as an integer.  <a href="ogr__api_8h.html#ad4168832561881cb75dcc7c35935cdd3">More...</a><br /></td></tr>
<tr class="separator:ad4168832561881cb75dcc7c35935cdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96082cdf432271acfa3b3777c3be853b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a96082cdf432271acfa3b3777c3be853b">OGR_ST_GetParamDbl</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int *bValueIsNull)</td></tr>
<tr class="memdesc:a96082cdf432271acfa3b3777c3be853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Style Tool parameter value as a double.  <a href="ogr__api_8h.html#a96082cdf432271acfa3b3777c3be853b">More...</a><br /></td></tr>
<tr class="separator:a96082cdf432271acfa3b3777c3be853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e9561d9a62d6f8368d526eb0468b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a88e9561d9a62d6f8368d526eb0468b3a">OGR_ST_SetParamStr</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, const char *pszValue)</td></tr>
<tr class="memdesc:a88e9561d9a62d6f8368d526eb0468b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool parameter value from a string.  <a href="ogr__api_8h.html#a88e9561d9a62d6f8368d526eb0468b3a">More...</a><br /></td></tr>
<tr class="separator:a88e9561d9a62d6f8368d526eb0468b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0397850aed3282865b444d65d2deb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ac0397850aed3282865b444d65d2deb0e">OGR_ST_SetParamNum</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, int nValue)</td></tr>
<tr class="memdesc:ac0397850aed3282865b444d65d2deb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool parameter value from an integer.  <a href="ogr__api_8h.html#ac0397850aed3282865b444d65d2deb0e">More...</a><br /></td></tr>
<tr class="separator:ac0397850aed3282865b444d65d2deb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764f52f8a72e950d0a5d84b7a7b37fc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a764f52f8a72e950d0a5d84b7a7b37fc8">OGR_ST_SetParamDbl</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, int eParam, double dfValue)</td></tr>
<tr class="memdesc:a764f52f8a72e950d0a5d84b7a7b37fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Style Tool parameter value from a double.  <a href="ogr__api_8h.html#a764f52f8a72e950d0a5d84b7a7b37fc8">More...</a><br /></td></tr>
<tr class="separator:a764f52f8a72e950d0a5d84b7a7b37fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4089c70ce3b1cbea0e45c3375d5093f0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a4089c70ce3b1cbea0e45c3375d5093f0">OGR_ST_GetStyleString</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST)</td></tr>
<tr class="memdesc:a4089c70ce3b1cbea0e45c3375d5093f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the style string for this Style Tool.  <a href="ogr__api_8h.html#a4089c70ce3b1cbea0e45c3375d5093f0">More...</a><br /></td></tr>
<tr class="separator:a4089c70ce3b1cbea0e45c3375d5093f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906f5e2b901413a0ab5fa35d649847fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a906f5e2b901413a0ab5fa35d649847fc">OGR_ST_GetRGBFromString</a> (<a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> hST, const char *pszColor, int *pnRed, int *pnGreen, int *pnBlue, int *pnAlpha)</td></tr>
<tr class="memdesc:a906f5e2b901413a0ab5fa35d649847fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format.  <a href="ogr__api_8h.html#a906f5e2b901413a0ab5fa35d649847fc">More...</a><br /></td></tr>
<tr class="separator:a906f5e2b901413a0ab5fa35d649847fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98697c161a0d07fd2f81b3129deddb36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a98697c161a0d07fd2f81b3129deddb36">OGR_STBL_Create</a> (void)</td></tr>
<tr class="memdesc:a98697c161a0d07fd2f81b3129deddb36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOGRStyleTable.html" title="This class represents a style table.">OGRStyleTable</a> factory.  <a href="ogr__api_8h.html#a98697c161a0d07fd2f81b3129deddb36">More...</a><br /></td></tr>
<tr class="separator:a98697c161a0d07fd2f81b3129deddb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf4e22eb7ef07c4a3249c21dce48764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a5cf4e22eb7ef07c4a3249c21dce48764">OGR_STBL_Destroy</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hSTBL)</td></tr>
<tr class="memdesc:a5cf4e22eb7ef07c4a3249c21dce48764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy Style Table.  <a href="ogr__api_8h.html#a5cf4e22eb7ef07c4a3249c21dce48764">More...</a><br /></td></tr>
<tr class="separator:a5cf4e22eb7ef07c4a3249c21dce48764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd2a4f109627f282c42229eaad7cdfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aacd2a4f109627f282c42229eaad7cdfd">OGR_STBL_AddStyle</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszName, const char *pszStyleString)</td></tr>
<tr class="memdesc:aacd2a4f109627f282c42229eaad7cdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new style in the table.  <a href="ogr__api_8h.html#aacd2a4f109627f282c42229eaad7cdfd">More...</a><br /></td></tr>
<tr class="separator:aacd2a4f109627f282c42229eaad7cdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e3aca0d4f3fefe3dd64da65814dda7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aa3e3aca0d4f3fefe3dd64da65814dda7">OGR_STBL_SaveStyleTable</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszFilename)</td></tr>
<tr class="memdesc:aa3e3aca0d4f3fefe3dd64da65814dda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a style table to a file.  <a href="ogr__api_8h.html#aa3e3aca0d4f3fefe3dd64da65814dda7">More...</a><br /></td></tr>
<tr class="separator:aa3e3aca0d4f3fefe3dd64da65814dda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed731a5a6fbedde73ed5063d62f3004e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#aed731a5a6fbedde73ed5063d62f3004e">OGR_STBL_LoadStyleTable</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszFilename)</td></tr>
<tr class="memdesc:aed731a5a6fbedde73ed5063d62f3004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a style table from a file.  <a href="ogr__api_8h.html#aed731a5a6fbedde73ed5063d62f3004e">More...</a><br /></td></tr>
<tr class="separator:aed731a5a6fbedde73ed5063d62f3004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ca305147b3b5a6c3f5fafaee7bc06a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a57ca305147b3b5a6c3f5fafaee7bc06a">OGR_STBL_Find</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable, const char *pszName)</td></tr>
<tr class="memdesc:a57ca305147b3b5a6c3f5fafaee7bc06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a style string by name.  <a href="ogr__api_8h.html#a57ca305147b3b5a6c3f5fafaee7bc06a">More...</a><br /></td></tr>
<tr class="separator:a57ca305147b3b5a6c3f5fafaee7bc06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ccd53d6d374d66d42266b3543509f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#a69ccd53d6d374d66d42266b3543509f7">OGR_STBL_ResetStyleStringReading</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:a69ccd53d6d374d66d42266b3543509f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the next style pointer to 0.  <a href="ogr__api_8h.html#a69ccd53d6d374d66d42266b3543509f7">More...</a><br /></td></tr>
<tr class="separator:a69ccd53d6d374d66d42266b3543509f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901a29f17b139108cc6390b9a075e89"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#ad901a29f17b139108cc6390b9a075e89">OGR_STBL_GetNextStyle</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:ad901a29f17b139108cc6390b9a075e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next style string from the table.  <a href="ogr__api_8h.html#ad901a29f17b139108cc6390b9a075e89">More...</a><br /></td></tr>
<tr class="separator:ad901a29f17b139108cc6390b9a075e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8214328c6866f0eb85bba376d94a05e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ogr__api_8h.html#af8214328c6866f0eb85bba376d94a05e">OGR_STBL_GetLastStyleName</a> (<a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> hStyleTable)</td></tr>
<tr class="memdesc:af8214328c6866f0eb85bba376d94a05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the style name of the last style string fetched with OGR_STBL_GetNextStyle.  <a href="ogr__api_8h.html#af8214328c6866f0eb85bba376d94a05e">More...</a><br /></td></tr>
<tr class="separator:af8214328c6866f0eb85bba376d94a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C API and defines for <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>, <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes.">OGRGeometry</a>, and <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> related classes. </p>
<p>See also: <a class="el" href="ogr__geometry_8h.html" title="Simple feature geometry classes.">ogr_geometry.h</a>, <a class="el" href="ogr__feature_8h.html" title="Simple feature classes.">ogr_feature.h</a>, <a class="el" href="ogrsf__frmts_8h.html" title="Classes related to registration of format support, and opening datasets.">ogrsf_frmts.h</a>, <a class="el" href="ogr__featurestyle_8h.html" title="Simple feature style classes.">ogr_featurestyle.h</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a261ecc4eb3468bae5f5deaed761f4221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261ecc4eb3468bae5f5deaed761f4221">&#9670;&nbsp;</a></span>OGR_FOR_EACH_FEATURE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGR_FOR_EACH_FEATURE_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hFeat, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hLayer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    {                                                                          \</div>
<div class="line">        OGRFeatureH hFeat = CPL_NULLPTR;                                       \</div>
<div class="line">        OGR_L_ResetReading(hLayer);                                            \</div>
<div class="line">        while (<span class="keyword">true</span>)                                                           \</div>
<div class="line">        {                                                                      \</div>
<div class="line">            if (hFeat)                                                         \</div>
<div class="line">                OGR_F_Destroy(hFeat);                                          \</div>
<div class="line">            hFeat = <a class="code" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">OGR_L_GetNextFeature</a>(hLayer);                              \</div>
<div class="line">            if (!hFeat)                                                        \</div>
<div class="line">                break;</div>
<div class="ttc" id="aogr__api_8h_html_a6708c067521ab7b7f9c4ec0ebe221b5b"><div class="ttname"><a href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b">OGR_L_GetNextFeature</a></div><div class="ttdeci">OGRFeatureH OGR_L_GetNextFeature(OGRLayerH)</div><div class="ttdoc">Fetch the next available feature from this layer.</div><div class="ttdef"><b>Definition:</b> ogrlayer.cpp:640</div></div>
</div><!-- fragment -->
<p>Conveniency macro to iterate over features of a layer. </p>
<p>Typical usage is: </p><pre>
<a class="el" href="ogr__api_8h.html#a261ecc4eb3468bae5f5deaed761f4221" title="Conveniency macro to iterate over features of a layer.">OGR_FOR_EACH_FEATURE_BEGIN(hFeat, hLayer)</a>
{
     // Do something, including continue, break;
     // Do not explicitly destroy the feature (unless you use return or goto
     // outside of the loop, in which case use OGR_F_Destroy(hFeat))
}
<a class="el" href="ogr__api_8h.html#a7c1c16c3af1f08084b3c261411beaf99" title="End of iterator.">OGR_FOR_EACH_FEATURE_END(hFeat)</a>
</pre><p>In C++, you might want to use instead range-based loop: </p><pre>
for( auto&amp;&amp; poFeature: poLayer )
{
}
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>variable name for OGRFeatureH. The variable will be declared inside the macro body. </td></tr>
    <tr><td class="paramname">hLayer</td><td>layer to iterate over.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.3 </dd></dl>

</div>
</div>
<a id="a7c1c16c3af1f08084b3c261411beaf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1c16c3af1f08084b3c261411beaf99">&#9670;&nbsp;</a></span>OGR_FOR_EACH_FEATURE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGR_FOR_EACH_FEATURE_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hFeat</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    }                                                                          \</div>
<div class="line">    OGR_F_Destroy(hFeat);                                                      \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>End of iterator. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3f3caffcd90d58c859cb51adef4c6c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3caffcd90d58c859cb51adef4c6c5d">&#9670;&nbsp;</a></span>OGR_AreTypeSubTypeCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_AreTypeSubTypeCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eSubType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return if type and subtype are compatible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eType</td><td>the field type. </td></tr>
    <tr><td class="paramname">eSubType</td><td>the field subtype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if type and subtype are compatible</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a5b54eadd367432591534133073cafcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b54eadd367432591534133073cafcb6">&#9670;&nbsp;</a></span>OGR_CodedFldDomain_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a> OGR_CodedFldDomain_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eFieldType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eFieldSubType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOGRCodedValue.html">OGRCodedValue</a> *&#160;</td>
          <td class="paramname"><em>enumeration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new coded field domain. </p>
<p>This is the same as the C++ method OGRCodedFieldDomain::OGRCodedFieldDomain() (except that the C function copies the enumeration, whereas the C++ method moves it)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Domain name. Should not be NULL. </td></tr>
    <tr><td class="paramname">pszDescription</td><td>Domain description (can be NULL) </td></tr>
    <tr><td class="paramname">eFieldType</td><td>Field type. Generally numeric. Potentially OFTDateTime </td></tr>
    <tr><td class="paramname">eFieldSubType</td><td>Field subtype. </td></tr>
    <tr><td class="paramname">enumeration</td><td>Enumeration as (code, value) pairs. Should not be NULL. The end of the enumeration is marked by a code set to NULL. The enumeration will be copied. Each code should appear only once, but it is the responsibility of the user to check it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new handle that should be freed with <a class="el" href="ogr__api_8h.html#a5b56883e79d620e4cf585e64f323787b" title="Destroy a field domain.">OGR_FldDomain_Destroy()</a>, or NULL in case of error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a971b4162d07e5640467f26dc4489c104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971b4162d07e5640467f26dc4489c104">&#9670;&nbsp;</a></span>OGR_CodedFldDomain_GetEnumeration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structOGRCodedValue.html">OGRCodedValue</a>* OGR_CodedFldDomain_GetEnumeration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the enumeration as (code, value) pairs. </p>
<p>The end of the enumeration is signaled by code == NULL</p>
<p>This is the same as the C++ method <a class="el" href="classOGRCodedFieldDomain.html#ad6cfd0fa5fd89e642d9d478d1b625753" title="Get the enumeration as (code, value) pairs.">OGRCodedFieldDomain::GetEnumeration()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (code, value) pairs, or nullptr in case of error. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="aa2104c8a76634f8841e3312295e717b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2104c8a76634f8841e3312295e717b2">&#9670;&nbsp;</a></span>OGR_Dr_CopyDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGR_Dr_CopyDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hSrcDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a new datasource by copying all the layers from the source datasource. </p>
<p>It is important to call <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#af30eed404fd7fd32f5a23761d61ca7d3" title="Create a copy of a dataset.">GDALCreateCopy()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver on which data source creation is based. </td></tr>
    <tr><td class="paramname">hSrcDS</td><td>source datasource </td></tr>
    <tr><td class="paramname">pszNewName</td><td>the name for the new data source. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> handle on success. </dd></dl>

</div>
</div>
<a id="a09a9c68495afce08505b8bbe36c1b96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a9c68495afce08505b8bbe36c1b96e">&#9670;&nbsp;</a></span>OGR_Dr_CreateDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGR_Dr_CreateDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts to create a new data source based on the passed driver. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<p>It is important to call <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> when the datasource is no longer used to ensure that all data has been properly flushed to disk.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a0862461cd6c073c1ec978a25d6c80325" title="Create a new dataset with this driver.">GDALCreate()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver on which data source creation is based. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name for the new data source. UTF-8 encoded. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> handle on success. </dd></dl>

</div>
</div>
<a id="a4d2314e22acd846e7e31ff5a5c5ec27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2314e22acd846e7e31ff5a5c5ec27f">&#9670;&nbsp;</a></span>OGR_Dr_DeleteDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_Dr_DeleteDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDataSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a datasource. </p>
<p>Delete (from the disk, in the database, ...) the named datasource. Normally it would be safest if the datasource was not open at the time.</p>
<p>Whether this is a supported operation on this driver case be tested using TestCapability() on ODrCDeleteDataSource.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a97939d588e2b350b9ec7a440f3e06a7c" title="Delete named dataset.">GDALDeleteDataset()</a> in GDAL 2</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver on which data source deletion is based.</td></tr>
    <tr><td class="paramname">pszDataSource</td><td>the name of the datasource to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, and OGRERR_UNSUPPORTED_OPERATION if this is not supported by this driver. </dd></dl>

</div>
</div>
<a id="afd11ea603491207a89c75b6b9480e091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd11ea603491207a89c75b6b9480e091">&#9670;&nbsp;</a></span>OGR_Dr_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_Dr_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch name of driver (file format). </p>
<p>This name should be relatively short (10-40 characters), and should reflect the underlying file format. For instance "ESRI Shapefile".</p>
<p>This function is the same as the C++ method OGRSFDriver::GetName().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>driver name. This is an internal string and should not be modified or freed. </dd></dl>

</div>
</div>
<a id="abd35488a77aae79835b8b753095cebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd35488a77aae79835b8b753095cebc7">&#9670;&nbsp;</a></span>OGR_Dr_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGR_Dr_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUpdate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to open file with this driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a9cb8585d0b3c16726b08e25bcc94274a" title="Open a raster or vector file as a GDALDataset.">GDALOpenEx()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver that is used to open file. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the file, or data source to try and open. </td></tr>
    <tr><td class="paramname">bUpdate</td><td>TRUE if update access is required, otherwise FALSE (the default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise a handle to a <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>. This <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> should be closed by deleting the object when it is no longer needed. </dd></dl>

</div>
</div>
<a id="a9010219bbc2e32627064ed860048d979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9010219bbc2e32627064ed860048d979">&#9670;&nbsp;</a></span>OGR_Dr_TestCapability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Dr_TestCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a>&#160;</td>
          <td class="paramname"><em>hDriver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<ul>
<li>
<p class="startli"><b>ODrCCreateDataSource</b>: True if this driver can support creating data sources.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODrCDeleteDataSource</b>: True if this driver supports deleting data sources.</p>
<p class="endli"></p>
</li>
</ul>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Use GDALGetMetadataItem(hDriver, GDAL_DCAP_CREATE) in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDriver</td><td>handle to the driver to test the capability against. </td></tr>
    <tr><td class="paramname">pszCap</td><td>the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if capability available otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a628d34530517b618696c97b73de31df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628d34530517b618696c97b73de31df7">&#9670;&nbsp;</a></span>OGR_DS_CopyLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_CopyLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hSrcLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate an existing layer. </p>
<p>This function creates a new layer, duplicate the field definitions of the source layer and then duplicate each features of the source layer. The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation. The source layer may come from another dataset.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#ad6bbc8895f27768a4ad644231b22cb24" title="Duplicate an existing layer.">GDALDatasetCopyLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source where to create the new layer </td></tr>
    <tr><td class="paramname">hSrcLayer</td><td>handle to the source layer. </td></tr>
    <tr><td class="paramname">pszNewName</td><td>the name of the layer to create. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the layer, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a424d383a37fbeaea58acaea11717f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d383a37fbeaea58acaea11717f320">&#9670;&nbsp;</a></span>OGR_DS_CreateLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_CreateLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSpatialRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts to create a new layer on the data source with the indicated name, coordinate system, geometry type. </p>
<p>The papszOptions argument can be used to control driver specific creation options. These options are normally documented in the format specific documentation.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000053">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a7f01d3d8584f29e4ef3c56b5af49d816" title="This function attempts to create a new layer on the dataset with the indicated name,...">GDALDatasetCreateLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>The dataset handle. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name for the new layer. This should ideally not match any existing layer on the datasource. </td></tr>
    <tr><td class="paramname">hSpatialRef</td><td>handle to the coordinate system to use for the new layer, or NULL if no coordinate system is available. The driver might only increase the reference counter of the object to take ownership, and not make a full copy, so do not use <a class="el" href="ogr__srs__api_8h.html#aa1485e7c17fb7edc15a0dfda63f77333" title="OGRSpatialReference destructor.">OSRDestroySpatialReference()</a>, but <a class="el" href="ogr__srs__api_8h.html#adb5e564701dab4e83b3d353745f4a054" title="Decrements the reference count by one, and destroy if zero.">OSRRelease()</a> instead when you are done with the object. </td></tr>
    <tr><td class="paramname">eType</td><td>the geometry type for the layer. Use wkbUnknown if there are no constraints on the types geometry to be written. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a StringList of name=value options. Options are driver specific, and driver information can be found at the following url: <a href="http://www.gdal.org/ogr_formats.html">http://www.gdal.org/ogr_formats.html</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL is returned on failure, or a new <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> handle on success.</dd></dl>
<p><b>Example:</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ogrsf__frmts_8h.html">ogrsf_frmts.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cpl__string_8h.html">cpl_string.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> *hLayer;</div>
<div class="line">        <span class="keywordtype">char</span>     **papszOptions;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>( <a class="code" href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability</a>( hDS, <a class="code" href="ogr__core_8h.html#aef6b1c2b9b7081b6c0c2c14f44f89014">ODsCCreateLayer</a> ) )</div>
<div class="line">        {</div>
<div class="line">            ...</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        papszOptions = <a class="code" href="cpl__string_8h.html#a8dbce00a6e7fa4710613e3e4c963dd5d">CSLSetNameValue</a>( papszOptions, <span class="stringliteral">&quot;DIM&quot;</span>, <span class="stringliteral">&quot;2&quot;</span> );</div>
<div class="line">        hLayer = <a class="code" href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer</a>( hDS, <span class="stringliteral">&quot;NewLayer&quot;</span>, NULL, <a class="code" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a>,</div>
<div class="line">                                     papszOptions );</div>
<div class="line">        <a class="code" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy</a>( papszOptions );</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span>( hLayer == NULL )</div>
<div class="line">        {</div>
<div class="line">            ...</div>
<div class="line">        }</div>
<div class="ttc" id="acpl__string_8h_html"><div class="ttname"><a href="cpl__string_8h.html">cpl_string.h</a></div><div class="ttdoc">Various convenience functions for working with strings and string lists.</div></div>
<div class="ttc" id="acpl__string_8h_html_a5a39b9c5896a273cc6f06c1d5be93238"><div class="ttname"><a href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238">CSLDestroy</a></div><div class="ttdeci">void CSLDestroy(char **papszStrList)</div><div class="ttdoc">Free string list.</div><div class="ttdef"><b>Definition:</b> cpl_string.cpp:200</div></div>
<div class="ttc" id="acpl__string_8h_html_a8dbce00a6e7fa4710613e3e4c963dd5d"><div class="ttname"><a href="cpl__string_8h.html#a8dbce00a6e7fa4710613e3e4c963dd5d">CSLSetNameValue</a></div><div class="ttdeci">char ** CSLSetNameValue(char **papszStrList, const char *pszName, const char *pszValue)</div><div class="ttdoc">Assign value to name in StringList.</div><div class="ttdef"><b>Definition:</b> cpl_string.cpp:1946</div></div>
<div class="ttc" id="aogr__api_8h_html_a424d383a37fbeaea58acaea11717f320"><div class="ttname"><a href="ogr__api_8h.html#a424d383a37fbeaea58acaea11717f320">OGR_DS_CreateLayer</a></div><div class="ttdeci">OGRLayerH OGR_DS_CreateLayer(OGRDataSourceH, const char *, OGRSpatialReferenceH, OGRwkbGeometryType, char **)</div><div class="ttdoc">This function attempts to create a new layer on the data source with the indicated name,...</div><div class="ttdef"><b>Definition:</b> ogrdatasource.cpp:120</div></div>
<div class="ttc" id="aogr__api_8h_html_a635095fa23dfea934f4bb2df38fb9a67"><div class="ttname"><a href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a></div><div class="ttdeci">void * OGRLayerH</div><div class="ttdoc">Opaque type for a layer (OGRLayer)</div><div class="ttdef"><b>Definition:</b> ogr_api.h:691</div></div>
<div class="ttc" id="aogr__api_8h_html_ad0fefab726442fa71ab5ef74fe8549a6"><div class="ttname"><a href="ogr__api_8h.html#ad0fefab726442fa71ab5ef74fe8549a6">OGR_DS_TestCapability</a></div><div class="ttdeci">int OGR_DS_TestCapability(OGRDataSourceH, const char *)</div><div class="ttdoc">Test if capability is available.</div><div class="ttdef"><b>Definition:</b> ogrdatasource.cpp:250</div></div>
<div class="ttc" id="aogr__core_8h_html_a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f"><div class="ttname"><a href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12aa3645f782f9b9f7632d7e7cdd0451d58f">wkbUnknown</a></div><div class="ttdeci">@ wkbUnknown</div><div class="ttdoc">unknown type, non-standard</div><div class="ttdef"><b>Definition:</b> ogr_core.h:417</div></div>
<div class="ttc" id="aogr__core_8h_html_aef6b1c2b9b7081b6c0c2c14f44f89014"><div class="ttname"><a href="ogr__core_8h.html#aef6b1c2b9b7081b6c0c2c14f44f89014">ODsCCreateLayer</a></div><div class="ttdeci">#define ODsCCreateLayer</div><div class="ttdoc">Dataset capability for layer creation.</div><div class="ttdef"><b>Definition:</b> ogr_core.h:1058</div></div>
<div class="ttc" id="aogrsf__frmts_8h_html"><div class="ttname"><a href="ogrsf__frmts_8h.html">ogrsf_frmts.h</a></div><div class="ttdoc">Classes related to registration of format support, and opening datasets.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a85827a79cd2ddb5a55126e785bee427d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85827a79cd2ddb5a55126e785bee427d">&#9670;&nbsp;</a></span>OGR_DS_DeleteLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_DS_DeleteLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the indicated layer from the datasource. </p>
<p>If this method is supported the ODsCDeleteLayer capability will test TRUE on the <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a6c71ac6976dbf150a5131f509669e56e" title="Delete the indicated layer from the datasource.">GDALDatasetDeleteLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the datasource </td></tr>
    <tr><td class="paramname">iLayer</td><td>the index of the layer to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or OGRERR_UNSUPPORTED_OPERATION if deleting layers is not supported for this datasource. </dd></dl>

</div>
</div>
<a id="a4823e7c3513cd9d57254364de9a1d021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4823e7c3513cd9d57254364de9a1d021">&#9670;&nbsp;</a></span>OGR_DS_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_DS_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes opened datasource and releases allocated resources. </p>
<p>This method is the same as the C++ method OGRDataSource::DestroyDataSource().</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a7c728fbbef87fe4929e6dd418f4035fa" title="Close GDAL dataset.">GDALClose()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to allocated datasource object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9892ecb0bf61add295bd9decdb13797a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9892ecb0bf61add295bd9decdb13797a">&#9670;&nbsp;</a></span>OGR_DS_ExecuteSQL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_ExecuteSQL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStatement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hSpatialFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDialect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute an SQL statement against the data store. </p>
<p>The result of an SQL query is either NULL for statements that are in error, or that have no results set, or an <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> handle representing a results set from the query. Note that this <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> is in addition to the layers in the data store and must be destroyed with <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181" title="Release results of OGR_DS_ExecuteSQL().">OGR_DS_ReleaseResultSet()</a> before the data source is closed (destroyed).</p>
<p>For more information on the SQL dialect supported internally by OGR review the <a href="https://gdal.org/user/ogr_sql_dialect.html">OGR SQL</a> document. Some drivers (i.e. Oracle and PostGIS) pass the SQL directly through to the underlying RDBMS.</p>
<p>The <a href="https://gdal.org/user/sql_sqlite_dialect.html">SQLITE dialect</a> can also be used.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aac9f2b65105d825901bc6cbe07a4b298" title="Execute an SQL statement against the data store.">GDALDatasetExecuteSQL()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source on which the SQL query is executed. </td></tr>
    <tr><td class="paramname">pszStatement</td><td>the SQL statement to execute. </td></tr>
    <tr><td class="paramname">hSpatialFilter</td><td>handle to a geometry which represents a spatial filter. Can be NULL. </td></tr>
    <tr><td class="paramname">pszDialect</td><td>allows control of the statement dialect. If set to NULL, the OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine, unless OGRSQL is explicitly passed as the dialect. The SQLITE dialect can also be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> containing the results of the query. Deallocate with <a class="el" href="ogr__api_8h.html#afc7b521a05c1207e298a2b9dbf4a1181" title="Release results of OGR_DS_ExecuteSQL().">OGR_DS_ReleaseResultSet()</a>. </dd></dl>

</div>
</div>
<a id="a5def9c0aa6f6f60ab96369203330e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5def9c0aa6f6f60ab96369203330e326">&#9670;&nbsp;</a></span>OGR_DS_GetDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> OGR_DS_GetDriver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the driver that the dataset was opened with. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000055">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a115e56894fda0a51ad99820b1bc38391" title="Fetch the driver to which this dataset relates.">GDALGetDatasetDriver()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the datasource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if driver info is not available, or pointer to a driver owned by the OGRSFDriverManager. </dd></dl>

</div>
</div>
<a id="a03998029f904d1c3b12de40114e7503e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03998029f904d1c3b12de40114e7503e">&#9670;&nbsp;</a></span>OGR_DS_GetLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_GetLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a layer by index. </p>
<p>The returned layer remains owned by the <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> and should not be deleted by the application.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a4c42c52e24e02fead69a3189db5585ab" title="Fetch a layer by index.">GDALDatasetGetLayer()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source from which to get the layer. </td></tr>
    <tr><td class="paramname">iLayer</td><td>a layer number between 0 and <a class="el" href="ogr__api_8h.html#ac6da541cb655ab631df729e71da2e762" title="Get the number of layers in this data source.">OGR_DS_GetLayerCount()</a>-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the layer, or NULL if iLayer is out of range or an error occurs. </dd></dl>

</div>
</div>
<a id="a74af4912b67bf2a7b6e3230711a40d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74af4912b67bf2a7b6e3230711a40d0e">&#9670;&nbsp;</a></span>OGR_DS_GetLayerByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a> OGR_DS_GetLayerByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszLayerName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a layer by name. </p>
<p>The returned layer remains owned by the <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> and should not be deleted by the application.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a06e1dfa7103356cbb11929a36c2ec139" title="Fetch a layer by name.">GDALDatasetGetLayerByName()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source from which to get the layer. </td></tr>
    <tr><td class="paramname">pszLayerName</td><td>Layer the layer name of the layer to fetch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the layer, or NULL if the layer is not found or an error occurs. </dd></dl>

</div>
</div>
<a id="ac6da541cb655ab631df729e71da2e762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da541cb655ab631df729e71da2e762">&#9670;&nbsp;</a></span>OGR_DS_GetLayerCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_DS_GetLayerCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of layers in this data source. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a8c9297e5115d559b27267b14122043ee" title="Get the number of layers in this dataset.">GDALDatasetGetLayerCount()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source from which to get the number of layers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>layer count. </dd></dl>

</div>
</div>
<a id="aea8cc826474b55371b1b4e24a24ba1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8cc826474b55371b1b4e24a24ba1db">&#9670;&nbsp;</a></span>OGR_DS_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_DS_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the data source. </p>
<p>This string should be sufficient to open the data source if passed to the same <a class="el" href="classOGRSFDriver.html" title="LEGACY class.">OGRSFDriver</a> that this data source was opened with, but it need not be exactly the same string that was used to open the data source. Normally this is a filename.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#acf7272f513f436a95572116ca9fb8885" title="Fetch object description.">GDALGetDescription()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an internal name string which should not be modified or freed by the caller. </dd></dl>

</div>
</div>
<a id="afc7b521a05c1207e298a2b9dbf4a1181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7b521a05c1207e298a2b9dbf4a1181">&#9670;&nbsp;</a></span>OGR_DS_ReleaseResultSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_DS_ReleaseResultSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release results of <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a>. </p>
<p>This function should only be used to deallocate OGRLayers resulting from an <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a> call on the same <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a>. Failure to deallocate a results set before destroying the <a class="el" href="classOGRDataSource.html" title="LEGACY class.">OGRDataSource</a> may cause errors.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#ac2fa4282c61ee085edefdd485efad952" title="Release results of ExecuteSQL().">GDALDatasetReleaseResultSet()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>a handle to the data source on which was executed an SQL query. </td></tr>
    <tr><td class="paramname">hLayer</td><td>handle to the result of a previous <a class="el" href="ogr__api_8h.html#a9892ecb0bf61add295bd9decdb13797a" title="Execute an SQL statement against the data store.">OGR_DS_ExecuteSQL()</a> call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a139ab189c06d9f5f26e21b134928f882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ab189c06d9f5f26e21b134928f882">&#9670;&nbsp;</a></span>OGR_DS_SyncToDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_DS_SyncToDisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>See <a class="el" href="classGDALDataset.html#a89ec3e0444eb32e18c4feb993b19bb25" title="Flush all write cached data to disk.">GDALDataset::FlushCache()</a> </p>

</div>
</div>
<a id="ad0fefab726442fa71ab5ef74fe8549a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fefab726442fa71ab5ef74fe8549a6">&#9670;&nbsp;</a></span>OGR_DS_TestCapability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_DS_TestCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCapability</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if capability is available. </p>
<p>One of the following data source capability names can be passed into this function, and a TRUE or FALSE value will be returned indicating whether or not the capability is available for this object.</p>
<ul>
<li>
<b>ODsCCreateLayer</b>: True if this datasource can create new layers. </li>
<li>
<p class="startli"><b>ODsCDeleteLayer</b>: True if this datasource can delete existing layers.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODsCCreateGeomFieldAfterCreateLayer</b>: True if the layers of this datasource support CreateGeomField() just after layer creation.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>ODsCCurveGeometries</b>: True if this datasource supports writing curve geometries. (GDAL 2.0). In that case, OLCCurveGeometries must also be declared in layers of that dataset.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
</ul>
<p>The #define macro forms of the capability names should be used in preference to the strings themselves to avoid misspelling.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a8dc635a536f123e1b03004dc74b4da86" title="Test if capability is available.">GDALDatasetTestCapability()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source against which to test the capability. </td></tr>
    <tr><td class="paramname">pszCapability</td><td>the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if capability available otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a90c0adfd518b71571d9ce8d976fab320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c0adfd518b71571d9ce8d976fab320">&#9670;&nbsp;</a></span>OGR_F_Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_F_Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate feature. </p>
<p>The newly created feature is owned by the caller, and will have its own reference to the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a58eab4eb4676ba5b4f5d089827ec1247" title="Duplicate feature.">OGRFeature::Clone()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the new feature, exactly matching this feature. </dd></dl>

</div>
</div>
<a id="a0d820fd7da6a079048c0d21e26fc9e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d820fd7da6a079048c0d21e26fc9e47">&#9670;&nbsp;</a></span>OGR_F_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_F_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Feature factory. </p>
<p>Note that the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> will increment the reference count of its defining <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. Destruction of the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> before destruction of all OGRFeatures that depend on it is likely to result in a crash.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae6559a9f3c26274d1253e5d043b2e852" title="Constructor.">OGRFeature::OGRFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature class (layer) definition to which the feature will adhere.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the new feature object with null fields and no geometry, or, starting with GDAL 2.1, NULL in case out of memory situation. </dd></dl>

</div>
</div>
<a id="a16fb8126aa932f4b4acdaca5ea99bbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fb8126aa932f4b4acdaca5ea99bbbb">&#9670;&nbsp;</a></span>OGR_F_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy feature. </p>
<p>The feature is deleted, but within the context of the GDAL/OGR heap. This is necessary when higher level applications use GDAL/OGR from a DLL and they want to delete a feature created within the DLL. If the delete is done in the calling application the memory will be freed onto the application heap which is inappropriate.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5d2602d11f21567119da0ca6b6c5ad45" title="Destroy feature.">OGRFeature::DestroyFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae38d330f942798fcbaaf27e5807fb567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38d330f942798fcbaaf27e5807fb567">&#9670;&nbsp;</a></span>OGR_F_DumpReadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_DumpReadable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fpOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump this feature in a human readable form. </p>
<p>This dumps the attributes, and geometry; however, it doesn't definition information (other than field types and names), nor does it report the geometry spatial reference system.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#af48ba00f4748f80fcd7325a7ac75523e" title="Dump this feature in a human readable form.">OGRFeature::DumpReadable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to dump. </td></tr>
    <tr><td class="paramname">fpOut</td><td>the stream to write to, such as strout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace01c50d673661f76d1c8f2a2424577d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace01c50d673661f76d1c8f2a2424577d">&#9670;&nbsp;</a></span>OGR_F_DumpReadableAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_F_DumpReadableAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump this feature in a human readable form. </p>
<p>This dumps the attributes, and geometry; however, it doesn't include definition information (other than field types and names), nor does it report the geometry spatial reference system.</p>
<p>A few options can be defined to change the default dump : </p><ul>
<li>
DISPLAY_FIELDS=NO : to hide the dump of the attributes </li>
<li>
DISPLAY_STYLE=NO : to hide the dump of the style string </li>
<li>
DISPLAY_GEOMETRY=NO : to hide the dump of the geometry </li>
<li>
DISPLAY_GEOMETRY=SUMMARY : to get only a summary of the geometry </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to dump. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the feature representation (to be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a8b6a502ec0b70f3de50e7184a087a264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6a502ec0b70f3de50e7184a087a264">&#9670;&nbsp;</a></span>OGR_F_Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_Equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hOtherFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if two features are the same. </p>
<p>Two features are considered equal if the share them (handle equality) same <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>, have the same field values, and the same geometry (as tested by OGR_G_Equal()) as well as the same feature id.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a52b96b85923e2128f17bc049fbd548a2" title="Test if two features are the same.">OGRFeature::Equal()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to one of the feature. </td></tr>
    <tr><td class="paramname">hOtherFeat</td><td>handle to the other feature to test this one against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are equal, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ac705f1d608d5e33d03851a7639fdfa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac705f1d608d5e33d03851a7639fdfa1f">&#9670;&nbsp;</a></span>OGR_F_FillUnsetWithDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_FillUnsetWithDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNotNullableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill unset fields with default values that might be defined. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a2328a84586eda70f44128bd58a89efc4" title="Fill unset fields with default values that might be defined.">OGRFeature::FillUnsetWithDefault()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
    <tr><td class="paramname">bNotNullableOnly</td><td>if we should fill only unset fields with a not-null constraint. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>unused currently. Must be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a123dfa431bf655aafd2dbd42247dd7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123dfa431bf655aafd2dbd42247dd7be">&#9670;&nbsp;</a></span>OGR_F_GetDefnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> OGR_F_GetDefnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a01ef8d59265a7ab7a575387a8269bf92" title="Fetch feature definition.">OGRFeature::GetDefnRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the feature definition from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the feature definition object on which feature depends. </dd></dl>

</div>
</div>
<a id="afc99defd1fb1f8f71ff89c38982f2103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc99defd1fb1f8f71ff89c38982f2103">&#9670;&nbsp;</a></span>OGR_F_GetFID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGR_F_GetFID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get feature identifier. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae7254201e4d96e8429c2509194740d58" title="Get feature identifier.">OGRFeature::GetFID()</a>. Note: since GDAL 2.0, this method returns a GIntBig (previously a long)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature from which to get the feature identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>feature id or OGRNullFID if none has been assigned. </dd></dl>

</div>
</div>
<a id="a72727f2f59d1defa01cedfb884df1a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72727f2f59d1defa01cedfb884df1a09">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ae7fbc84d3d1f7a40973be07382e28401">GByte</a>* OGR_F_GetFieldAsBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as binary. </p>
<p>This method only works for OFTBinary and OFTString fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a2bda1256e28dbb14d37e5b6920fbc8d9" title="Fetch field value as binary data.">OGRFeature::GetFieldAsBinary()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnBytes</td><td>location to place count of bytes returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

</div>
</div>
<a id="a47ca681bb6099eb8c18004d1f7112d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ca681bb6099eb8c18004d1f7112d95">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsDateTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a54097fad3054b57cfc7b6b0b0dd805e2" title="Fetch field value as date and time.">OGRFeature::GetFieldAsDateTime()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">pnMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">pnDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">pnHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">pnMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">pnSecond</td><td>(0-59) </td></tr>
    <tr><td class="paramname">pnTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Use <a class="el" href="ogr__api_8h.html#a748995fa28574b25f6b723013a405a8f" title="Fetch field value as date and time.">OGR_F_GetFieldAsDateTimeEx()</a> for second with millisecond accuracy. </dd></dl>

</div>
</div>
<a id="a748995fa28574b25f6b723013a405a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748995fa28574b25f6b723013a405a8f">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDateTimeEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsDateTimeEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as date and time. </p>
<p>Currently this method only works for OFTDate, OFTTime and OFTDateTime fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a54097fad3054b57cfc7b6b0b0dd805e2" title="Fetch field value as date and time.">OGRFeature::GetFieldAsDateTime()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">pnMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">pnDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">pnHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">pnMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">pfSecond</td><td>(0-59 with millisecond accuracy) </td></tr>
    <tr><td class="paramname">pnTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success or FALSE on failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a62252a0d4538c695d41956a96cdc6978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62252a0d4538c695d41956a96cdc6978">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_F_GetFieldAsDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a double. </p>
<p>OFTString features will be translated using <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a>. OFTInteger fields will be cast to double. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#af1e473ed4496676610640a3fbe15d8e3" title="Fetch field value as a double.">OGRFeature::GetFieldAsDouble()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. </dd></dl>

</div>
</div>
<a id="a4a27f74a38506ac492ec8b6e00eb58c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a27f74a38506ac492ec8b6e00eb58c9">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsDoubleList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* OGR_F_GetFieldAsDoubleList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of doubles. </p>
<p>Currently this function only works for OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a206f481869ded42b685a163cc97e04cd" title="Fetch field value as a list of doubles.">OGRFeature::GetFieldAsDoubleList()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnCount</td><td>an integer to put the list count (number of doubles) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>

</div>
</div>
<a id="acfb4d2c0001af379e396021ecbdaf275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb4d2c0001af379e396021ecbdaf275">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldAsInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as integer. </p>
<p>OFTString features will be translated using atoi(). OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#aa0fa233c76792a07bf2e72c2846502f1" title="Fetch field value as integer.">OGRFeature::GetFieldAsInteger()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. </dd></dl>

</div>
</div>
<a id="a0e190099fd6ee40e206bf4bf74d3b784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e190099fd6ee40e206bf4bf74d3b784">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsInteger64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGR_F_GetFieldAsInteger64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as integer 64 bit. </p>
<p>OFTInteger are promoted to 64 bit. OFTString features will be translated using <a class="el" href="cpl__conv_8h.html#aa35579a348f417a35965d6be69cde090" title="Convert a string to a 64 bit signed integer.">CPLAtoGIntBig()</a>. OFTReal fields will be cast to integer. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7178e6fe945237da0595a934aba9e2ff" title="Fetch field value as integer 64 bit.">OGRFeature::GetFieldAsInteger64()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a9df79763bd50aeef2581454bcab51ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df79763bd50aeef2581454bcab51ce6">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsInteger64List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>* OGR_F_GetFieldAsInteger64List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of 64 bit integers. </p>
<p>Currently this function only works for OFTInteger64List fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#afddc9cb3f91db6ba82b105a20b57cb6c" title="Fetch field value as a list of 64 bit integers.">OGRFeature::GetFieldAsInteger64List()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnCount</td><td>an integer to put the list count (number of integers) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac671852e05692c584b493b2acbd6b8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac671852e05692c584b493b2acbd6b8ce">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsIntegerList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int* OGR_F_GetFieldAsIntegerList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of integers. </p>
<p>Currently this function only works for OFTIntegerList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8f3817334dc5a0987d2a384708efc9af" title="Fetch field value as a list of integers.">OGRFeature::GetFieldAsIntegerList()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pnCount</td><td>an integer to put the list count (number of integers) into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. If *pnCount is zero on return the returned pointer may be NULL or non-NULL. </dd></dl>

</div>
</div>
<a id="a1800a44ab7cce67ccec3c61b947548c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1800a44ab7cce67ccec3c61b947548c4">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsISO8601DateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetFieldAsISO8601DateTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch OFTDateTime field value as a ISO8601 representation. </p>
<p>Return a string like "YYYY-MM6DDTHH:MM:SS(.sss)?(Z|([+|-]HH:MM))?" Milliseconds are omitted if equal to zero. Other field types, or errors will result in a return of an empty string.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a3dcf635dbf3ac8cb4ae984a7fdc7d4ad" title="Fetch OFTDateTime field value as a ISO8601 representation.">OGRFeature::GetFieldAsISO8601DateTime()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of strings, or NULL. No options are defined currently.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a42acfd1f4b49dddc1c308462ae800c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42acfd1f4b49dddc1c308462ae800c26">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetFieldAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a string. </p>
<p>OFTReal and OFTInteger fields will be translated to string using sprintf(), but not necessarily using the established formatting rules. Other field types, or errors will result in a return value of zero.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a92ecdc127eeb3fe7e2ead80f1d17d4b4" title="Fetch field value as a string.">OGRFeature::GetFieldAsString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This string is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

</div>
</div>
<a id="a3e55ba4a06d4c4a392206518b390ac38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e55ba4a06d4c4a392206518b390ac38">&#9670;&nbsp;</a></span>OGR_F_GetFieldAsStringList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** OGR_F_GetFieldAsStringList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field value as a list of strings. </p>
<p>Currently this method only works for OFTStringList fields.</p>
<p>The returned list is terminated by a NULL pointer. The number of elements can also be calculated using <a class="el" href="cpl__string_8h.html#a827f21b7a67d16059c131d0946482bb1" title="Return number of items in a string list.">CSLCount()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a317004e2ab87ff097bc76a7a7619e4b4" title="Fetch field value as a list of strings.">OGRFeature::GetFieldAsStringList()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field value. This list is internal, and should not be modified, or freed. Its lifetime may be very brief. </dd></dl>

</div>
</div>
<a id="af6c1440956ee56c0c160394bccf96990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c1440956ee56c0c160394bccf96990">&#9670;&nbsp;</a></span>OGR_F_GetFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of fields on this feature This will always be the same as the field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5f2125ed7986f684e835c3d44feda6fe" title="Fetch number of fields on this feature.">OGRFeature::GetFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of fields. </dd></dl>

</div>
</div>
<a id="a6f8fc7fd6ecca789ad90db6d28391623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8fc7fd6ecca789ad90db6d28391623">&#9670;&nbsp;</a></span>OGR_F_GetFieldDefnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> OGR_F_GetFieldDefnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch definition for this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a545a4c983e1fa557e64333fe63656637" title="Fetch definition for this field.">OGRFeature::GetFieldDefnRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td class="paramname">i</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the field definition (from the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>). This is an internal reference, and should not be deleted or modified. </dd></dl>

</div>
</div>
<a id="a9a8a6b93ab97204b94f5c2b358f8f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a6b93ab97204b94f5c2b358f8f98e">&#9670;&nbsp;</a></span>OGR_F_GetFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the field index given field name. </p>
<p>This is a cover for the <a class="el" href="classOGRFeatureDefn.html#adf94fefd88e82172e5279f5188b3873b" title="Find field by name.">OGRFeatureDefn::GetFieldIndex()</a> method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a989153f429715d02e4d5c45d0e43f303" title="Fetch the field index given field name.">OGRFeature::GetFieldIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the field to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field index, or -1 if no matching field is found. </dd></dl>

</div>
</div>
<a id="a1bf9596756aeacec4da502383c378f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf9596756aeacec4da502383c378f5c">&#9670;&nbsp;</a></span>OGR_F_GetGeometryRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_GetGeometryRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a handle to feature geometry. </p>
<p>This function is essentially the same as the C++ method <a class="el" href="classOGRFeature.html#acc966ce8c10ae3ddf9f14c2736fdce9a" title="Fetch pointer to feature geometry.">OGRFeature::GetGeometryRef()</a> (the only difference is that this C function honours <a class="el" href="ogr__api_8h.html#af7f6cfab316f5f22962bcd85216c4684" title="Get flag to enable/disable returning non-linear geometries in the C API.">OGRGetNonLinearGeometriesEnabledFlag()</a>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get geometry from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to internal feature geometry. This object should not be modified. </dd></dl>

</div>
</div>
<a id="a7975076d4ab247189487c0fd50d8365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7975076d4ab247189487c0fd50d8365c">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetGeomFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of geometry fields on this feature This will always be the same as the geometry field count for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a372e4ace921fa830a342181328a5a4cf" title="Fetch number of geometry fields on this feature.">OGRFeature::GetGeomFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the geometry fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of geometry fields.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a11c3d59a3854dad80c4257e788c5d881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c3d59a3854dad80c4257e788c5d881">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldDefnRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> OGR_F_GetGeomFieldDefnRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch definition for this geometry field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ab0416401dc7d6a7634c2a24ca1f7d255" title="Fetch definition for this geometry field.">OGRFeature::GetGeomFieldDefnRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is found. </td></tr>
    <tr><td class="paramname">i</td><td>the field to fetch, from 0 to GetGeomFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the field definition (from the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>). This is an internal reference, and should not be deleted or modified.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a546acd0aad47128b1f178a8d01765e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546acd0aad47128b1f178a8d01765e63">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_GetGeomFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the geometry field index given geometry field name. </p>
<p>This is a cover for the <a class="el" href="classOGRFeatureDefn.html#af033ae277fade415ff13ed8b5643e4be" title="Find geometry field by name.">OGRFeatureDefn::GetGeomFieldIndex()</a> method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#aae3ed6071596aea439843f1e4110ad40" title="Fetch the geometry field index given geometry field name.">OGRFeature::GetGeomFieldIndex()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the geometry field is found. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the geometry field to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry field index, or -1 if no matching geometry field is found.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a37aa8b53b1fc8816c5b7bcbbcb6a46ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37aa8b53b1fc8816c5b7bcbbcb6a46ca">&#9670;&nbsp;</a></span>OGR_F_GetGeomFieldRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_GetGeomFieldRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a handle to feature geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae54d999d4649730d5c7b37de731e4f69" title="Fetch pointer to feature geometry.">OGRFeature::GetGeomFieldRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get geometry from. </td></tr>
    <tr><td class="paramname">iField</td><td>geometry field to get. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to internal feature geometry. This object should not be modified.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a3737dec6492741cd11c1767e04edec1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3737dec6492741cd11c1767e04edec1f">&#9670;&nbsp;</a></span>OGR_F_GetNativeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetNativeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the native data for the feature. </p>
<p>The native data is the representation in a "natural" form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by <a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6" title="Returns the native media type for the feature.">OGR_F_GetNativeMediaType()</a>.</p>
<p>Note that most drivers do not support storing the native data in the feature object, and if they do, generally the NATIVE_DATA open option must be passed at dataset opening.</p>
<p>The "native data" does not imply it is something more performant or powerful than what can be obtained with the rest of the API, but it may be useful in round-tripping scenarios where some characteristics of the underlying format are not captured otherwise by the OGR abstraction.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8f91a40806d4207efb689b9c3cdf8e53" title="Returns the native data for the feature.">OGRFeature::GetNativeData()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the native data, or NULL if there is none. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="abcfe5e7897623a97a2bdc0ec32323fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfe5e7897623a97a2bdc0ec32323fa6">&#9670;&nbsp;</a></span>OGR_F_GetNativeMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetNativeMediaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the native media type for the feature. </p>
<p>The native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see <a href="https://en.wikipedia.org/wiki/Media_type">https://en.wikipedia.org/wiki/Media_type</a>), e.g. "application/vnd.geo+json" for JSon.</p>
<p>This function is the same as the C function <a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6" title="Returns the native media type for the feature.">OGR_F_GetNativeMediaType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string with the native media type, or NULL if there is none. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="af7043e9dfadbdeca8059ace336875d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7043e9dfadbdeca8059ace336875d4c">&#9670;&nbsp;</a></span>OGR_F_GetRawFieldRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionOGRField.html">OGRField</a>* OGR_F_GetRawFieldRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a handle to the internal field value given the index. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae7f676d5a8e1f62d80b438c13b159ee0" title="Fetch a pointer to the internal field value given the index.">OGRFeature::GetRawFieldRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which field is found. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the returned handle is to an internal data structure, and should not be freed, or modified. </dd></dl>

</div>
</div>
<a id="a10fb5f53d99ccf46280e4c38afe4a5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fb5f53d99ccf46280e4c38afe4a5a5">&#9670;&nbsp;</a></span>OGR_F_GetStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_F_GetStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch style string for this feature. </p>
<p>Set the OGR Feature Style Specification for details on the format of this string, and <a class="el" href="ogr__featurestyle_8h.html" title="Simple feature style classes.">ogr_featurestyle.h</a> for services available to parse it.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a6f0eba9faff40c251784217584ac97a4" title="Fetch style string for this feature.">OGRFeature::GetStyleString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to get the style from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a representation in string format, or NULL if there isn't one. </dd></dl>

</div>
</div>
<a id="aa4d08c0ac3b9624955e682a9a2afe2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d08c0ac3b9624955e682a9a2afe2b1">&#9670;&nbsp;</a></span>OGR_F_IsFieldNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field is null. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a655ee311e45188dcb5143ce3e408884e" title="Test if a field is null.">OGRFeature::IsFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is null, otherwise false.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="abb018a9030ed76353ae26082deaaef11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb018a9030ed76353ae26082deaaef11">&#9670;&nbsp;</a></span>OGR_F_IsFieldSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field has ever been assigned a value or not. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a905bb73fe5e6df57f1be5a8b77489b74" title="Test if a field has ever been assigned a value or not.">OGRFeature::IsFieldSet()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field has been set, otherwise false. </dd></dl>

</div>
</div>
<a id="adf414eb3a145bcd7203fca727f7a2ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf414eb3a145bcd7203fca727f7a2ead">&#9670;&nbsp;</a></span>OGR_F_IsFieldSetAndNotNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_IsFieldSetAndNotNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if a field is set and not null. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a55cee63d6370dc1123dfca2b8333b1ac" title="Test if a field is set and not null.">OGRFeature::IsFieldSetAndNotNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is set and not null, otherwise false.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="adf24e93da4c03360d1d2e01664596e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf24e93da4c03360d1d2e01664596e29">&#9670;&nbsp;</a></span>OGR_F_SetFID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetFID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the feature identifier. </p>
<p>For specific types of features this operation may fail on illegal features ids. Generally it always succeeds. Feature ids should be greater than or equal to zero, with the exception of OGRNullFID (-1) indicating that the feature id is unknown.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ad159156f6e544343f3f24081208a4b42" title="Set the feature identifier.">OGRFeature::SetFID()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set the feature id to. </td></tr>
    <tr><td class="paramname">nFID</td><td>the new feature identifier value to assign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success OGRERR_NONE, or on failure some other value. </dd></dl>

</div>
</div>
<a id="a348b1423e9ae34290f2e32f3bdf8154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348b1423e9ae34290f2e32f3bdf8154b">&#9670;&nbsp;</a></span>OGR_F_SetFieldBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to binary data. </p>
<p>This function currently on has an effect of OFTBinary fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes in pabyData array. </td></tr>
    <tr><td class="paramname">pabyData</td><td>the data to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a627970180a20e2a4b1c7ae694923fd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627970180a20e2a4b1c7ae694923fd73">&#9670;&nbsp;</a></span>OGR_F_SetFieldDateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDateTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">nMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">nDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">nHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">nMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">nSecond</td><td>(0-59) </td></tr>
    <tr><td class="paramname">nTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Use <a class="el" href="ogr__api_8h.html#a71e1bc23b8a31553550775a212075da3" title="Set field to datetime.">OGR_F_SetFieldDateTimeEx()</a> for second with millisecond accuracy. </dd></dl>

</div>
</div>
<a id="a71e1bc23b8a31553550775a212075da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e1bc23b8a31553550775a212075da3">&#9670;&nbsp;</a></span>OGR_F_SetFieldDateTimeEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDateTimeEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMonth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nHour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMinute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fSecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to datetime. </p>
<p>This method currently only has an effect for OFTDate, OFTTime and OFTDateTime fields.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nYear</td><td>(including century) </td></tr>
    <tr><td class="paramname">nMonth</td><td>(1-12) </td></tr>
    <tr><td class="paramname">nDay</td><td>(1-31) </td></tr>
    <tr><td class="paramname">nHour</td><td>(0-23) </td></tr>
    <tr><td class="paramname">nMinute</td><td>(0-59) </td></tr>
    <tr><td class="paramname">fSecond</td><td>(0-59, with millisecond accuracy) </td></tr>
    <tr><td class="paramname">nTZFlag</td><td>(0=unknown, 1=localtime, 100=GMT, see data model for details)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a9d28aa13b1b7c88f07066c36286d13b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d28aa13b1b7c88f07066c36286d13b9">&#9670;&nbsp;</a></span>OGR_F_SetFieldDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDouble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to double value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">dfValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83a56d01128bf247016c139faed157be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a56d01128bf247016c139faed157be">&#9670;&nbsp;</a></span>OGR_F_SetFieldDoubleList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldDoubleList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>padfValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of doubles value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List, OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nCount</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td class="paramname">padfValues</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad902fb7c7fe459aacf0b2c26b8e6d1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad902fb7c7fe459aacf0b2c26b8e6d1ee">&#9670;&nbsp;</a></span>OGR_F_SetFieldInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to integer value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c95abf476d0ad250eb7499627f0e3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c95abf476d0ad250eb7499627f0e3b1">&#9670;&nbsp;</a></span>OGR_F_SetFieldInteger64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to 64 bit integer value. </p>
<p>OFTInteger, OFTInteger64 and OFTReal fields will be set directly. OFTString fields will be assigned a string representation of the value, but not necessarily taking into account formatting constraints on this field. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="af7538949a9e8b85920381809fadbe897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7538949a9e8b85920381809fadbe897">&#9670;&nbsp;</a></span>OGR_F_SetFieldInteger64List()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldInteger64List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> *&#160;</td>
          <td class="paramname"><em>panValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of 64 bit integers value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List and OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nCount</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td class="paramname">panValues</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a984c8595693b4e94f3be5f796e6f7c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c8595693b4e94f3be5f796e6f7c92">&#9670;&nbsp;</a></span>OGR_F_SetFieldIntegerList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldIntegerList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of integers value. </p>
<p>This function currently on has an effect of OFTIntegerList, OFTInteger64List and OFTRealList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">nCount</td><td>the number of values in the list being assigned. </td></tr>
    <tr><td class="paramname">panValues</td><td>the values to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a090a6a8d699d4eed977ce9fcf028137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090a6a8d699d4eed977ce9fcf028137a">&#9670;&nbsp;</a></span>OGR_F_SetFieldNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a field, marking it as null. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a21e81c0995c1f2a8e5c9f6c76fdfb2f4" title="Clear a field, marking it as null.">OGRFeature::SetFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set to null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="a5422da1e04dae4fa2248155575a54f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5422da1e04dae4fa2248155575a54f4b">&#9670;&nbsp;</a></span>OGR_F_SetFieldRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>psValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field. </p>
<p>The passed value <a class="el" href="unionOGRField.html" title="OGRFeature field attribute value union.">OGRField</a> must be of exactly the same type as the target field, or an application crash may occur. The passed value is copied, and will not be affected. It remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">psValue</td><td>handle on the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1a3e8b4a08f9558807389bcdde85bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a3e8b4a08f9558807389bcdde85bab">&#9670;&nbsp;</a></span>OGR_F_SetFieldString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to string value. </p>
<p>OFTInteger fields will be set based on an atoi() conversion of the string. OFTInteger64 fields will be set based on an <a class="el" href="cpl__conv_8h.html#aa35579a348f417a35965d6be69cde090" title="Convert a string to a 64 bit signed integer.">CPLAtoGIntBig()</a> conversion of the string. OFTReal fields will be set based on an <a class="el" href="cpl__conv_8h.html#afb5bf88066f997b1ab3b3911f5e9b722" title="Converts ASCII string to floating point number.">CPLAtof()</a> conversion of the string. Other field types may be unaffected.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">pszValue</td><td>the value to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35dd76723ae1acc91135054e64d7598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35dd76723ae1acc91135054e64d7598e">&#9670;&nbsp;</a></span>OGR_F_SetFieldStringList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetFieldStringList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set field to list of strings value. </p>
<p>This function currently on has an effect of OFTStringList fields.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a4abbe118cc2f3e48bbac7f710b71b531" title="Set field to integer value.">OGRFeature::SetField()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature that owned the field. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to set, from 0 to GetFieldCount()-1. </td></tr>
    <tr><td class="paramname">papszValues</td><td>the values to assign. List of NUL-terminated string, ending with a NULL pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f7057a7a3764c526a4a59e2b587fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f7057a7a3764c526a4a59e2b587fba">&#9670;&nbsp;</a></span>OGR_F_SetFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hOtherFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForgiving</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. Field values are copied by corresponding field names. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7a28b748acc4d3a6b7fa029661e33c21" title="Set one feature from another.">OGRFeature::SetFrom()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set to. </td></tr>
    <tr><td class="paramname">hOtherFeat</td><td>handle to the feature from which geometry, and field values will be copied.</td></tr>
    <tr><td class="paramname">bForgiving</td><td>TRUE if the operation should continue despite lacking output fields matching some of the source fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </dd></dl>

</div>
</div>
<a id="a9c1b7383891a47387a9b48cb02918fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1b7383891a47387a9b48cb02918fde">&#9670;&nbsp;</a></span>OGR_F_SetFromWithMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetFromWithMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hOtherFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForgiving</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one feature from another. </p>
<p>Overwrite the contents of this feature from the geometry and attributes of another. The hOtherFeature does not need to have the same <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. Field values are copied according to the provided indices map. Field types do not have to exactly match. OGR_F_SetField*() function conversion rules will be applied as needed. This is more efficient than <a class="el" href="ogr__api_8h.html#ad7f7057a7a3764c526a4a59e2b587fba" title="Set one feature from another.">OGR_F_SetFrom()</a> in that this doesn't lookup the fields by their names. Particularly useful when the field names don't match.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7a28b748acc4d3a6b7fa029661e33c21" title="Set one feature from another.">OGRFeature::SetFrom()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set to. </td></tr>
    <tr><td class="paramname">hOtherFeat</td><td>handle to the feature from which geometry, and field values will be copied.</td></tr>
    <tr><td class="paramname">panMap</td><td>Array of the indices of the destination feature's fields stored at the corresponding index of the source feature's fields. A value of -1 should be used to ignore the source's field. The array should not be NULL and be as long as the number of fields in the source feature.</td></tr>
    <tr><td class="paramname">bForgiving</td><td>TRUE if the operation should continue despite lacking output fields matching some of the source fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation succeeds, even if some values are not transferred, otherwise an error code. </dd></dl>

</div>
</div>
<a id="a7b9c524f5c01a6a4b4e50e351d03299f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9c524f5c01a6a4b4e50e351d03299f">&#9670;&nbsp;</a></span>OGR_F_SetGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeature.html#a67949569519c0de6ee3ea48f23ff11c9" title="Set feature geometry.">OGRFeature::SetGeometry()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which new geometry is applied to. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

</div>
</div>
<a id="ad391d3197728bb6d12a6b0c2e2661aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad391d3197728bb6d12a6b0c2e2661aa4">&#9670;&nbsp;</a></span>OGR_F_SetGeometryDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeometryDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometry(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a40a4ddb33f09a5f340b9139be72e277d" title="Set feature geometry.">OGRFeature::SetGeometryDirectly</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method has only an effect on the in-memory feature object. If this object comes from a layer and the modifications must be serialized back to the datasource, <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a> must be used afterwards. Or if this is a new feature, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a> must be used afterwards.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which to apply the geometry. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

</div>
</div>
<a id="ad75b18930385432110aa8d3461854cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75b18930385432110aa8d3461854cce">&#9670;&nbsp;</a></span>OGR_F_SetGeomField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeomField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeometryDirectly(), except that this function does not assume ownership of the passed geometry, but instead makes a copy of it.</p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeature.html#ab03a00692c1ccd5da895b2b90593508c" title="Set feature geometry of a specified geometry field.">OGRFeature::SetGeomField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which new geometry is applied to. </td></tr>
    <tr><td class="paramname">iField</td><td>geometry field to set. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> (checking not yet implemented). </dd></dl>

</div>
</div>
<a id="a01530e163973979cfd8248e3ecbf2640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01530e163973979cfd8248e3ecbf2640">&#9670;&nbsp;</a></span>OGR_F_SetGeomFieldDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_F_SetGeomFieldDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature geometry of a specified geometry field. </p>
<p>This function updates the features geometry, and operate exactly as SetGeomField(), except that this function assumes ownership of the passed geometry (even in case of failure of that function).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ae0ddbbc910727ada3b2cd00a357222da" title="Set feature geometry of a specified geometry field.">OGRFeature::SetGeomFieldDirectly</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which to apply the geometry. </td></tr>
    <tr><td class="paramname">iField</td><td>geometry field to set. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the new geometry to apply to feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is invalid, or OGR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> (checking not yet implemented).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="aeb0f1eb5d248e1d2131b877026cb2a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0f1eb5d248e1d2131b877026cb2a8a">&#9670;&nbsp;</a></span>OGR_F_SetNativeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetNativeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNativeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the native data for the feature. </p>
<p>The native data is the representation in a "natural" form that comes from the driver that created this feature, or that is aimed at an output driver. The native data may be in different format, which is indicated by <a class="el" href="ogr__api_8h.html#abcfe5e7897623a97a2bdc0ec32323fa6" title="Returns the native media type for the feature.">OGR_F_GetNativeMediaType()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#ada90236daf06fa86e8ec9e59ec976908" title="Sets the native data for the feature.">OGRFeature::SetNativeData()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
    <tr><td class="paramname">pszNativeData</td><td>a string with the native data, or NULL if there is none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="a5e5e7ec78caaa3d0c65acb662fa6161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5e7ec78caaa3d0c65acb662fa6161d">&#9670;&nbsp;</a></span>OGR_F_SetNativeMediaType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetNativeMediaType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNativeMediaType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the native media type for the feature. </p>
<p>The native media type is the identifier for the format of the native data. It follows the IANA RFC 2045 (see <a href="https://en.wikipedia.org/wiki/Media_type">https://en.wikipedia.org/wiki/Media_type</a>), e.g. "application/vnd.geo+json" for JSon.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a68476551e589b220eadd02998d5c3a47" title="Sets the native media type for the feature.">OGRFeature::SetNativeMediaType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature. </td></tr>
    <tr><td class="paramname">pszNativeMediaType</td><td>a string with the native media type, or NULL if there is none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr">https://trac.osgeo.org/gdal/wiki/rfc60_improved_roundtripping_in_ogr</a> </dd></dl>

</div>
</div>
<a id="afbe436a7a48ad5bbfb3aa34f44791a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe436a7a48ad5bbfb3aa34f44791a68">&#9670;&nbsp;</a></span>OGR_F_SetStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature style string. </p>
<p>This method operate exactly as <a class="el" href="ogr__api_8h.html#abc1ab2f6fb7937a8b927e4c1d3fd057c" title="Set feature style string.">OGR_F_SetStyleStringDirectly()</a> except that it does not assume ownership of the passed string, but instead makes a copy of it.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a5d2c15d00845820e6382d48227ed7ff7" title="Set feature style string.">OGRFeature::SetStyleString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set style to. </td></tr>
    <tr><td class="paramname">pszStyle</td><td>the style string to apply to this feature, cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1ab2f6fb7937a8b927e4c1d3fd057c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1ab2f6fb7937a8b927e4c1d3fd057c">&#9670;&nbsp;</a></span>OGR_F_SetStyleStringDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_SetStyleStringDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pszStyle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set feature style string. </p>
<p>This method operate exactly as <a class="el" href="ogr__api_8h.html#afbe436a7a48ad5bbfb3aa34f44791a68" title="Set feature style string.">OGR_F_SetStyleString()</a> except that it assumes ownership of the passed string.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a7282982663cee5dd2fc18a093c3e386a" title="Set feature style string.">OGRFeature::SetStyleStringDirectly()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to set style to. </td></tr>
    <tr><td class="paramname">pszStyle</td><td>the style string to apply to this feature, cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a6a61d39a67b1990ce92bd65de4bc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6a61d39a67b1990ce92bd65de4bc6f">&#9670;&nbsp;</a></span>OGR_F_StealGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_StealGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take away ownership of geometry. </p>
<p>Fetch the geometry from this feature, and clear the reference to the geometry on the feature. This is a mechanism for the application to take over ownership of the geometry from the feature without copying. Sort of an inverse to OGR_FSetGeometryDirectly().</p>
<p>After this call the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> will have a NULL geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>feature from which to steal the first geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the stolen geometry. </dd></dl>

</div>
</div>
<a id="af077f5a70f6fe091e3004bfd4dd952cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077f5a70f6fe091e3004bfd4dd952cb">&#9670;&nbsp;</a></span>OGR_F_StealGeometryEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_F_StealGeometryEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take away ownership of geometry. </p>
<p>Fetch the geometry from this feature, and clear the reference to the geometry on the feature. This is a mechanism for the application to take over ownership of the geometry from the feature without copying. This is the functional opposite of OGR_F_SetGeomFieldDirectly.</p>
<p>After this call the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> will have a NULL geometry for the geometry field of index iGeomField.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>feature from which to steal a geometry. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field to steal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the stolen geometry. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="aa70b7675a003141e63f9603c752ee22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70b7675a003141e63f9603c752ee22e">&#9670;&nbsp;</a></span>OGR_F_UnsetField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_F_UnsetField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a field, marking it as unset. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a937b21e0137e40bc1473f354879975da" title="Clear a field, marking it as unset.">OGRFeature::UnsetField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature on which the field is. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to unset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab798c73a20f4b311026232badda9701d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab798c73a20f4b311026232badda9701d">&#9670;&nbsp;</a></span>OGR_F_Validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_F_Validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValidateFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bEmitError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate that a feature meets constraints of its schema. </p>
<p>The scope of test is specified with the nValidateFlags parameter.</p>
<p>Regarding OGR_F_VAL_WIDTH, the test is done assuming the string width must be interpreted as the number of UTF-8 characters. Some drivers might interpret the width as the number of bytes instead. So this test is rather conservative (if it fails, then it will fail for all interpretations).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeature.html#a8ddcb9dd93fc92f7c9c0c55cb39349fb" title="Validate that a feature meets constraints of its schema.">OGRFeature::Validate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFeat</td><td>handle to the feature to validate. </td></tr>
    <tr><td class="paramname">nValidateFlags</td><td>OGR_F_VAL_ALL or combination of OGR_F_VAL_NULL, OGR_F_VAL_GEOM_TYPE, OGR_F_VAL_WIDTH and OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT with '|' operator </td></tr>
    <tr><td class="paramname">bEmitError</td><td>TRUE if a <a class="el" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d" title="Report an error.">CPLError()</a> must be emitted when a check fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if all enabled validation tests pass. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a2a798e8d03299403418a7c87862f1acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a798e8d03299403418a7c87862f1acb">&#9670;&nbsp;</a></span>OGR_FD_AddFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_AddFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#aab585ef1166c61c4819f7fd46ee4a275" title="Create a new field on a layer.">OGR_L_CreateField()</a> instead.</p>
<p>This function should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. The <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a5aee3ab9dfe9f886e261ca57b934ba5c" title="Add a new field definition.">OGRFeatureDefn::AddFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to add the field definition to. </td></tr>
    <tr><td class="paramname">hNewField</td><td>handle to the new field definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa080fdbe88c1829c1b7adcce208ec4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa080fdbe88c1829c1b7adcce208ec4b8">&#9670;&nbsp;</a></span>OGR_FD_AddGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_AddGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new field definition to the passed feature definition. </p>
<p>To add a new field definition to a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#af6908931c4f3ad364fef8d6e831363bc" title="Create a new geometry field on a layer.">OGR_L_CreateGeomField()</a> instead.</p>
<p>This function should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>. The <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> passed in is copied, and remains the responsibility of the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#aa7347349c45e6015ecd251614c67ef32" title="Add a new geometry field definition.">OGRFeatureDefn::AddGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to add the geometry field definition to. </td></tr>
    <tr><td class="paramname">hNewGeomField</td><td>handle to the new field definition.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a5a8049bf2d58da5381c9350a6159ea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8049bf2d58da5381c9350a6159ea6c">&#9670;&nbsp;</a></span>OGR_FD_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> OGR_FD_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new feature definition object to hold the field definitions. </p>
<p>The <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> maintains a reference count, but this starts at zero, and should normally be incremented by the owner.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ada5564d238a73a8c98b30807c4c8db73" title="Constructor.">OGRFeatureDefn::OGRFeatureDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name to be assigned to this layer/class. It does not need to be unique. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the newly created feature definition. </dd></dl>

</div>
</div>
<a id="a6283475163d911204f5ff45098c8479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6283475163d911204f5ff45098c8479e">&#9670;&nbsp;</a></span>OGR_FD_DeleteFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_FD_DeleteFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing field definition. </p>
<p>To delete an existing field definition from a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#afc861413683418eba5d31e487da2f9e2" title="Delete an existing field on a layer.">OGR_L_DeleteField()</a> instead.</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ada48e1a3e90798bdccc2dd26f32f48cb" title="Delete an existing field definition.">OGRFeatureDefn::DeleteFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition. </td></tr>
    <tr><td class="paramname">iField</td><td>the index of the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a1fb650102be3837fc220b086b17f4462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb650102be3837fc220b086b17f4462">&#9670;&nbsp;</a></span>OGR_FD_DeleteGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_FD_DeleteGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing geometry field definition. </p>
<p>To delete an existing geometry field definition from a layer definition, do not use this function directly, but use OGR_L_DeleteGeomField() instead (<em>not implemented yet</em>).</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2c67a35c58cfd9ac384858d1b7b7ec48" title="Delete an existing geometry field definition.">OGRFeatureDefn::DeleteGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>the index of the geometry field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a107635936c90c7f4347d7b3f9fb06e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107635936c90c7f4347d7b3f9fb06e6d">&#9670;&nbsp;</a></span>OGR_FD_Dereference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_Dereference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrements the reference count by one. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a87a280dd42634206dfbcfc47b1ecfea4" title="Decrements the reference count by one.">OGRFeatureDefn::Dereference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated reference count. </dd></dl>

</div>
</div>
<a id="a59d5cbb660cce8467a210caa4d68a011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d5cbb660cce8467a210caa4d68a011">&#9670;&nbsp;</a></span>OGR_FD_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a feature definition object and release all memory associated with it. </p>
<p>This function is the same as the C++ method OGRFeatureDefn::~OGRFeatureDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586a14271a457387a2b5c0097a02c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586a14271a457387a2b5c0097a02c8da">&#9670;&nbsp;</a></span>OGR_FD_GetFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature.">OGRFeatureDefn::GetFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of fields. </dd></dl>

</div>
</div>
<a id="a484456df86a01284769d0afe3beaa4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484456df86a01284769d0afe3beaa4f6">&#9670;&nbsp;</a></span>OGR_FD_GetFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> OGR_FD_GetFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a43b95ce699bbca73acb453cc959378e7" title="Fetch field definition.">OGRFeatureDefn::GetFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the field definition from. </td></tr>
    <tr><td class="paramname">iField</td><td>the field to fetch, between 0 and GetFieldCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application. </dd></dl>

</div>
</div>
<a id="a1e54c3271dce0562209d78ae6eaae330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e54c3271dce0562209d78ae6eaae330">&#9670;&nbsp;</a></span>OGR_FD_GetFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find field by name. </p>
<p>The field index of the first field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#adf94fefd88e82172e5279f5188b3873b" title="Find field by name.">OGRFeatureDefn::GetFieldIndex</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get field index from. </td></tr>
    <tr><td class="paramname">pszFieldName</td><td>the field name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field index, or -1 if no match found. </dd></dl>

</div>
</div>
<a id="a0b34027b691ea40e20b911290f863303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b34027b691ea40e20b911290f863303">&#9670;&nbsp;</a></span>OGR_FD_GetGeomFieldCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetGeomFieldCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of geometry fields on the passed feature definition. </p>
<p>This function is the same as the C++ <a class="el" href="classOGRFeatureDefn.html#ad5e568a81eca8d6101ae4475b653f1c9" title="Fetch number of geometry fields on this feature.">OGRFeatureDefn::GetGeomFieldCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the fields count from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count of geometry fields.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a82275ef1d2655817f6fe582f885c92c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82275ef1d2655817f6fe582f885c92c7">&#9670;&nbsp;</a></span>OGR_FD_GetGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> OGR_FD_GetGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry field definition of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#acacca3de3718ae525565e5130b5474dc" title="Fetch geometry field definition.">OGRFeatureDefn::GetGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the field definition from. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to an internal field definition object or NULL if invalid index. This object should not be modified or freed by the application.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a69be97ea100c50bdaad8a1d3c30e7b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69be97ea100c50bdaad8a1d3c30e7b14">&#9670;&nbsp;</a></span>OGR_FD_GetGeomFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetGeomFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszGeomFieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find geometry field by name. </p>
<p>The geometry field index of the first geometry field matching the passed field name (case insensitively) is returned.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#af033ae277fade415ff13ed8b5643e4be" title="Find geometry field by name.">OGRFeatureDefn::GetGeomFieldIndex</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get field index from. </td></tr>
    <tr><td class="paramname">pszGeomFieldName</td><td>the geometry field name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry field index, or -1 if no match found. </dd></dl>

</div>
</div>
<a id="add0b3a6b6062122e4f4316d194d2a1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0b3a6b6062122e4f4316d194d2a1cf">&#9670;&nbsp;</a></span>OGR_FD_GetGeomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_FD_GetGeomType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the geometry base type of the passed feature definition. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#acc3e3904d856b9c8b5b26204c68e916a" title="Fetch the geometry base type.">OGRFeatureDefn::GetGeomType()</a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;GetType().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the geometry type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base type for all geometry related to this definition. </dd></dl>

</div>
</div>
<a id="a20f309bf10e5b76cc083848b710babb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f309bf10e5b76cc083848b710babb8">&#9670;&nbsp;</a></span>OGR_FD_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_FD_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> passed as an argument. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ab8fa2428efb085a0b5dd78342b535aeb" title="Get name of this OGRFeatureDefn.">OGRFeatureDefn::GetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to get the name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name. This name is internal and should not be modified, or freed. </dd></dl>

</div>
</div>
<a id="a9e4e8867edeaf1a6f98e6ff284835811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e8867edeaf1a6f98e6ff284835811">&#9670;&nbsp;</a></span>OGR_FD_GetReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_GetReferenceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch current reference count. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#aedb957000f22445d536d89c566f32526" title="Fetch current reference count.">OGRFeatureDefn::GetReferenceCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current reference count. </dd></dl>

</div>
</div>
<a id="ad1208985f67db526136dbe74f490c8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1208985f67db526136dbe74f490c8d3">&#9670;&nbsp;</a></span>OGR_FD_IsGeometryIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsGeometryIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#ab64252824a66afa3e1ada210a1f29d28" title="Determine whether the geometry can be omitted when fetching features.">OGRFeatureDefn::IsGeometryIgnored()</a>.</p>
<p>Starting with GDAL 1.11, this method returns GetGeomFieldDefn(0)-&gt;IsIgnored().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state </dd></dl>

</div>
</div>
<a id="ab07056d514160c26724f3a2d5319185f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07056d514160c26724f3a2d5319185f">&#9670;&nbsp;</a></span>OGR_FD_IsSame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsSame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hFDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hOtherFDefn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the feature definition is identical to the other one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
    <tr><td class="paramname">hOtherFDefn</td><td>handle to the other feature definition to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the feature definition is identical to the other one.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.11 </dd></dl>

</div>
</div>
<a id="aa9490e3e5d25b780723ad3f0ab3302eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9490e3e5d25b780723ad3f0ab3302eb">&#9670;&nbsp;</a></span>OGR_FD_IsStyleIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_IsStyleIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a7edc3d1a8add158e00475faec76c036a" title="Determine whether the style can be omitted when fetching features.">OGRFeatureDefn::IsStyleIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on which <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state </dd></dl>

</div>
</div>
<a id="a6763104e7fafcab1b52d9b0f275e19e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6763104e7fafcab1b52d9b0f275e19e8">&#9670;&nbsp;</a></span>OGR_FD_Reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_FD_Reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the reference count by one. </p>
<p>The reference count is used keep track of the number of <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> objects referencing this definition.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a2c58c6238242dff3d472faf5e3803922" title="Increments the reference count by one.">OGRFeatureDefn::Reference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the updated reference count. </dd></dl>

</div>
</div>
<a id="a0755b0360414095e15eaf2c1496f8c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0755b0360414095e15eaf2c1496f8c47">&#9670;&nbsp;</a></span>OGR_FD_Release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_Release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference, and destroy if unreferenced. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a75e1424e3ce755d4393f5b42736d13ee" title="Drop a reference to this object, and destroy if no longer referenced.">OGRFeatureDefn::Release()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition to be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4c8060c508310620870bd89969418ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c8060c508310620870bd89969418ac">&#9670;&nbsp;</a></span>OGR_FD_ReorderFieldDefns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_FD_ReorderFieldDefns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the field definitions in the array of the feature definition. </p>
<p>To reorder the field definitions in a layer definition, do not use this function directly, but use <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer.">OGR_L_ReorderFields()</a> instead.</p>
<p>This method should only be called while there are no <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> objects in existence based on this <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a96b526938c909d927f1851b39d1fb67e" title="Reorder the field definitions in the array of the feature definition.">OGRFeatureDefn::ReorderFieldDefns()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition. </td></tr>
    <tr><td class="paramname">panMap</td><td>an array of GetFieldCount() elements which is a permutation of [0, GetFieldCount()-1]. panMap is such that, for each field definition at position i after reordering, its position before reordering was panMap[i]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1.0 </dd></dl>

</div>
</div>
<a id="a1bbc85e1ba2378679e4ce6bf3523bf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbc85e1ba2378679e4ce6bf3523bf8e">&#9670;&nbsp;</a></span>OGR_FD_SetGeometryIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetGeometryIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIgnore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the geometry can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#a539b87cd1587dc928b246a211839e22a" title="Set whether the geometry can be omitted when fetching features.">OGRFeatureDefn::SetGeometryIgnored()</a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetIgnored().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
    <tr><td class="paramname">bIgnore</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11ca3a84b54ac36c5f68a03821f1fa78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ca3a84b54ac36c5f68a03821f1fa78">&#9670;&nbsp;</a></span>OGR_FD_SetGeomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetGeomType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the base geometry type for the passed layer (the same as the feature definition). </p>
<p>All geometry objects using this type must be of the defined type or a derived type. The default upon creation is wkbUnknown which allows for any geometry type. The geometry type should generally not be changed after any OGRFeatures have been created against this definition.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#aa0f50b39efbba6559a510d7afcfa5efb" title="Assign the base geometry type for this layer.">OGRFeatureDefn::SetGeomType()</a>.</p>
<p>Starting with GDAL 1.11, this method calls GetGeomFieldDefn(0)-&gt;SetType().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the layer or feature definition to set the geometry type to. </td></tr>
    <tr><td class="paramname">eType</td><td>the new type to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c09218e9ef9e49abcdd0b76858a514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c09218e9ef9e49abcdd0b76858a514b">&#9670;&nbsp;</a></span>OGR_FD_SetStyleIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FD_SetStyleIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIgnore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the style can be omitted when fetching features. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFeatureDefn.html#af0b584e3423493421a4f69da42beedcc" title="Set whether the style can be omitted when fetching features.">OGRFeatureDefn::SetStyleIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the feature definition on witch <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> are based on. </td></tr>
    <tr><td class="paramname">bIgnore</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb1ffd4d1f9f68aa76f660dc4f82e492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1ffd4d1f9f68aa76f660dc4f82e492">&#9670;&nbsp;</a></span>OGR_Fld_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a> OGR_Fld_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new field definition. </p>
<p>By default, fields have no width, precision, are nullable and not ignored.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#afc375f038b548b5a86b854c214fee114" title="Constructor.">OGRFieldDefn::OGRFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the new field definition. </td></tr>
    <tr><td class="paramname">eType</td><td>the type of the new field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the new field definition. </dd></dl>

</div>
</div>
<a id="a455fa4a2c2451b1748facb6b7126a822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455fa4a2c2451b1748facb6b7126a822">&#9670;&nbsp;</a></span>OGR_Fld_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a field definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74c6791d020eab96730a9ab3ecca6f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c6791d020eab96730a9ab3ecca6f84">&#9670;&nbsp;</a></span>OGR_Fld_GetAlternativeNameRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetAlternativeNameRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the alternative name (or "alias") for this field. </p>
<p>The alternative name is an optional attribute for a field which can provide a more user-friendly, descriptive name of a field which is not subject to the usual naming constraints defined by the data provider.</p>
<p>This is a metadata style attribute only: the alternative name cannot be used in place of the actual field name during SQL queries or other field name dependent API calls.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#ad65cd1946750fb8bc80d9f8414e576bd" title="Fetch the alternative name (or &quot;alias&quot;) for this field.">OGRFieldDefn::GetAlternativeNameRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the alternative name of the field definition.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="a80c22d085f7ffae07b22c8d26c77794a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c22d085f7ffae07b22c8d26c77794a">&#9670;&nbsp;</a></span>OGR_Fld_GetComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetComment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the (optional) comment for this field. </p>
<p>By default, none (empty string) is returned.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ab03617cad10b80e943b6419f17a1c489" title="Return the (optional) comment for this field.">OGRFieldDefn::GetComment()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the comment, or an empty string if there is none. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="aacc96ddb37f8b8076e711e48ee9ead62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc96ddb37f8b8076e711e48ee9ead62">&#9670;&nbsp;</a></span>OGR_Fld_GetDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default field value. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ac4210fa7c6f10ed090a5558224447cfa" title="Get default field value.">OGRFieldDefn::GetDefault()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>default field value or NULL. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a11064c2d8444dff4b87f44626849f4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11064c2d8444dff4b87f44626849f4b9">&#9670;&nbsp;</a></span>OGR_Fld_GetDomainName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetDomainName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the field domain for this field. </p>
<p>By default, none (empty string) is returned.</p>
<p>Field domains (<a class="el" href="classOGRFieldDomain.html" title="Definition of a field domain.">OGRFieldDomain</a> class) are attached at the <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> level and should be retrieved with <a class="el" href="gdal_8h.html#ab9f59bc05ea40c670851a645e084ea4f" title="Get a field domain from its name.">GDALDatasetGetFieldDomain()</a>.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ae36192269558570b6627073f82542c9c" title="Return the name of the field domain for this field.">OGRFieldDefn::GetDomainName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field domain name, or an empty string if there is none. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a0cf8a09826e47763e6bf667af0dae1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf8a09826e47763e6bf667af0dae1a7">&#9670;&nbsp;</a></span>OGR_Fld_GetJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a> OGR_Fld_GetJustify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the justification for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a5ac2afcfb22e885321bf877d2d1fd99d" title="Get the justification for this field.">OGRFieldDefn::GetJustify()</a>.</p>
<p>Note: no driver is know to use the concept of field justification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get justification from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the justification. </dd></dl>

</div>
</div>
<a id="a8d7640a6b6a47a95d83415f9271ffe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7640a6b6a47a95d83415f9271ffe30">&#9670;&nbsp;</a></span>OGR_Fld_GetNameRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_Fld_GetNameRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a0264c5e7e6ff31fbd6a2b55aab86c6a6" title="Fetch name of this field.">OGRFieldDefn::GetNameRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the field definition. </dd></dl>

</div>
</div>
<a id="a120dd56ee23070922e4d84ed06b06e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120dd56ee23070922e4d84ed06b06e27">&#9670;&nbsp;</a></span>OGR_Fld_GetPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the formatting precision for this field. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a86337654bc490bdc3e3b17e292b09c4b" title="Get the formatting precision for this field.">OGRFieldDefn::GetPrecision()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get precision from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the precision. </dd></dl>

</div>
</div>
<a id="a3ef13952aa38f83b0dc1da047870511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef13952aa38f83b0dc1da047870511f">&#9670;&nbsp;</a></span>OGR_Fld_GetSubType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> OGR_Fld_GetSubType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch subtype of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a3c18c491717be99e2e1a3c96cfc2ffd9" title="Fetch subtype of this field.">OGRFieldDefn::GetSubType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get subtype from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field subtype. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ad8d150dfc678e0a2a7f5241ba38c5611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d150dfc678e0a2a7f5241ba38c5611">&#9670;&nbsp;</a></span>OGR_Fld_GetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> OGR_Fld_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch type of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a8bb642e3e582146e3090247a1673d715" title="Fetch type of this field.">OGRFieldDefn::GetType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field type. </dd></dl>

</div>
</div>
<a id="ae573548454787d6f0552e469e15fc3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae573548454787d6f0552e469e15fc3d9">&#9670;&nbsp;</a></span>OGR_Fld_GetTZFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetTZFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time zone flag. </p>
<p>Only applies to OFTTime, OFTDate and OFTDateTime fields.</p>
<p>Cf OGR_TZFLAG_UNKNOWN, OGR_TZFLAG_LOCALTIME, OGR_TZFLAG_MIXED_TZ and OGR_TZFLAG_UTC</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time zone flag. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="aa6500186e3f22761a615428c55bba0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6500186e3f22761a615428c55bba0ce">&#9670;&nbsp;</a></span>OGR_Fld_GetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_GetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the formatting width for this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#aa8c4090f59d60ca949ba3fd0eada9f36" title="Get the formatting width for this field.">OGRFieldDefn::GetWidth()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to get width from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the width, zero means no specified width. </dd></dl>

</div>
</div>
<a id="a4bf08ca1607bdc678f2ae166ad0f27e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf08ca1607bdc678f2ae166ad0f27e2">&#9670;&nbsp;</a></span>OGR_Fld_IsDefaultDriverSpecific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsDefaultDriverSpecific </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the default value is driver specific. </p>
<p>Driver specific default values are those that are <em>not</em> NULL, a numeric value, a literal value enclosed between single quote characters, CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal value.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a979f31c748be9d066c888c549e410876" title="Returns whether the default value is driver specific.">OGRFieldDefn::IsDefaultDriverSpecific()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the default value is driver specific. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a29bec35ae5a4c232ad850315bdc2b675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bec35ae5a4c232ad850315bdc2b675">&#9670;&nbsp;</a></span>OGR_Fld_IsIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ae55ec65c6013cfbf0bd08b7acecb0b9f" title="Return whether this field should be omitted when fetching features.">OGRFieldDefn::IsIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state </dd></dl>

</div>
</div>
<a id="a57bfc414977d37ee22edefd38c1f414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bfc414977d37ee22edefd38c1f414b">&#9670;&nbsp;</a></span>OGR_Fld_IsNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field can receive null values. </p>
<p>By default, fields are nullable.</p>
<p>Even if this method returns FALSE (i.e not-nullable field), it doesn't mean that <a class="el" href="classOGRFeature.html#a905bb73fe5e6df57f1be5a8b77489b74" title="Test if a field has ever been assigned a value or not.">OGRFeature::IsFieldSet()</a> will necessary return TRUE, as fields can be temporary unset and null/not-null validation is usually done when <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">OGRLayer::CreateFeature()</a>/SetFeature() is called.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a0a610ad741b9a6d81689de70133937d0" title="Return whether this field can receive null values.">OGRFieldDefn::IsNullable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is authorized to be null. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a6ff65c05d498c568bd72d0d08e9544ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff65c05d498c568bd72d0d08e9544ce">&#9670;&nbsp;</a></span>OGR_Fld_IsUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_Fld_IsUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field has a unique constraint. </p>
<p>By default, fields have no unique constraint.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a20df702a2e152c946407d7c4796095a4" title="Return whether this field has a unique constraint.">OGRFieldDefn::IsUnique()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field has a unique constraint. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="a5922e599fe8746b81adf251be6b5ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5922e599fe8746b81adf251be6b5ecf0">&#9670;&nbsp;</a></span>OGR_Fld_Set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_Set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNameIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eTypeIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nWidthIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPrecisionIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&#160;</td>
          <td class="paramname"><em>eJustifyIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set defining parameters for a field in one call. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a9b08b348f111ecbfe2970b312d9ce54b" title="Set defining parameters for a field in one call.">OGRFieldDefn::Set()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set to. </td></tr>
    <tr><td class="paramname">pszNameIn</td><td>the new name to assign. </td></tr>
    <tr><td class="paramname">eTypeIn</td><td>the new type (one of the OFT values like OFTInteger). </td></tr>
    <tr><td class="paramname">nWidthIn</td><td>the preferred formatting width. Defaults to zero indicating undefined. </td></tr>
    <tr><td class="paramname">nPrecisionIn</td><td>number of decimals places for formatting, defaults to zero indicating undefined. </td></tr>
    <tr><td class="paramname">eJustifyIn</td><td>the formatting justification (OJLeft or OJRight), defaults to OJUndefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a158cc56e4591cb18ebba61c2ec16ac3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158cc56e4591cb18ebba61c2ec16ac3f">&#9670;&nbsp;</a></span>OGR_Fld_SetAlternativeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetAlternativeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAlternativeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the alternative name (or "alias") for this field. </p>
<p>The alternative name is an optional attribute for a field which can provide a more user-friendly, descriptive name of a field which is not subject to the usual naming constraints defined by the data provider.</p>
<p>This is a metadata style attribute only: the alternative name cannot be used in place of the actual field name during SQL queries or other field name dependent API calls.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a19a197d6a1adbd22bc081fcdf45f91ce" title="Reset the alternative name (or &quot;alias&quot;) for this field.">OGRFieldDefn::SetAlternativeName()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to apply the new alternative name to. </td></tr>
    <tr><td class="paramname">pszAlternativeName</td><td>the new alternative name to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="affc1e58b1b86ea322e4f440f61bc5a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc1e58b1b86ea322e4f440f61bc5a82">&#9670;&nbsp;</a></span>OGR_Fld_SetComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetComment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszComment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the comment for this field. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a0d415863819992d77a9c40dac8ef063c" title="Set the comment for this field.">OGRFieldDefn::SetComment()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">pszComment</td><td>Field comment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="aa0268ee60f240e6fa668b7c612354f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0268ee60f240e6fa668b7c612354f80">&#9670;&nbsp;</a></span>OGR_Fld_SetDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDefault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default field value. </p>
<p>The default field value is taken into account by drivers (generally those with a SQL interface) that support it at field creation time. OGR will generally not automatically set the default field value to null fields by itself when calling <a class="el" href="classOGRFeature.html#a0ef4455f24cfbec6cf37110f9116cf15" title="Feature factory.">OGRFeature::CreateFeature()</a> / OGRFeature::SetFeature(), but will let the low-level layers to do the job. So retrieving the feature from the layer is recommended.</p>
<p>The accepted values are NULL, a numeric value, a literal value enclosed between single quote characters (and inner single quote characters escaped by repetition of the single quote character), CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or a driver specific expression (that might be ignored by other drivers). For a datetime literal value, format should be 'YYYY/MM/DD HH:MM:SS[.sss]' (considered as UTC time).</p>
<p>Drivers that support writing DEFAULT clauses will advertise the GDAL_DCAP_DEFAULT_FIELDS driver metadata item.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a2371ed1f14f00bd9aa9ee4bce11dd768" title="Set default field value.">OGRFieldDefn::SetDefault()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. </td></tr>
    <tr><td class="paramname">pszDefault</td><td>new default field value or NULL pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a475c92a9d0dabad1e1b578e8712059d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475c92a9d0dabad1e1b578e8712059d9">&#9670;&nbsp;</a></span>OGR_Fld_SetDomainName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetDomainName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFieldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the field domain for this field. </p>
<p>Field domains (<a class="el" href="classOGRFieldDomain.html" title="Definition of a field domain.">OGRFieldDomain</a>) are attached at the <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> level.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a7fb851d60c2097d96f70d0ea7810877e" title="Set the name of the field domain for this field.">OGRFieldDefn::SetDomainName()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">pszFieldName</td><td>Field domain name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="aeddf9aa9767cd28c90dc66ed2a7a7332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddf9aa9767cd28c90dc66ed2a7a7332">&#9670;&nbsp;</a></span>OGR_Fld_SetIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a5d8df84c8a8d87908b8416fef6913934" title="Set whether this field should be omitted when fetching features.">OGRFieldDefn::SetIgnored()</a>.</p>
<p>This method should not be called on a object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, the <a class="el" href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a" title="Set which fields can be omitted when retrieving features from the layer.">OGRLayer::SetIgnoredFields()</a> method should be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">ignore</td><td>ignore state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4809f2fe957002b8e18aacc1bdca240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4809f2fe957002b8e18aacc1bdca240">&#9670;&nbsp;</a></span>OGR_Fld_SetJustify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetJustify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a701976be938cd60a2fa96454f61d3600">OGRJustification</a>&#160;</td>
          <td class="paramname"><em>eJustify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the justification for this field. </p>
<p>Note: no driver is know to use the concept of field justification.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#acbd783e3b61ab388eab3f45c25cf1bc0" title="Set the justification for this field.">OGRFieldDefn::SetJustify()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set justification to. </td></tr>
    <tr><td class="paramname">eJustify</td><td>the new justification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6599fa42bad3aba26574ae3260c6984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6599fa42bad3aba26574ae3260c6984d">&#9670;&nbsp;</a></span>OGR_Fld_SetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a241585cd66a38311aa0322f34e6d5214" title="Reset the name of this field.">OGRFieldDefn::SetName()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to apply the new name to. </td></tr>
    <tr><td class="paramname">pszName</td><td>the new name to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a35def2d6766804a59f0b4c24e457d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a35def2d6766804a59f0b4c24e457d5">&#9670;&nbsp;</a></span>OGR_Fld_SetNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNullableIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field can receive null values. </p>
<p>By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint.</p>
<p>Drivers that support writing not-null constraint will advertise the GDAL_DCAP_NOTNULL_FIELDS driver metadata item.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#ac10a3da064cd17f9b5d377b690d3162c" title="Set whether this field can receive null values.">OGRFieldDefn::SetNullable()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">bNullableIn</td><td>FALSE if the field must have a not-null constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a13890f01f7d7e57bcd07e23f3e2947da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13890f01f7d7e57bcd07e23f3e2947da">&#9670;&nbsp;</a></span>OGR_Fld_SetPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPrecision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the formatting precision for this field in characters. </p>
<p>This should normally be zero for fields of types other than OFTReal.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#abea88d3ed96c46b4f0eda415460f8664" title="Set the formatting precision for this field in characters.">OGRFieldDefn::SetPrecision()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set precision to. </td></tr>
    <tr><td class="paramname">nPrecision</td><td>the new precision. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab83497e3ce74c6abb615a234791850c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83497e3ce74c6abb615a234791850c1">&#9670;&nbsp;</a></span>OGR_Fld_SetSubType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetSubType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eSubType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the subtype of this field. </p>
<p>This should never be done to an <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#af5e277ae923683e8b4982d9dd009740d" title="Set the subtype of this field.">OGRFieldDefn::SetSubType()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set type to. </td></tr>
    <tr><td class="paramname">eSubType</td><td>the new field subtype. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a76195990f814eb93e821c01ce0599a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76195990f814eb93e821c01ce0599a50">&#9670;&nbsp;</a></span>OGR_Fld_SetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the type of this field. </p>
<p>This should never be done to an <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a26bf22b7d805b9e33dd5c5fe9b4a8363" title="Set the type of this field.">OGRFieldDefn::SetType()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set type to. </td></tr>
    <tr><td class="paramname">eType</td><td>the new field type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad684a6c2079c558d5e0579a3f758b5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad684a6c2079c558d5e0579a3f758b5ea">&#9670;&nbsp;</a></span>OGR_Fld_SetTZFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetTZFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nTZFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the formatting precision for this field in characters. </p>
<p>Set the time zone flag.</p>
<p>Only applies to OFTTime, OFTDate and OFTDateTime fields.</p>
<p>Cf OGR_TZFLAG_UNKNOWN, OGR_TZFLAG_LOCALTIME, OGR_TZFLAG_MIXED_TZ and OGR_TZFLAG_UTC</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set precision to. </td></tr>
    <tr><td class="paramname">nTZFlag</td><td>the new time zone flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a6779229ca8cd4459538915674d67a6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6779229ca8cd4459538915674d67a6c5">&#9670;&nbsp;</a></span>OGR_Fld_SetUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUniqueIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field has a unique constraint. </p>
<p>By default, fields have no unique constraint, so this method is generally called with TRUE to set a unique constraint.</p>
<p>Drivers that support writing unique constraint will advertise the GDAL_DCAP_UNIQUE_FIELDS driver metadata item. field can receive null values.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRFieldDefn.html#a321d53614b18a90cd662508f12e46474" title="Set whether this field has a unique constraint.">OGRFieldDefn::SetUnique()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">bUniqueIn</td><td>TRUE if the field must have a unique constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.2 </dd></dl>

</div>
</div>
<a id="a1d7bf7c14a299448efac58f7bf364326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7bf7c14a299448efac58f7bf364326">&#9670;&nbsp;</a></span>OGR_Fld_SetWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_Fld_SetWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the formatting width for this field in characters. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#aa793194c45ccba5ec7e9f7aea49dc6f3" title="Set the formatting width for this field in characters.">OGRFieldDefn::SetWidth()</a>.</p>
<p>Note that once a <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> has been added to a layer definition with OGRLayer::AddFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition to set width to. </td></tr>
    <tr><td class="paramname">nNewWidth</td><td>the new width. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b56883e79d620e4cf585e64f323787b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b56883e79d620e4cf585e64f323787b">&#9670;&nbsp;</a></span>OGR_FldDomain_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FldDomain_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#aa0e788087a388460e482c9d1f037cdd5" title="Destructor.">OGRFieldDomain::~OGRFieldDomain()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>the field domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a416e9dd1549466905307cb4127cb2f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416e9dd1549466905307cb4127cb2f96">&#9670;&nbsp;</a></span>OGR_FldDomain_GetDescription()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_FldDomain_GetDescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the description of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#acb14f4b0a30ad70fbeb40b105290bc82" title="Get the description of the field domain.">OGRFieldDomain::GetDescription()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field domain description (might be empty string). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a059d2f1f33bba149c21aafc5ceb44e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059d2f1f33bba149c21aafc5ceb44e81">&#9670;&nbsp;</a></span>OGR_FldDomain_GetDomainType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a45135d27c2151b4e9a812c4c805750f0">OGRFieldDomainType</a> OGR_FldDomain_GetDomainType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#ad2721c9de3e8ad35f086d31bf9b27399" title="Get the type of the field domain.">OGRFieldDomain::GetDomainType()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the field domain. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a62d137f7095dcbed598b12ae4c301662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d137f7095dcbed598b12ae4c301662">&#9670;&nbsp;</a></span>OGR_FldDomain_GetFieldSubType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a> OGR_FldDomain_GetFieldSubType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field subtype of the field domain. </p>
<p>This is the same as <a class="el" href="classOGRFieldDomain.html#a5ce08ba9405808c3bc2bd44ea689902f" title="Get the field subtype.">OGRFieldDomain::GetFieldSubType()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field subtype of the field domain. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="af620d05baaca2f877571a4404d668289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af620d05baaca2f877571a4404d668289">&#9670;&nbsp;</a></span>OGR_FldDomain_GetFieldType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a> OGR_FldDomain_GetFieldType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field type of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#ad16942a0fb82a84c386d308cddc6613a" title="Get the field type.">OGRFieldDomain::GetFieldType()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field type of the field domain. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a3a34a6a061992272a0ab8ed7c16e4433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a34a6a061992272a0ab8ed7c16e4433">&#9670;&nbsp;</a></span>OGR_FldDomain_GetMergePolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a367cf2b3c8f40c3892e37a09fe1805c7">OGRFieldDomainMergePolicy</a> OGR_FldDomain_GetMergePolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the merge policy of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#a21abc4f8e2c0c065802b52bb68f89317" title="Get the merge policy.">OGRFieldDomain::GetMergePolicy()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the merge policy of the field domain. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a84e017419012b470cf99305d2ebe2b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e017419012b470cf99305d2ebe2b46">&#9670;&nbsp;</a></span>OGR_FldDomain_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_FldDomain_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#ae2811985c99807b034ea05fa09bb1300" title="Get the name of the field domain.">OGRFieldDomain::GetName()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field domain name. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a73426f344716dc6ac29e8768d186dcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73426f344716dc6ac29e8768d186dcde">&#9670;&nbsp;</a></span>OGR_FldDomain_GetSplitPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#af913e138a8606cc7a201acc434a53317">OGRFieldDomainSplitPolicy</a> OGR_FldDomain_GetSplitPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the split policy of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#ab514a2e61306b1c7afd93c8461f68d16" title="Get the split policy.">OGRFieldDomain::GetSplitPolicy()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the split policy of the field domain. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a7b58e909e596ebb4c787d0bb7ab0c5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58e909e596ebb4c787d0bb7ab0c5ab">&#9670;&nbsp;</a></span>OGR_FldDomain_SetMergePolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FldDomain_SetMergePolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a367cf2b3c8f40c3892e37a09fe1805c7">OGRFieldDomainMergePolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the merge policy of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#a37a6de70bcdd4d43032ea018372fb5e5" title="Set the merge policy.">OGRFieldDomain::SetMergePolicy()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
    <tr><td class="paramname">policy</td><td>the merge policy of the field domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a0ee9d25a1607b86020a83e6f3447131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee9d25a1607b86020a83e6f3447131e">&#9670;&nbsp;</a></span>OGR_FldDomain_SetSplitPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_FldDomain_SetSplitPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#af913e138a8606cc7a201acc434a53317">OGRFieldDomainSplitPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the split policy of the field domain. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRFieldDomain.html#aeca7838c2107301943b31b3513a9af09" title="Set the split policy.">OGRFieldDomain::SetSplitPolicy()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
    <tr><td class="paramname">policy</td><td>the split policy of the field domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a4a15e130614cb4c66fc99bb93dc6b3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15e130614cb4c66fc99bb93dc6b3b5">&#9670;&nbsp;</a></span>OGR_G_AddGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_AddGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hNewSubGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a geometry to a geometry container. </p>
<p>Some subclasses of <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects.">OGRGeometryCollection</a> restrict the types of geometry that can be added, and may return an error. The passed geometry is cloned to make an internal copy.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#a3da519655d14346e591d22a547562b0c" title="Add a geometry to the container.">OGRGeometryCollection::addGeometry</a>.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>existing geometry container. </td></tr>
    <tr><td class="paramname">hNewSubGeom</td><td>geometry to add to the container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of existing geometry. </dd></dl>

</div>
</div>
<a id="aff56cae8305396a9c5b690d8356e39c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56cae8305396a9c5b690d8356e39c9">&#9670;&nbsp;</a></span>OGR_G_AddGeometryDirectly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_AddGeometryDirectly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hNewSubGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a geometry directly to an existing geometry container. </p>
<p>Some subclasses of <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects.">OGRGeometryCollection</a> restrict the types of geometry that can be added, and may return an error. Ownership of the passed geometry is taken by the container rather than cloning as addGeometry() does.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#a8422907a01d088ec5ef916382bea8eb3" title="Add a geometry directly to the container.">OGRGeometryCollection::addGeometryDirectly</a>.</p>
<p>There is no SFCOM analog to this method.</p>
<p>For a polygon, hNewSubGeom must be a linearring. If the polygon is empty, the first added subgeometry will be the exterior ring. The next ones will be the interior rings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>existing geometry. </td></tr>
    <tr><td class="paramname">hNewSubGeom</td><td>geometry to add to the existing geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_UNSUPPORTED_GEOMETRY_TYPE if the geometry type is illegal for the type of geometry container. </dd></dl>

</div>
</div>
<a id="aa2702d812663bc767e3a8f8832fda089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2702d812663bc767e3a8f8832fda089">&#9670;&nbsp;</a></span>OGR_G_AddPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfZ</td><td>z coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a280275c1492d6426cfe0a918d4725374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280275c1492d6426cfe0a918d4725374">&#9670;&nbsp;</a></span>OGR_G_AddPoint_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPoint_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16370d0b3feb2505fa5f3a2acfffbf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16370d0b3feb2505fa5f3a2acfffbf17">&#9670;&nbsp;</a></span>OGR_G_AddPointM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPointM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfM</td><td>m coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf01e19ca7b9951a5201b345ea130325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf01e19ca7b9951a5201b345ea130325">&#9670;&nbsp;</a></span>OGR_G_AddPointZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AddPointZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a point to a geometry (line string or point). </p>
<p>The vertex count of the line string is increased by one, and assigned from the passed location value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a point to. </td></tr>
    <tr><td class="paramname">dfX</td><td>x coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfY</td><td>y coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfZ</td><td>z coordinate of point to add. </td></tr>
    <tr><td class="paramname">dfM</td><td>m coordinate of point to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c9ee71d0030dc30bdd595c37ab71062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9ee71d0030dc30bdd595c37ab71062">&#9670;&nbsp;</a></span>OGR_G_ApproximateArcAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ApproximateArcAngles </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfCenterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfPrimaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfSecondaryRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfStartAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfEndAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stroke arc to linestring. </p>
<p>Stroke an arc of a circle to a linestring based on a center point, radius, start angle and end angle, all angles in degrees.</p>
<p>If the dfMaxAngleStepSizeDegrees is zero, then a default value will be used. This is currently 4 degrees unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cpl__conv_8h.html#aa0cd1a68fe4f2fc7874cd2da605c36ce" title="Set a configuration option for GDAL/OGR use.">CPLSetConfigOption()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfCenterX</td><td>center X </td></tr>
    <tr><td class="paramname">dfCenterY</td><td>center Y </td></tr>
    <tr><td class="paramname">dfZ</td><td>center Z </td></tr>
    <tr><td class="paramname">dfPrimaryRadius</td><td>X radius of ellipse. </td></tr>
    <tr><td class="paramname">dfSecondaryRadius</td><td>Y radius of ellipse. </td></tr>
    <tr><td class="paramname">dfRotation</td><td>rotation of the ellipse clockwise. </td></tr>
    <tr><td class="paramname">dfStartAngle</td><td>angle to first point on arc (clockwise of X-positive) </td></tr>
    <tr><td class="paramname">dfEndAngle</td><td>angle to last point on arc (clockwise of X-positive) </td></tr>
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classOGRLineString.html" title="Concrete representation of a multi-vertex line.">OGRLineString</a> geometry representing an approximation of the arc.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a2a849c584cd22a199bcfb9b34b9a1a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a849c584cd22a199bcfb9b34b9a1a8f">&#9670;&nbsp;</a></span>OGR_G_Area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute geometry area. </p>
<p>The returned area is a 2D Cartesian (planar) area in square units of the spatial reference system in use, so potentially "square degrees" for a geometry expressed in a geographic SRS.</p>
<p>Computes the area for surfaces or closed curves. Undefined for all other geometry types (returns 0.0).</p>
<p>This function utilizes the C++ <a class="el" href="classOGRSurface.html#a3b2c3125ec8c0b3a986e43cd1056f9e4" title="Get the area of the surface object.">OGRSurface::get_Area()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area of the geometry in square units of the spatial reference system in use, or 0.0 for unsupported geometry types.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#aafc3e4fe81effd5f56368ce8756cd5f3" title="Compute geometry area, considered as a surface on the underlying ellipsoid of the SRS attached to the...">OGR_G_GeodesicArea()</a> for an alternative function returning areas computed on the ellipsoid, an in square meters.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a4dfbd5861e1cd20b372d090539fa4536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfbd5861e1cd20b372d090539fa4536">&#9670;&nbsp;</a></span>OGR_G_AssignSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_AssignSpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign spatial reference to this object. </p>
<p>Any existing spatial reference is replaced, but under no circumstances does this result in the object being reprojected. It is just changing the interpretation of the existing geometry. Note that assigning a spatial reference increments the reference count on the <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a>, but does not copy it.</p>
<p>Starting with GDAL 2.3, this will also assign the spatial reference to potential sub-geometries of the geometry (<a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects.">OGRGeometryCollection</a>, OGRCurvePolygon/OGRPolygon, <a class="el" href="classOGRCompoundCurve.html" title="Utility class to store a collection of curves.">OGRCompoundCurve</a>, <a class="el" href="classOGRPolyhedralSurface.html" title="PolyhedralSurface class.">OGRPolyhedralSurface</a> and their derived classes).</p>
<p>This is similar to the SFCOM IGeometry::put_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#af57de03effd32d0d09cbdc0ed146b508" title="Assign spatial reference to this object.">OGRGeometry::assignSpatialReference</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to apply the new spatial reference system. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle on the new spatial reference system to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95447f722f907b7143a1fc19005dd20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95447f722f907b7143a1fc19005dd20b">&#9670;&nbsp;</a></span>OGR_G_Boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute boundary. </p>
<p>A new geometry object is created and returned containing the boundary of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="ogr__api_8h.html#a95447f722f907b7143a1fc19005dd20b" title="Compute boundary.">OGR_G_Boundary()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to calculate the boundary of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a398ad99b74f10fe63cdf81d8674edfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398ad99b74f10fe63cdf81d8674edfc2">&#9670;&nbsp;</a></span>OGR_G_Buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nQuadSegs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>Some buffer sections are properly described as curves, but are converted to approximate polygons. The nQuadSegs parameter can be used to control how many segments should be used to define a 90 degree curve - a quadrant of a circle. A value of 30 is a reasonable default. Large values result in large numbers of vertices in the resulting buffer geometry while small numbers reduce the accuracy of the result.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a8694e757f44388bd6da4cf7be696b7e7" title="Compute buffer of geometry.">OGRGeometry::Buffer()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry.</td></tr>
    <tr><td class="paramname">nQuadSegs</td><td>the number of segments used to approximate a 90 degree (quadrant) of curvature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="aa6daaf8d57da28ab6c45b8a8b3094901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6daaf8d57da28ab6c45b8a8b3094901">&#9670;&nbsp;</a></span>OGR_G_BufferEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_BufferEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute buffer of geometry. </p>
<p>Builds a new geometry containing the buffer region around the geometry on which it is invoked. The buffer is a polygon containing the region within the buffer distance of the original geometry.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<p>The following options are supported. See the GEOS library for more detailed descriptions.</p>
<ul>
<li>
ENDCAP_STYLE=ROUND/FLAT/SQUARE </li>
<li>
JOIN_STYLE=ROUND/MITRE/BEVEL </li>
<li>
MITRE_LIMIT=double </li>
<li>
QUADRANT_SEGMENTS=double </li>
<li>
SINGLE_SIDED=YES/NO </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ac226d1821ce677689f1de12bbe6497b5" title="Compute buffer of geometry.">OGRGeometry::BufferEx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dfDist</td><td>the buffer distance to be applied. Should be expressed into the same unit as the coordinates of the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created geometry, or NULL if an error occurs. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.10 </dd></dl>

</div>
</div>
<a id="a23f5a19a81628af7f9cc59a37378cb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f5a19a81628af7f9cc59a37378cb2b">&#9670;&nbsp;</a></span>OGR_G_Centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Centroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hCentroidPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the geometry centroid. </p>
<p>The centroid location is applied to the passed in <a class="el" href="classOGRPoint.html" title="Point class.">OGRPoint</a> object. The centroid is not necessarily within the geometry.</p>
<p>This method relates to the SFCOM ISurface::get_Centroid() method however the current implementation based on GEOS can operate on other geometry types such as multipoint, linestring, geometrycollection such as multipolygons. OGC SF SQL 1.1 defines the operation for surfaces (polygons). SQL/MM-Part 3 defines the operation for surfaces and multisurfaces (multipolygons).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a91787f669b2a148169667e270e7e40df" title="Compute the geometry centroid.">OGRGeometry::Centroid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or OGRERR_FAILURE on error. </dd></dl>

</div>
</div>
<a id="a1725918932da7d59f9ee72829ac171fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1725918932da7d59f9ee72829ac171fa">&#9670;&nbsp;</a></span>OGR_G_Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a copy of this object. </p>
<p>This function relates to the SFCOM IGeometry::clone() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#af4cf9f6eee1997268a481b39401c3161" title="Make a copy of this object.">OGRGeometry::clone()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to clone from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle on the copy of the geometry with the spatial reference system as the original. </dd></dl>

</div>
</div>
<a id="acfeb849dcfd4fdf4d6dab66e6ea697c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeb849dcfd4fdf4d6dab66e6ea697c0">&#9670;&nbsp;</a></span>OGR_G_CloseRings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_CloseRings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force rings to be closed. </p>
<p>If this geometry, or any contained geometries has polygon rings that are not closed, they will be closed by adding the starting point at the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32f11850c5ed2f86b99e4682178c6797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f11850c5ed2f86b99e4682178c6797">&#9670;&nbsp;</a></span>OGR_G_ConcaveHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ConcaveHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfRatio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowHoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute "concave hull" of a geometry. </p>
<p>The concave hull is fully contained within the convex hull and also contains all the points of the input, but in a smaller area. The area ratio is the ratio of the area of the convex hull and the concave hull. Frequently used to convert a multi-point into a polygonal area. that contains all the points in the input Geometry.</p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the function is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a4eebda9322568a50da1cb8bb2bcf0a9e" title="Compute &quot;concave hull&quot; of a geometry.">OGRGeometry::ConcaveHull()</a>.</p>
<p>This function is built on the GEOS &gt;= 3.11 library If OGR is built without the GEOS &gt;= 3.11 librray, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to calculate the concave hull of. </td></tr>
    <tr><td class="paramname">dfRatio</td><td>Ratio of the area of the convex hull and the concave hull. </td></tr>
    <tr><td class="paramname">bAllowHoles</td><td>Whether holes are allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="ad87e37380f0320faddbe5e67e23312f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87e37380f0320faddbe5e67e23312f8">&#9670;&nbsp;</a></span>OGR_G_Contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if this geometry contains the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ae818178178f80c2987c6173ab4da041e" title="Test for containment.">OGRGeometry::Contains()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if hThis contains hOther geometry, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a7a93026cfae8ee6ce25546dba1b2df7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a93026cfae8ee6ce25546dba1b2df7d">&#9670;&nbsp;</a></span>OGR_G_ConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ConvexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute convex hull. </p>
<p>A new geometry object is created and returned containing the convex hull of the geometry on which the method is invoked.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a83020c007c4f3beabe1e01edba173135" title="Compute convex hull.">OGRGeometry::ConvexHull()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to calculate the convex hull of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ac4843a200c0c4e57bbdc99e509f68baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4843a200c0c4e57bbdc99e509f68baf">&#9670;&nbsp;</a></span>OGR_G_CoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_CoordinateDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this geometry. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a35c4f4d75ec84fa225a9a4dee0a609c1" title="Get the dimension of the coordinates in this object.">OGRGeometry::CoordinateDimension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the dimension of the coordinates from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a3ab486f7ab98a4b592d25e4b8a0ac698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab486f7ab98a4b592d25e4b8a0ac698">&#9670;&nbsp;</a></span>OGR_G_CreateFromFgf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromFgf </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBytesConsumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representation. </p>
<p>See <a class="el" href="classOGRGeometryFactory.html#a99be8486694e4b99384c38aab094ebdc" title="Create a geometry object of the appropriate type from its FGF (FDO Geometry Format) binary representa...">OGRGeometryFactory::createFromFgf()</a> </p>

</div>
</div>
<a id="aef37aa4d89f303fee679f97d32461d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef37aa4d89f303fee679f97d32461d69">&#9670;&nbsp;</a></span>OGR_G_CreateFromGML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_CreateFromGML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszGML</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create geometry from GML. </p>
<p>This method translates a fragment of GML containing only the geometry portion into a corresponding <a class="el" href="classOGRGeometry.html" title="Abstract base class for all geometry classes.">OGRGeometry</a>. There are many limitations on the forms of GML geometries supported by this parser, but they are too numerous to list here.</p>
<p>The following GML2 elements are parsed : Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, MultiGeometry.</p>
<p>The following GML3 elements are parsed : Surface, MultiSurface, PolygonPatch, Triangle, Rectangle, Curve, MultiCurve, CompositeCurve, LineStringSegment, Arc, Circle, CompositeSurface, OrientableSurface, Solid, Tin, TriangulatedSurface.</p>
<p>Arc and Circle elements are returned as curves by default. Stroking to linestrings can be done with OGR_G_ForceTo(hGeom, OGR_GT_GetLinear(OGR_G_GetGeometryType(hGeom)), NULL). A 4 degrees step is used by default, unless the user has overridden the value with the OGR_ARC_STEPSIZE configuration variable.</p>
<p>The C++ method <a class="el" href="classOGRGeometryFactory.html#af8714df4e6b6c5d5b2cdbdeec78af08c" title="Create geometry from GML.">OGRGeometryFactory::createFromGML()</a> is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszGML</td><td>The GML fragment for the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a geometry on success, or NULL on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a4e5f995d159279739909196d45ba09e5" title="Convert to another geometry type.">OGR_G_ForceTo()</a> </dd>
<dd>
<a class="el" href="ogr__core_8h.html#a510e29430cffef63b0b12a5d40db59e8" title="Returns the non-curve geometry type that can contain the passed geometry type.">OGR_GT_GetLinear()</a> </dd>
<dd>
<a class="el" href="ogr__api_8h.html#a8fae58102f5c4a4cf2526e5ca8369a76" title="Fetch geometry type.">OGR_G_GetGeometryType()</a> </dd></dl>

</div>
</div>
<a id="a65af51cbb3d62789dee6f96044f4dcb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65af51cbb3d62789dee6f96044f4dcb6">&#9670;&nbsp;</a></span>OGR_G_CreateFromWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromWkb </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a795f00bea3e1d8e84cd2ba3e78cb16d2" title="Create a geometry object of the appropriate type from its well known binary representation.">OGRGeometryFactory::createFromWkb()</a> CPP method is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">phGeometry</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL in case of failure. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a6c2f1b68f3dee366c2387e1fc9b32700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2f1b68f3dee366c2387e1fc9b32700">&#9670;&nbsp;</a></span>OGR_G_CreateFromWkbEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromWkbEx </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known binary representation. </p>
<p>Note that if nBytes is passed as zero, no checking can be done on whether the pabyData is sufficient. This can result in a crash if the input data is corrupt. This function returns no indication of the number of bytes from the data source actually used to represent the returned geometry object. Use <a class="el" href="ogr__api_8h.html#a39db2efdc712cb6b3f15d45905e6f712" title="Returns size of related binary representation.">OGR_G_WkbSizeEx()</a> on the returned geometry to establish the number of bytes it required in WKB format.</p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a795f00bea3e1d8e84cd2ba3e78cb16d2" title="Create a geometry object of the appropriate type from its well known binary representation.">OGRGeometryFactory::createFromWkb()</a> CPP method is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pabyData</td><td>pointer to the input BLOB data. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">phGeometry</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL in case of failure. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use. </td></tr>
    <tr><td class="paramname">nBytes</td><td>the number of bytes of data available in pabyData, or -1 if it is not known, but assumed to be sufficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="ac02c3ed5f7ebd5039dc2ae70154fd94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02c3ed5f7ebd5039dc2ae70154fd94a">&#9670;&nbsp;</a></span>OGR_G_CreateFromWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_CreateFromWkt </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> *&#160;</td>
          <td class="paramname"><em>phGeometry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry object of the appropriate type from its well known text representation. </p>
<p>The <a class="el" href="classOGRGeometryFactory.html#a4dc0e1a8308b51eab6d665a1535cdb00" title="Create a geometry object of the appropriate type from its well known text representation.">OGRGeometryFactory::createFromWkt</a> CPP method is the same as this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppszData</td><td>input zero terminated string containing well known text representation of the geometry to be created. The pointer is updated to point just beyond that last character consumed. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle to the spatial reference to be assigned to the created geometry object. This may be NULL. </td></tr>
    <tr><td class="paramname">phGeometry</td><td>the newly created geometry object will be assigned to the indicated handle on return. This will be NULL if the method fails. If not NULL, *phGeometry should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a4e47710cf70e5bc72216704ddfead0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e47710cf70e5bc72216704ddfead0dd">&#9670;&nbsp;</a></span>OGR_G_CreateGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_CreateGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eGeometryType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty geometry of desired type. </p>
<p>This is equivalent to allocating the desired geometry with new, but the allocation is guaranteed to take place in the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryFactory.html#ae4887e270d5099357f9a19b1eda6027a" title="Create an empty geometry of desired type.">OGRGeometryFactory::createGeometry</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eGeometryType</td><td>the type code of the geometry to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the newly create geometry or NULL on failure. Should be freed with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> after use. </dd></dl>

</div>
</div>
<a id="a7af82e14406879c08841331b2a4cfe7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af82e14406879c08841331b2a4cfe7c">&#9670;&nbsp;</a></span>OGR_G_Crosses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Crosses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for crossing. </p>
<p>Tests if this geometry and the other geometry are crossing.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#adf30cb59307e8d5889e9fcf71d371afb" title="Test for crossing.">OGRGeometry::Crosses()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are crossing, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="acf65b24716b3538cb883de3fa0d35a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf65b24716b3538cb883de3fa0d35a8a">&#9670;&nbsp;</a></span>OGR_G_DelaunayTriangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_DelaunayTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bOnlyEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a Delaunay triangulation of the vertices of the geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a45b0d68bea79509e675bd773c30eb350" title="Return a Delaunay triangulation of the vertices of the geometry.">OGRGeometry::DelaunayTriangulation()</a>.</p>
<p>This function is built on the GEOS library, v3.4 or above. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dfTolerance</td><td>optional snapping tolerance to use for improved robustness </td></tr>
    <tr><td class="paramname">bOnlyEdges</td><td>if TRUE, will return a MULTILINESTRING, otherwise it will return a GEOMETRYCOLLECTION containing triangular POLYGONs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry resulting from the Delaunay triangulation or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.1 </dd></dl>

</div>
</div>
<a id="ac4e665f5f9690c4fa0c190b930fe9492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e665f5f9690c4fa0c190b930fe9492">&#9670;&nbsp;</a></span>OGR_G_DestroyGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_DestroyGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy geometry object. </p>
<p>Equivalent to invoking delete on a geometry, but it guaranteed to take place within the context of the GDAL/OGR heap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryFactory.html#aae001086e26985d95c36ccd255a8c6d5" title="Destroy geometry object.">OGRGeometryFactory::destroyGeometry</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a497977bec6ecd9dade7a9694f776be64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497977bec6ecd9dade7a9694f776be64">&#9670;&nbsp;</a></span>OGR_G_Difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Difference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute difference. </p>
<p>Generates a new geometry which is the region of this geometry with the region of the other geometry removed.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a6f49d7599f955e3d459c4dd13bbf1f9e" title="Compute difference.">OGRGeometry::Difference()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the difference or NULL if the difference is empty or an error occurs. </dd></dl>

</div>
</div>
<a id="a7980d65f3d82d5a5442c5141efe3f503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7980d65f3d82d5a5442c5141efe3f503">&#9670;&nbsp;</a></span>OGR_G_Disjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Disjoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for disjointness. </p>
<p>Tests if this geometry and the other geometry are disjoint.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#aaa4f0b34b165b589ffbef7d3ea65c00c" title="Test for disjointness.">OGRGeometry::Disjoint()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are disjoint, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ab01002a9fd4175832af965930f069401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01002a9fd4175832af965930f069401">&#9670;&nbsp;</a></span>OGR_G_Distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute distance between two geometries. </p>
<p>Returns the shortest distance between the two geometries. The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a72e832f8dc1001de35e9e888a4bae8b3" title="Compute distance between two geometries.">OGRGeometry::Distance()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFirst</td><td>the first geometry to compare against. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a7313a805a15bf78a26c52ff1bc6242e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7313a805a15bf78a26c52ff1bc6242e2">&#9670;&nbsp;</a></span>OGR_G_Distance3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Distance3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3D distance between two geometries. </p>
<p>The distance is expressed into the same unit as the coordinates of the geometries.</p>
<p>This method is built on the SFCGAL library, check it for the definition of the geometry operation. If OGR is built without the SFCGAL library, this method will always return -1.0</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#aa2e39301afc475f5fff022af690fcf84" title="Returns the 3D distance between two geometries.">OGRGeometry::Distance3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFirst</td><td>the first geometry to compare against. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>distance between the two geometries </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the distance between the geometries or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a3a99330bd108940f8a33036c0f83119f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a99330bd108940f8a33036c0f83119f">&#9670;&nbsp;</a></span>OGR_G_DumpReadable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_DumpReadable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszPrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump geometry in well known text format to indicated output file. </p>
<p>This method is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae8836b9e2d6a79eee8f88c61718e1e50" title="Dump geometry in well known text format to indicated output file.">OGRGeometry::dumpReadable</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to dump. </td></tr>
    <tr><td class="paramname">fp</td><td>the text file to write the geometry to. </td></tr>
    <tr><td class="paramname">pszPrefix</td><td>the prefix to put on each line of output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90cc83b0a3052b8fbe2ed77a86323bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cc83b0a3052b8fbe2ed77a86323bf2">&#9670;&nbsp;</a></span>OGR_G_Empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear geometry information. </p>
<p>This restores the geometry to its initial state after construction, and before assignment of actual geometry.</p>
<p>This function relates to the SFCOM IGeometry::Empty() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a1702b5b8142abe761061a6cd44e50b05" title="Clear geometry information.">OGRGeometry::empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaed0c4fb6f08abc280f91619e2e47d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaed0c4fb6f08abc280f91619e2e47d3">&#9670;&nbsp;</a></span>OGR_G_Equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if two geometries are equivalent. </p>
<p>This operation implements the SQL/MM ST_OrderingEquals() operation.</p>
<p>The comparison is done in a structural way, that is to say that the geometry types must be identical, as well as the number and ordering of sub-geometries and vertices. Or equivalently, two geometries are considered equal by this method if their WKT/WKB representation is equal. Note: this must be distinguished for equality in a spatial way (which is the purpose of the ST_Equals() operation).</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a1b80c7f464de1d332215f16d35138590" title="Returns TRUE if two geometries are equivalent.">OGRGeometry::Equals()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the first geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>handle on the other geometry to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if equivalent or FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a3c473bd75c553d2bbae1aed480f8c34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c473bd75c553d2bbae1aed480f8c34d">&#9670;&nbsp;</a></span>OGR_G_ExportToGML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToGML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2" title="Convert a geometry into GML format.">OGRGeometry::exportToGML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="a06fc1cec4a17a2926640f95c6bf7a442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fc1cec4a17a2926640f95c6bf7a442">&#9670;&nbsp;</a></span>OGR_G_ExportToGMLEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToGMLEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GML format. </p>
<p>The GML geometry is expressed directly in terms of GML basic data types assuming the this is available in the gml namespace. The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>The supported options are : </p><ul>
<li>
FORMAT=GML2/GML3/GML32 (GML2 or GML32 added in GDAL 2.1). If not set, it will default to GML 2.1.2 output.  </li>
<li>
GML3_LINESTRING_ELEMENT=curve. (Only valid for FORMAT=GML3) To use gml:Curve element for linestrings. Otherwise gml:LineString will be used .  </li>
<li>
GML3_LONGSRS=YES/NO. (Only valid for FORMAT=GML3, deprecated by SRSNAME_FORMAT in GDAL &gt;=2.2). Defaults to YES. If YES, SRS with EPSG authority will be written with the "urn:ogc:def:crs:EPSG::" prefix. In the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it. If set to NO, SRS with EPSG authority will be written with the "EPSG:" prefix, even if they are in lat/long order.  </li>
<li>
SRSNAME_FORMAT=SHORT/OGC_URN/OGC_URL (Only valid for FORMAT=GML3, added in GDAL 2.2). Defaults to OGC_URN. If SHORT, then srsName will be in the form AUTHORITY_NAME:AUTHORITY_CODE. If OGC_URN, then srsName will be in the form urn:ogc:def:crs:AUTHORITY_NAME::AUTHORITY_CODE. If OGC_URL, then srsName will be in the form <a href="http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE">http://www.opengis.net/def/crs/AUTHORITY_NAME/0/AUTHORITY_CODE</a>. For OGC_URN and OGC_URL, in the case the SRS should be treated as lat/long or northing/easting, then the function will take care of coordinate order swapping if the data axis to CRS axis mapping indicates it.  </li>
<li>
GMLID=astring. If specified, a gml:id attribute will be written in the top-level geometry element with the provided value. Required for GML 3.2 compatibility.  </li>
<li>
SRSDIMENSION_LOC=POSLIST/GEOMETRY/GEOMETRY,POSLIST. (Only valid for FORMAT=GML3/GML32, GDAL &gt;= 2.0) Default to POSLIST. For 2.5D geometries, define the location where to attach the srsDimension attribute. There are diverging implementations. Some put in on the &lt;gml:posList&gt; element, other on the top geometry element.  </li>
<li>
NAMESPACE_DECL=YES/NO. If set to YES, xmlns:gml="http://www.opengis.net/gml" will be added to the root node for GML &lt; 3.2 or xmlns:gml="http://www.opengis.net/gml/3.2" for GML 3.2  </li>
<li>
XY_COORD_RESOLUTION=double (added in GDAL 3.9): Resolution for the coordinate precision of the X and Y coordinates. Expressed in the units of the X and Y axis of the SRS. eg 1e-5 for up to 5 decimal digits. 0 for the default behavior.  </li>
<li>
Z_COORD_RESOLUTION=double (added in GDAL 3.9): Resolution for the coordinate precision of the Z coordinates. Expressed in the units of the Z axis of the SRS. 0 for the default behavior.  </li>
</ul>
<p>Note that curve geometries like CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE are not supported in GML 2.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#abbd63002f416db1ea0eb24857b5ef9f2" title="Convert a geometry into GML format.">OGRGeometry::exportToGML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GML fragment or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a622a18776e6d51515d0f2ff0ee211d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622a18776e6d51515d0f2ff0ee211d91">&#9670;&nbsp;</a></span>OGR_G_ExportToIsoWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToIsoWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method. It exports the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkb(OGRwkbByteOrder, unsigned char *, OGRwkbVariant) with eWkbVariant = wkbVariantIso.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a well know binary data from. </td></tr>
    <tr><td class="paramname">eOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> byte in size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a0d988d220539479601e1a80a58864d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d988d220539479601e1a80a58864d1e">&#9670;&nbsp;</a></span>OGR_G_ExportToIsoWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToIsoWkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszSrcText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method. It exports the SFSQL 1.2 and ISO SQL/MM Part 3 extended dimension (Z&amp;M) WKB types.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkt(wkbVariantIso).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a text format from. </td></tr>
    <tr><td class="paramname">ppszSrcText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a9ebd5fa6a9b67ff6ce5a7e4cd0238a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ebd5fa6a9b67ff6ce5a7e4cd0238a47">&#9670;&nbsp;</a></span>OGR_G_ExportToJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToJson </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#af39899a5c670d2475281cbf5adf8fa97" title="Convert a geometry into GeoJSON format.">OGRGeometry::exportToJson()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="a97f1713300ac83c3cf31f40b419b9c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f1713300ac83c3cf31f40b419b9c0d">&#9670;&nbsp;</a></span>OGR_G_ExportToJsonEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToJsonEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into GeoJSON format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>The following options are supported : </p><ul>
<li>
COORDINATE_PRECISION=number: maximum number of figures after decimal separator to write in coordinates. </li>
<li>
XY_COORD_PRECISION=integer: number of decimal figures for X,Y coordinates (added in GDAL 3.9) </li>
<li>
Z_COORD_PRECISION=integer: number of decimal figures for Z coordinates (added in GDAL 3.9) </li>
<li>
SIGNIFICANT_FIGURES=number: maximum number of significant figures (GDAL &gt;= 2.1). </li>
</ul>
<p>If XY_COORD_PRECISION or Z_COORD_PRECISION is specified, COORDINATE_PRECISION or SIGNIFICANT_FIGURES will be ignored if specified. If COORDINATE_PRECISION is defined, SIGNIFICANT_FIGURES will be ignored if specified. When none are defined, the default is COORDINATE_PRECISION=15.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#af39899a5c670d2475281cbf5adf8fa97" title="Convert a geometry into GeoJSON format.">OGRGeometry::exportToJson()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>a null terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GeoJSON fragment or NULL in case of error.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a27b1389e05c84261a7b612aefedd0ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b1389e05c84261a7b612aefedd0ed3">&#9670;&nbsp;</a></span>OGR_G_ExportToKML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* OGR_G_ExportToKML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszAltitudeMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into KML format. </p>
<p>The returned string should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a> when no longer required.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeometry.html#ab73487475ea43a2e677fe0556bf738e0" title="Convert a geometry into KML format.">OGRGeometry::exportToKML()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeometry</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">pszAltitudeMode</td><td>value to write in altitudeMode element, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A KML fragment or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ad5c94ae76c09774dba8725c24daeefd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c94ae76c09774dba8725c24daeefd6">&#9670;&nbsp;</a></span>OGR_G_ExportToWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>For backward compatibility purposes, it exports the Old-style 99-402 extended dimension (Z) WKB types for types Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For other geometry types, it is equivalent to <a class="el" href="ogr__api_8h.html#a622a18776e6d51515d0f2ff0ee211d91" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known binary format.">OGR_G_ExportToIsoWkb()</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#abf4bcfa2fd949bf8c889a1b128a6dbb5" title="Convert a geometry into well known binary format.">OGRGeometry::exportToWkb</a>(OGRwkbByteOrder, unsigned char *, OGRwkbVariant) with eWkbVariant = wkbVariantOldOgc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a well know binary data from. </td></tr>
    <tr><td class="paramname">eOrder</td><td>One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively. </td></tr>
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> byte in size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="ae18ca8de10fb5fc90705d4e91791566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18ca8de10fb5fc90705d4e91791566f">&#9670;&nbsp;</a></span>OGR_G_ExportToWkbEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToWkbEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pabyDstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into well known binary format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKB() method.</p>
<p>This function is the same as the CPP method OGRGeometry::exportToWkb(unsigned char *, const OGRwkbExportOptions*)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a well know binary data from. </td></tr>
    <tr><td class="paramname">pabyDstBuffer</td><td>a buffer into which the binary representation is written. This buffer must be at least <a class="el" href="ogr__api_8h.html#a5f7035a933b957a9d453184c154c237c" title="Returns size of related binary representation.">OGR_G_WkbSize()</a> byte in size. </td></tr>
    <tr><td class="paramname">psOptions</td><td>WKB export options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a3bc9310302e2dbfaab1690de9e2fd2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc9310302e2dbfaab1690de9e2fd2fb">&#9670;&nbsp;</a></span>OGR_G_ExportToWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ExportToWkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszSrcText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a geometry into well known text format. </p>
<p>This function relates to the SFCOM IWks::ExportToWKT() method.</p>
<p>For backward compatibility purposes, it exports the Old-style 99-402 extended dimension (Z) WKB types for types Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection. For other geometry types, it is equivalent to <a class="el" href="ogr__api_8h.html#a0d988d220539479601e1a80a58864d1e" title="Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text format.">OGR_G_ExportToIsoWkt()</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ad17cfebfd9826a22763dff6280ba196e" title="Convert a geometry into well known text format.">OGRGeometry::exportToWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert to a text format from. </td></tr>
    <tr><td class="paramname">ppszSrcText</td><td>a text buffer is allocated by the program, and assigned to the passed pointer. After use, *ppszDstText should be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Currently OGRERR_NONE is always returned. </dd></dl>

</div>
</div>
<a id="afdb7354b55c7448b60b44cd9e36073b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb7354b55c7448b60b44cd9e36073b8">&#9670;&nbsp;</a></span>OGR_G_FlattenTo2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_FlattenTo2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert geometry to strictly 2D. </p>
<p>In a sense this converts all Z coordinates to 0.0.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aaae1a2ced937a5900b2bfeb717bad6c9" title="Convert geometry to strictly 2D.">OGRGeometry::flattenTo2D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5f995d159279739909196d45ba09e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5f995d159279739909196d45ba09e5">&#9670;&nbsp;</a></span>OGR_G_ForceTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eTargetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to another geometry type. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a26120382ccfec8ac4b5f932dd3a67c5f" title="Convert to another geometry type.">OGRGeometryFactory::forceTo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the input geometry - ownership is passed to the method. </td></tr>
    <tr><td class="paramname">eTargetType</td><td>target output geometry type. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a670481ed69704f2be0c2c24a304d3bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670481ed69704f2be0c2c24a304d3bf5">&#9670;&nbsp;</a></span>OGR_G_ForceToLineString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to line string. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#adcae79ea28620e332a3d1df87f1180f3" title="Convert to line string.">OGRGeometryFactory::forceToLineString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.10.0 </dd></dl>

</div>
</div>
<a id="ac3d8424596b90664b7280a9e7c89dc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d8424596b90664b7280a9e7c89dc96">&#9670;&nbsp;</a></span>OGR_G_ForceToMultiLineString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToMultiLineString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to multilinestring. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a1c00a78cec110d71175726d6f26b1b39" title="Convert to multilinestring.">OGRGeometryFactory::forceToMultiLineString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="aedd1952b5cde54253746d9da1a2b0500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd1952b5cde54253746d9da1a2b0500">&#9670;&nbsp;</a></span>OGR_G_ForceToMultiPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToMultiPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to multipoint. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#aa97b7837101f6c56e476520d10a9f3c3" title="Convert to multipoint.">OGRGeometryFactory::forceToMultiPoint()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="abea3d494951ab99e72b59cbd5318e8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea3d494951ab99e72b59cbd5318e8c4">&#9670;&nbsp;</a></span>OGR_G_ForceToMultiPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToMultiPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to multipolygon. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a2a40032fa65cc71c028516bf8fc0df3e" title="Convert to multipolygon.">OGRGeometryFactory::forceToMultiPolygon()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="ac4d5e3d348db62e46ebba718edb36abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d5e3d348db62e46ebba718edb36abe">&#9670;&nbsp;</a></span>OGR_G_ForceToPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_ForceToPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to polygon. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#afd61936e41ea69831b3196e817658d08" title="Convert to polygon.">OGRGeometryFactory::forceToPolygon()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert (ownership surrendered). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted geometry (ownership to caller).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL/OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="aafc3e4fe81effd5f56368ce8756cd5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc3e4fe81effd5f56368ce8756cd5f3">&#9670;&nbsp;</a></span>OGR_G_GeodesicArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GeodesicArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute geometry area, considered as a surface on the underlying ellipsoid of the SRS attached to the geometry. </p>
<p>The returned area will always be in square meters, and assumes that polygon edges describe geodesic lines on the ellipsoid.</p>
<p>If the geometry' SRS is not a geographic one, geometries are reprojected to the underlying geographic SRS of the geometry' SRS. <a class="el" href="classOGRSpatialReference.html#a50a4542a228db455df2126e98a971d5d" title="Return the data axis to SRS axis mapping.">OGRSpatialReference::GetDataAxisToSRSAxisMapping()</a> is honored.</p>
<p>Computes the area for surfaces or closed curves. Undefined for all other geometry types (returns a negative value).</p>
<p>Note that geometries with circular arcs will be linearized in their original coordinate space first, so the resulting geodesic area will be an approximation.</p>
<p>This function utilizes the C++ <a class="el" href="classOGRSurface.html#a7ef99197393373bd09b745ae3818fb18" title="Get the area of the surface object, considered as a surface on the underlying ellipsoid of the SRS at...">OGRSurface::get_GeodesicArea()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the area, or a negative value in case of error (unsupported geometry type, no SRS attached, etc.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a2a849c584cd22a199bcfb9b34b9a1a8f" title="Compute geometry area.">OGR_G_Area()</a> for an alternative method returning areas computed in 2D Cartesian space.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 3.9.0 </dd></dl>

</div>
</div>
<a id="a8a5e78b0753339d1cdd282b0e151d28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5e78b0753339d1cdd282b0e151d28f">&#9670;&nbsp;</a></span>OGR_G_GetCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of the coordinates in this geometry. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a4a6fdd4df7c043558b5428d8f1c35b16" title="Get the dimension of the coordinates in this object.">OGRGeometry::getCoordinateDimension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the dimension of the coordinates from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>use <a class="el" href="ogr__api_8h.html#ac4843a200c0c4e57bbdc99e509f68baf" title="Get the dimension of the coordinates in this geometry.">OGR_G_CoordinateDimension()</a>, <a class="el" href="ogr__api_8h.html#af2d4c2fb8935e9ee9584f0243e4bd0ca" title="See whether this geometry has Z coordinates.">OGR_G_Is3D()</a>, or <a class="el" href="ogr__api_8h.html#a84a8bf231d721ac04ed465d5208bac6e" title="See whether this geometry is measured.">OGR_G_IsMeasured()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this will return 2 or 3. </dd></dl>

</div>
</div>
<a id="a21a8713301c4f28c30aa7bd034411402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a8713301c4f28c30aa7bd034411402">&#9670;&nbsp;</a></span>OGR_G_GetCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_GetCurveGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return curve version of this geometry. </p>
<p>Returns a geometry that has possibly CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by de-approximating linear into curve geometries.</p>
<p>If the geometry has no curve portion, the returned geometry will be a clone of it.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse function is <a class="el" href="ogr__api_8h.html#a540a6941c76bd4da7fdf2dca081d07e5" title="Return, possibly approximate, linear version of this geometry.">OGR_G_GetLinearGeometry()</a>.</p>
<p>This function is the same as C++ method <a class="el" href="classOGRGeometry.html#a1068398fd3af02de78bd2b9dbbb837f1" title="Return curve version of this geometry.">OGRGeometry::getCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings. Unused for now. Must be set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a94b633e1acd208c258ad49f8d4fd4104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b633e1acd208c258ad49f8d4fd4104">&#9670;&nbsp;</a></span>OGR_G_GetDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimension of this geometry. </p>
<p>This function corresponds to the SFCOM IGeometry::GetDimension() method. It indicates the dimension of the geometry, but does not indicate the dimension of the underlying space (as indicated by <a class="el" href="ogr__api_8h.html#a8a5e78b0753339d1cdd282b0e151d28f" title="Get the dimension of the coordinates in this geometry.">OGR_G_GetCoordinateDimension()</a> function).</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aadca09471fa9917452e087ba12d73eeb" title="Get the dimension of this object.">OGRGeometry::getDimension()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the dimension from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for points, 1 for lines and 2 for surfaces. </dd></dl>

</div>
</div>
<a id="a617a9c9ea85157661619a1d8f0a69cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617a9c9ea85157661619a1d8f0a69cf9">&#9670;&nbsp;</a></span>OGR_G_GetEnvelope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetEnvelope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGRGeometry::getEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle of the geometry to get envelope from. </td></tr>
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a950633ac824042b0afdb88c670c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a950633ac824042b0afdb88c670c5ce">&#9670;&nbsp;</a></span>OGR_G_GetEnvelope3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetEnvelope3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&#160;</td>
          <td class="paramname"><em>psEnvelope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the bounding envelope (3D) for this geometry in the passed psEnvelope structure. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa3d42b06ae6f7bbef6d1a2886da8d398" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGRGeometry::getEnvelope()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle of the geometry to get envelope from. </td></tr>
    <tr><td class="paramname">psEnvelope</td><td>the structure in which to place the results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a1fa07ddf969f97f6444de6ae5128d842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa07ddf969f97f6444de6ae5128d842">&#9670;&nbsp;</a></span>OGR_G_GetGeometryCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetGeometryCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the number of elements in a geometry or number of geometries in container. </p>
<p>Only geometries of type wkbPolygon[25D], wkbMultiPoint[25D], wkbMultiLineString[25D], wkbMultiPolygon[25D] or wkbGeometryCollection[25D] may return a valid value. Other geometry types will silently return 0.</p>
<p>For a polygon, the returned number is the number of rings (exterior ring + interior rings).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>single geometry or geometry container from which to get the number of elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements. </dd></dl>

</div>
</div>
<a id="a18121f835b2fb724a0c1a87beb1a437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18121f835b2fb724a0c1a87beb1a437a">&#9670;&nbsp;</a></span>OGR_G_GetGeometryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_G_GetGeometryName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch WKT name for geometry type. </p>
<p>There is no SFCOM analog to this function.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aba109e1c53ce1452942f85eae66d88b8" title="Fetch WKT name for geometry type.">OGRGeometry::getGeometryName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get name from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name used for this geometry type in well known text format. </dd></dl>

</div>
</div>
<a id="a6bac93150529a5c98811db29e289dd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bac93150529a5c98811db29e289dd66">&#9670;&nbsp;</a></span>OGR_G_GetGeometryRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_GetGeometryRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iSubGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry from a geometry container. </p>
<p>This function returns a handle to a geometry within the container. The returned geometry remains owned by the container, and should not be modified. The handle is only valid until the next change to the geometry container. Use <a class="el" href="ogr__api_8h.html#a1725918932da7d59f9ee72829ac171fa" title="Make a copy of this object.">OGR_G_Clone()</a> to make a copy.</p>
<p>This function relates to the SFCOM IGeometryCollection::get_Geometry() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#ad609f2c7886918a766dd3d3a4fa52ec3" title="Fetch geometry from container.">OGRGeometryCollection::getGeometryRef()</a>.</p>
<p>For a polygon, OGR_G_GetGeometryRef(iSubGeom) returns the exterior ring if iSubGeom == 0, and the interior rings for iSubGeom &gt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry container from which to get a geometry from. </td></tr>
    <tr><td class="paramname">iSubGeom</td><td>the index of the geometry to fetch, between 0 and getNumGeometries() - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the requested geometry. </dd></dl>

</div>
</div>
<a id="a8fae58102f5c4a4cf2526e5ca8369a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fae58102f5c4a4cf2526e5ca8369a76">&#9670;&nbsp;</a></span>OGR_G_GetGeometryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_G_GetGeometryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry type. </p>
<p>Note that the geometry type may include the 2.5D flag. To get a 2D flattened version of the geometry type apply the <a class="el" href="ogr__core_8h.html#a5d2800b1a2d4f4dbcb906390969bb823" title="Return the 2D geometry type corresponding to the specified geometry type.">wkbFlatten()</a> macro to the return result.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a5c6bca18682cb933e3227552d480e1a5" title="Fetch geometry type.">OGRGeometry::getGeometryType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry type code. </dd></dl>

</div>
</div>
<a id="a540a6941c76bd4da7fdf2dca081d07e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540a6941c76bd4da7fdf2dca081d07e5">&#9670;&nbsp;</a></span>OGR_G_GetLinearGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_GetLinearGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxAngleStepSizeDegrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return, possibly approximate, linear version of this geometry. </p>
<p>Returns a geometry that has no CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it, by approximating curve geometries.</p>
<p>The ownership of the returned geometry belongs to the caller.</p>
<p>The reverse function is <a class="el" href="ogr__api_8h.html#a21a8713301c4f28c30aa7bd034411402" title="Return curve version of this geometry.">OGR_G_GetCurveGeometry()</a>.</p>
<p>This method relates to the ISO SQL/MM Part 3 ICurve::CurveToLine() and CurvePolygon::CurvePolyToPoly() methods.</p>
<p>This function is the same as C++ method <a class="el" href="classOGRGeometry.html#ada1408cd0015a83b697eb27aebaf5480" title="Return, possibly approximate, non-curve version of this geometry.">OGRGeometry::getLinearGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
    <tr><td class="paramname">dfMaxAngleStepSizeDegrees</td><td>the largest step in degrees along the arc, zero to use the default setting. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>options as a null-terminated list of strings or NULL. See <a class="el" href="classOGRGeometryFactory.html#a6f661d6691fcf745ca185ae4d586156c" title="Converts an arc circle into an approximate line string.">OGRGeometryFactory::curveToLineString()</a> for valid options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a49fa1c4594aa103068870ef4b4ef094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fa1c4594aa103068870ef4b4ef094f">&#9670;&nbsp;</a></span>OGR_G_GetM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the m coordinate of a point from a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the M coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the M coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the M coordinate of this point. </dd></dl>

</div>
</div>
<a id="a67b897ffcd88a83832964c3735fa1dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b897ffcd88a83832964c3735fa1dcb">&#9670;&nbsp;</a></span>OGR_G_GetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a point in line string or a point geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">i</td><td>the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </td></tr>
    <tr><td class="paramname">pdfX</td><td>value of x coordinate. </td></tr>
    <tr><td class="paramname">pdfY</td><td>value of y coordinate. </td></tr>
    <tr><td class="paramname">pdfZ</td><td>value of z coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec43cbe83609bc7b43739d67858846c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec43cbe83609bc7b43739d67858846c1">&#9670;&nbsp;</a></span>OGR_G_GetPointCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPointCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch number of points from a Point or a LineString/LinearRing geometry. </p>
<p>Only wkbPoint[25D] or wkbLineString[25D] may return a valid value. Other geometry types will silently return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points. </dd></dl>

</div>
</div>
<a id="a6c22d91b27d7a42c225a7dfde28f09c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c22d91b27d7a42c225a7dfde28f09c4">&#9670;&nbsp;</a></span>OGR_G_GetPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutive elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">pabyX</td><td>a buffer of at least (sizeof(double) * nXStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td class="paramname">pabyY</td><td>a buffer of at least (sizeof(double) * nYStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td class="paramname">pabyZ</td><td>a buffer of at last size (sizeof(double) * nZStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pabyZ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a0ce63762b79f4d882e1498981a4c26ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce63762b79f4d882e1498981a4c26ba">&#9670;&nbsp;</a></span>OGR_G_GetPointsZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_GetPointsZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pabyM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all points of line string. </p>
<p>This method copies all points into user arrays. The user provides the stride between 2 consecutive elements of the array.</p>
<p>On some CPU architectures, care must be taken so that the arrays are properly aligned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">pabyX</td><td>a buffer of at least (nXStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td class="paramname">pabyY</td><td>a buffer of at least (nYStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td class="paramname">pabyZ</td><td>a buffer of at last size (nZStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pabyZ. </td></tr>
    <tr><td class="paramname">pabyM</td><td>a buffer of at last size (nMStride * nPointCount) bytes, may be NULL. </td></tr>
    <tr><td class="paramname">nMStride</td><td>the number of bytes between 2 elements of pabyM.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a362999cdf708959829209e9d885d923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362999cdf708959829209e9d885d923d">&#9670;&nbsp;</a></span>OGR_G_GetPointZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_GetPointZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pdfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a point in line string or a point geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the coordinates. </td></tr>
    <tr><td class="paramname">i</td><td>the vertex to fetch, from 0 to getNumPoints()-1, zero for a point. </td></tr>
    <tr><td class="paramname">pdfX</td><td>value of x coordinate. </td></tr>
    <tr><td class="paramname">pdfY</td><td>value of y coordinate. </td></tr>
    <tr><td class="paramname">pdfZ</td><td>value of z coordinate. </td></tr>
    <tr><td class="paramname">pdfM</td><td>value of m coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc393e40282eec3801fb4a4abc9e25bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc393e40282eec3801fb4a4abc9e25bf">&#9670;&nbsp;</a></span>OGR_G_GetSpatialReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGR_G_GetSpatialReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns spatial reference system for geometry. </p>
<p>This function relates to the SFCOM IGeometry::get_SpatialReference() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a66a53c103e37c6d1ead00d2d74586ddd" title="Returns spatial reference system for object.">OGRGeometry::getSpatialReference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get spatial reference from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the spatial reference geometry, which should not be modified. </dd></dl>

</div>
</div>
<a id="a354146161d0a087b63ab6e350bae4d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354146161d0a087b63ab6e350bae4d86">&#9670;&nbsp;</a></span>OGR_G_GetX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the x coordinate of a point from a Point or a LineString/LinearRing geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the x coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the x coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the X coordinate of this point. </dd></dl>

</div>
</div>
<a id="a8405350c9aea2ab7d0f759f0b09b926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8405350c9aea2ab7d0f759f0b09b926f">&#9670;&nbsp;</a></span>OGR_G_GetY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the x coordinate of a point from a Point or a LineString/LinearRing geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the y coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the Y coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Y coordinate of this point. </dd></dl>

</div>
</div>
<a id="a1d8c6aeb013325f33b8e642003fc17ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8c6aeb013325f33b8e642003fc17ad">&#9670;&nbsp;</a></span>OGR_G_GetZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_GetZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the z coordinate of a point from a Point or a LineString/LinearRing geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry from which to get the Z coordinate. </td></tr>
    <tr><td class="paramname">i</td><td>point to get the Z coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Z coordinate of this point. </dd></dl>

</div>
</div>
<a id="af4f8e7d05f06a1fe69ea9638085e5e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f8e7d05f06a1fe69ea9638085e5e26">&#9670;&nbsp;</a></span>OGR_G_HasCurveGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_HasCurveGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bLookForNonLinear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if this geometry is or has curve geometry. </p>
<p>Returns if a geometry is or has CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE or MULTISURFACE in it.</p>
<p>If bLookForNonLinear is set to TRUE, it will be actually looked if the geometry or its subgeometries are or contain a non-linear geometry in them. In which case, if the method returns TRUE, it means that <a class="el" href="ogr__api_8h.html#a540a6941c76bd4da7fdf2dca081d07e5" title="Return, possibly approximate, linear version of this geometry.">OGR_G_GetLinearGeometry()</a> would return an approximate version of the geometry. Otherwise, <a class="el" href="ogr__api_8h.html#a540a6941c76bd4da7fdf2dca081d07e5" title="Return, possibly approximate, linear version of this geometry.">OGR_G_GetLinearGeometry()</a> would do a conversion, but with just converting container type, like COMPOUNDCURVE -&gt; LINESTRING, MULTICURVE -&gt; MULTILINESTRING or MULTISURFACE -&gt; MULTIPOLYGON, resulting in a "loss-less" conversion.</p>
<p>This function is the same as C++ method <a class="el" href="classOGRGeometry.html#a15afb03f64091205af0530d8d1262798" title="Returns if this geometry is or has curve geometry.">OGRGeometry::hasCurveGeometry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
    <tr><td class="paramname">bLookForNonLinear</td><td>set it to TRUE to check if the geometry is or contains a CIRCULARSTRING. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if this geometry is or has curve geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ae523fe14c8c87dffcee706438ec2e81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae523fe14c8c87dffcee706438ec2e81f">&#9670;&nbsp;</a></span>OGR_G_ImportFromWkb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ImportFromWkb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign geometry from well known binary data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the binaries type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKB() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae2231c970e4075202cafb4f6a69e07e6" title="Assign geometry from well known binary data.">OGRGeometry::importFromWkb()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to assign the well know binary data to. </td></tr>
    <tr><td class="paramname">pabyData</td><td>the binary input data. </td></tr>
    <tr><td class="paramname">nSize</td><td>the size of pabyData in bytes, or -1 if not known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a4286ba243fb05a831a49f52aabcbc6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4286ba243fb05a831a49f52aabcbc6f8">&#9670;&nbsp;</a></span>OGR_G_ImportFromWkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_ImportFromWkt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszSrcText</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign geometry from well known text data. </p>
<p>The object must have already been instantiated as the correct derived type of geometry object to match the text type.</p>
<p>This function relates to the SFCOM IWks::ImportFromWKT() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#af1bb0f7cae630c31511766718bcc5b66" title="Assign geometry from well known text data.">OGRGeometry::importFromWkt()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to assign well know text data to. </td></tr>
    <tr><td class="paramname">ppszSrcText</td><td>pointer to a pointer to the source text. The pointer is updated to pointer after the consumed text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all goes well, otherwise any of OGRERR_NOT_ENOUGH_DATA, OGRERR_UNSUPPORTED_GEOMETRY_TYPE, or OGRERR_CORRUPT_DATA may be returned. </dd></dl>

</div>
</div>
<a id="a5a271b5c7b72994120e7a6bbc7e7e5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a271b5c7b72994120e7a6bbc7e7e5cb">&#9670;&nbsp;</a></span>OGR_G_Intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute intersection. </p>
<p>Generates a new geometry which is the region of intersection of the two geometries operated on. The <a class="el" href="ogr__api_8h.html#acaed6926b75cd33a42b284c10def6e87" title="Do these features intersect?">OGR_G_Intersects()</a> function can be used to test if two geometries intersect.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#ae2fc420ca5d995bfef55adb1819a31f2" title="Compute intersection.">OGRGeometry::Intersection()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the intersection or NULL if there is no intersection or an error occurs. </dd></dl>

</div>
</div>
<a id="acaed6926b75cd33a42b284c10def6e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaed6926b75cd33a42b284c10def6e87">&#9670;&nbsp;</a></span>OGR_G_Intersects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Intersects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOtherGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do these features intersect? </p>
<p>Determines whether two geometries intersect. If GEOS is enabled, then this is done in rigorous fashion otherwise TRUE is returned if the envelopes (bounding boxes) of the two geometries overlap.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a12b9bf1e607908703d68bcdd5a82440c" title="Do these features intersect?">OGRGeometry::Intersects</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the first geometry. </td></tr>
    <tr><td class="paramname">hOtherGeom</td><td>handle on the other geometry to test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometries intersect, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="af2d4c2fb8935e9ee9584f0243e4bd0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d4c2fb8935e9ee9584f0243e4bd0ca">&#9670;&nbsp;</a></span>OGR_G_Is3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Is3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See whether this geometry has Z coordinates. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#ae9867dbbd6b840ca9c9240c7cb9c3b8c">OGRGeometry::Is3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to check whether it has Z coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has Z coordinates. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a04a4e8c234bf9c2452363531d315e8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a4e8c234bf9c2452363531d315e8c9">&#9670;&nbsp;</a></span>OGR_G_IsClockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OGR_G_IsClockwise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the ring has clockwise winding (or less than 2 points) </p>
<p>Assumes that the ring is closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to a curve geometry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.8 </dd></dl>

</div>
</div>
<a id="a737b0c4d73928e7406d69c658209dbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737b0c4d73928e7406d69c658209dbbf">&#9670;&nbsp;</a></span>OGR_G_IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the geometry is empty. </p>
<p>This method is the same as the CPP method <a class="el" href="classOGRGeometry.html#ac8653ba97e53f3e3b041946ca2acc111" title="Returns TRUE (non-zero) if the object has no points.">OGRGeometry::IsEmpty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a84a8bf231d721ac04ed465d5208bac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a8bf231d721ac04ed465d5208bac6e">&#9670;&nbsp;</a></span>OGR_G_IsMeasured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See whether this geometry is measured. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a959d5776c17018e362b580b1e61e1caa">OGRGeometry::IsMeasured()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to check whether it is measured.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has M coordinates. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ab9e99b4792042aca861866cb29bdf826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e99b4792042aca861866cb29bdf826">&#9670;&nbsp;</a></span>OGR_G_IsRing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the geometry is a ring. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#afe3c69f5b89fa5eb0bfb03e4880822bf" title="Test if the geometry is a ring.">OGRGeometry::IsRing()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a3cb66472d7e302d16aacf0d66c01ac73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb66472d7e302d16aacf0d66c01ac73">&#9670;&nbsp;</a></span>OGR_G_IsSimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsSimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the geometry is simple. </p>
<p>Returns TRUE if the geometry has no anomalous geometric points, such as self intersection or self tangency. The description of each instantiable geometric class will include the specific conditions that cause an instance of that class to be classified as not simple.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#afe41ef903c94999a81a98c356b32e624" title="Test if the geometry is simple.">OGRGeometry::IsSimple()</a> method.</p>
<p>If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if object is simple, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a4df68924f3b41fd377c5b4aa6631a00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df68924f3b41fd377c5b4aa6631a00b">&#9670;&nbsp;</a></span>OGR_G_IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_IsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the geometry is valid. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a681c8b8f8136764fd689ffbce24085d3" title="Test if the geometry is valid.">OGRGeometry::IsValid()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the geometry has no points, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a5eb038c3271dbf41ac7ebc02fad3907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb038c3271dbf41ac7ebc02fad3907f">&#9670;&nbsp;</a></span>OGR_G_Length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_G_Length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute length of a geometry. </p>
<p>Computes the length for <a class="el" href="classOGRCurve.html" title="Abstract curve base class for OGRLineString, OGRCircularString and OGRCompoundCurve.">OGRCurve</a> or MultiCurve objects. Undefined for all other geometry types (returns zero).</p>
<p>This function utilizes the C++ get_Length() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length or 0.0 for unsupported geometry types.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a4e24b3b68c6fc20ed8a315451bd61514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e24b3b68c6fc20ed8a315451bd61514">&#9670;&nbsp;</a></span>OGR_G_MakeValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_MakeValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to make an invalid geometry valid without losing vertices. </p>
<p>Already-valid geometries are cloned without further intervention.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a700a2d4b1c719e1f65fa3009bfc04f78" title="Attempts to make an invalid geometry valid without losing vertices.">OGRGeometry::MakeValid()</a>.</p>
<p>This function is built on the GEOS &gt;= 3.8 library, check it for the definition of the geometry operation. If OGR is built without the GEOS &gt;= 3.8 library, this function will return a clone of the input geometry if it is valid, or NULL if it is invalid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to make valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.0 </dd></dl>

</div>
</div>
<a id="a3a819ea6e9634201501cc062f192c922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a819ea6e9634201501cc062f192c922">&#9670;&nbsp;</a></span>OGR_G_MakeValidEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_MakeValidEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to make an invalid geometry valid without losing vertices. </p>
<p>Already-valid geometries are cloned without further intervention.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a700a2d4b1c719e1f65fa3009bfc04f78" title="Attempts to make an invalid geometry valid without losing vertices.">OGRGeometry::MakeValid()</a>.</p>
<p>See documentation of that method for possible options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to make valid. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4 </dd></dl>

</div>
</div>
<a id="affbc131cab986a87e0db5b8b4dda91e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbc131cab986a87e0db5b8b4dda91e3">&#9670;&nbsp;</a></span>OGR_G_Normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to bring geometry into normalized/canonical form. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#aa518a2cafc2a2394bc3a5196fa7dd017" title="Attempts to bring geometry into normalized/canonical form.">OGRGeometry::Normalize()</a>.</p>
<p>This function is built on the GEOS library; check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>The Geometry to normalize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a07acfe1bef39cd2cd1ad4a5ec26f2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07acfe1bef39cd2cd1ad4a5ec26f2ceb">&#9670;&nbsp;</a></span>OGR_G_Overlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Overlaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for overlap. </p>
<p>Tests if this geometry and the other geometry overlap, that is their intersection has a non-zero area.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a432b89868f8094004467e8e9b51ad5ca" title="Test for overlap.">OGRGeometry::Overlaps()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are overlapping, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="af89dc63f138aee453cf8ff3e2b1c0833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89dc63f138aee453cf8ff3e2b1c0833">&#9670;&nbsp;</a></span>OGR_G_PointOnSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_PointOnSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a point guaranteed to lie on the surface. </p>
<p>This method relates to the SFCOM ISurface::get_PointOnSurface() method however the current implementation based on GEOS can operate on other geometry types than the types that are supported by SQL/MM-Part 3 : surfaces (polygons) and multisurfaces (multipolygons).</p>
<p>This method is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this method will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the geometry to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a point guaranteed to lie on the surface or NULL if an error occurred.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a673c6c4745d5092fb250ae5342bc1b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673c6c4745d5092fb250ae5342bc1b3b">&#9670;&nbsp;</a></span>OGR_G_Polygonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Polygonize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polygonizes a set of sparse edges. </p>
<p>A new geometry object is created and returned containing a collection of reassembled Polygons: NULL will be returned if the input collection doesn't corresponds to a MultiLinestring, or when reassembling Edges into Polygons is impossible due to topological inconsistencies.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a9f35edabf2e5d40a79f07f77d56a2459" title="Polygonizes a set of sparse edges.">OGRGeometry::Polygonize()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTarget</td><td>The Geometry to be polygonized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a newly allocated geometry now owned by the caller, or NULL on failure.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a54ea024bb659e48d3297404e53800237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ea024bb659e48d3297404e53800237">&#9670;&nbsp;</a></span>OGR_G_RemoveGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_RemoveGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a geometry from an exiting geometry container. </p>
<p>Removing a geometry will cause the geometry count to drop by one, and all "higher" geometries will shuffle down one in index.</p>
<p>There is no SFCOM analog to this method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometryCollection.html#ae37405203118eeb0430ef38668a385b7" title="Remove a geometry from the container.">OGRGeometryCollection::removeGeometry()</a> for geometry collections, <a class="el" href="classOGRCurvePolygon.html#af7fb46dfd0cd7eebe68555ac1b6da76f" title="Remove a geometry from the container.">OGRCurvePolygon::removeRing()</a> for polygons / curve polygons and <a class="el" href="classOGRPolyhedralSurface.html#afb16af941e5fc7d2758c033c490cac4b" title="Remove a geometry from the container.">OGRPolyhedralSurface::removeGeometry()</a> for polyhedral surfaces and TINs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>the existing geometry to delete from. </td></tr>
    <tr><td class="paramname">iGeom</td><td>the index of the geometry to delete. A value of -1 is a special flag meaning that all geometries should be removed.</td></tr>
    <tr><td class="paramname">bDelete</td><td>if TRUE the geometry will be destroyed, otherwise it will not. The default is TRUE as the existing geometry is considered to own the geometries in it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successful, or OGRERR_FAILURE if the index is out of range. </dd></dl>

</div>
</div>
<a id="ace05a6716d40b2f52fe929ab482ff3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace05a6716d40b2f52fe929ab482ff3bf">&#9670;&nbsp;</a></span>OGR_G_RemoveLowerDimensionSubGeoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_RemoveLowerDimensionSubGeoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove sub-geometries from a geometry collection that do not have the maximum topological dimensionality of the collection. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometryFactory.html#a9dda76280700944f813f6b4c8e7be7a0" title="Remove sub-geometries from a geometry collection that do not have the maximum topological dimensional...">OGRGeometryFactory::removeLowerDimensionSubGeoms()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1.0 </dd></dl>

</div>
</div>
<a id="ade9f08c8d63bc0e726cb20c201c86423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9f08c8d63bc0e726cb20c201c86423">&#9670;&nbsp;</a></span>OGR_G_Segmentize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Segmentize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the geometry such it has no segment longer then the given distance. </p>
<p>Interpolated points will have Z and M values (if needed) set to 0. Distance computation is performed in 2d only.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#a91685bd7c0bdd67cd073a8b4da3c06a5" title="Modify the geometry such it has no segment longer then the given distance.">OGRGeometry::segmentize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to segmentize </td></tr>
    <tr><td class="paramname">dfMaxLength</td><td>the maximum distance between 2 points after segmentization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13c109c8afc2c614f206f8f610c7c4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c109c8afc2c614f206f8f610c7c4be">&#9670;&nbsp;</a></span>OGR_G_Set3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_Set3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIs3D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add or remove the Z coordinate dimension. </p>
<p>This method adds or removes the explicit Z coordinate dimension. Removing the Z coordinate dimension of a geometry will remove any existing Z values. Adding the Z dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to set or unset the Z dimension. </td></tr>
    <tr><td class="paramname">bIs3D</td><td>Should the geometry have a Z dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="ac6bcad9553f488f7d8b6c8674cf7771c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bcad9553f488f7d8b6c8674cf7771c">&#9670;&nbsp;</a></span>OGR_G_SetCoordinateDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetCoordinateDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewDimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the coordinate dimension. </p>
<p>This method sets the explicit coordinate dimension. Setting the coordinate dimension of a geometry to 2 should zero out any existing Z values. Setting the dimension of a geometry collection, a compound curve, a polygon, etc. will affect the children geometries. This will also remove the M dimension if present before this call.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>use <a class="el" href="ogr__api_8h.html#a13c109c8afc2c614f206f8f610c7c4be" title="Add or remove the Z coordinate dimension.">OGR_G_Set3D()</a> or <a class="el" href="ogr__api_8h.html#a8840ed4e65bfbf50a6a52779305a78f6" title="Add or remove the M coordinate dimension.">OGR_G_SetMeasured()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to set the dimension of the coordinates. </td></tr>
    <tr><td class="paramname">nNewDimension</td><td>New coordinate dimension value, either 2 or 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8840ed4e65bfbf50a6a52779305a78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8840ed4e65bfbf50a6a52779305a78f6">&#9670;&nbsp;</a></span>OGR_G_SetMeasured()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetMeasured </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bIsMeasured</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add or remove the M coordinate dimension. </p>
<p>This method adds or removes the explicit M coordinate dimension. Removing the M coordinate dimension of a geometry will remove any existing M values. Adding the M dimension to a geometry collection, a compound curve, a polygon, etc. will affect the children geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to set or unset the M dimension. </td></tr>
    <tr><td class="paramname">bIsMeasured</td><td>Should the geometry have a M dimension, either TRUE or FALSE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.1 </dd></dl>

</div>
</div>
<a id="a303fb1a2a94363c15f9e61dc46b710e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303fb1a2a94363c15f9e61dc46b710e8">&#9670;&nbsp;</a></span>OGR_G_SetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
    <tr><td class="paramname">dfZ</td><td>input Z coordinate to assign (defaults to zero). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab14b9730d6f9fc829fe6be9bc2a5ec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14b9730d6f9fc829fe6be9bc2a5ec48">&#9670;&nbsp;</a></span>OGR_G_SetPoint_2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoint_2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4f7bff0d685b2713504bd89b14d0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4f7bff0d685b2713504bd89b14d0fc">&#9670;&nbsp;</a></span>OGR_G_SetPointCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNewPointCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of points in a geometry. </p>
<p>This method primary exists to preset the number of points in a linestring geometry before setPoint() is used to assign them to avoid reallocating the array larger with each call to addPoint().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry. </td></tr>
    <tr><td class="paramname">nNewPointCount</td><td>the new number of points for geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ce9b54d1e821bd020a7a6731d2f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ce9b54d1e821bd020a7a6731d2f529">&#9670;&nbsp;</a></span>OGR_G_SetPointM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
    <tr><td class="paramname">dfM</td><td>input M coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51438701454d7e86988efc62b25d6aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51438701454d7e86988efc62b25d6aeb">&#9670;&nbsp;</a></span>OGR_G_SetPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pabyZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to set the coordinates. </td></tr>
    <tr><td class="paramname">nPointsIn</td><td>number of points being passed in padfX and padfY. </td></tr>
    <tr><td class="paramname">pabyX</td><td>list of X coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pabyX. </td></tr>
    <tr><td class="paramname">pabyY</td><td>list of Y coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pabyY. </td></tr>
    <tr><td class="paramname">pabyZ</td><td>list of Z coordinates (double values) of points being assigned (defaults to NULL for 2D objects). </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pabyZ. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac54402dc365f496b29ad1f01261e4576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54402dc365f496b29ad1f01261e4576">&#9670;&nbsp;</a></span>OGR_G_SetPointsZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointsZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPointsIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nXStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nYStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nZStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nMStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign all points in a point or a line string geometry. </p>
<p>This method clear any existing points assigned to this geometry, and assigns a whole new set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to set the coordinates. </td></tr>
    <tr><td class="paramname">nPointsIn</td><td>number of points being passed in padfX and padfY. </td></tr>
    <tr><td class="paramname">pX</td><td>list of X coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nXStride</td><td>the number of bytes between 2 elements of pX. </td></tr>
    <tr><td class="paramname">pY</td><td>list of Y coordinates (double values) of points being assigned. </td></tr>
    <tr><td class="paramname">nYStride</td><td>the number of bytes between 2 elements of pY. </td></tr>
    <tr><td class="paramname">pZ</td><td>list of Z coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have Z coordinate). </td></tr>
    <tr><td class="paramname">nZStride</td><td>the number of bytes between 2 elements of pZ. </td></tr>
    <tr><td class="paramname">pM</td><td>list of M coordinates (double values) of points being assigned (if not NULL, upgrades the geometry to have M coordinate). </td></tr>
    <tr><td class="paramname">nMStride</td><td>the number of bytes between 2 elements of pM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a034b6b1bae3843345cbfc78e07fa7075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034b6b1bae3843345cbfc78e07fa7075">&#9670;&nbsp;</a></span>OGR_G_SetPointZM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SetPointZM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the location of a vertex in a point or linestring geometry. </p>
<p>If iPoint is larger than the number of existing points in the linestring, the point count will be increased to accommodate the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to add a vertex to. </td></tr>
    <tr><td class="paramname">i</td><td>the index of the vertex to assign (zero based) or zero for a point. </td></tr>
    <tr><td class="paramname">dfX</td><td>input X coordinate to assign. </td></tr>
    <tr><td class="paramname">dfY</td><td>input Y coordinate to assign. </td></tr>
    <tr><td class="paramname">dfZ</td><td>input Z coordinate to assign. </td></tr>
    <tr><td class="paramname">dfM</td><td>input M coordinate to assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90133f7d05c95ae681274cce4481c74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90133f7d05c95ae681274cce4481c74f">&#9670;&nbsp;</a></span>OGR_G_SetPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_SetPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfGridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the geometry's precision, rounding all its coordinates to the precision grid, and making sure the geometry is still valid. </p>
<p>This is a stronger version of roundCoordinates().</p>
<p>Note that at time of writing GEOS does no supported curve geometries. So currently if this function is called on such a geometry, OGR will first call getLinearGeometry() on the input and getCurveGeometry() on the output, but that it is unlikely to yield to the expected result.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a36db4751a05c870f180fde6f1a6d939c" title="Set the geometry&#39;s precision, rounding all its coordinates to the precision grid, and making sure the...">OGRGeometry::SetPrecision()</a>.</p>
<p>This function is built on the GEOSGeom_setPrecision_r() function of the GEOS library. Check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dfGridSize</td><td>size of the precision grid, or 0 for FLOATING precision. </td></tr>
    <tr><td class="paramname">nFlags</td><td>The bitwise OR of zero, one or several of OGR_GEOS_PREC_NO_TOPO and OGR_GEOS_PREC_KEEP_COLLAPSED</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a0453f97e9d4fc44e13787ad1a8439c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0453f97e9d4fc44e13787ad1a8439c0c">&#9670;&nbsp;</a></span>OGR_G_Simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a simplified geometry. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a40909bc6bc40b9aecfdae5cb70160eaa" title="Simplify the geometry.">OGRGeometry::Simplify()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a8e19e9cfa01744db6a2e8eee710611b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e19e9cfa01744db6a2e8eee710611b6">&#9670;&nbsp;</a></span>OGR_G_SimplifyPreserveTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_SimplifyPreserveTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the geometry while preserving topology. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a3951fc5d0043af5794dd08d738e0a1dc" title="Simplify the geometry while preserving topology.">OGRGeometry::SimplifyPreserveTopology()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">dTolerance</td><td>the distance tolerance for the simplification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplified geometry or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a4cacbe8ef1bbacdcee7ad7c3d74ed593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cacbe8ef1bbacdcee7ad7c3d74ed593">&#9670;&nbsp;</a></span>OGR_G_SwapXY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_G_SwapXY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap x and y coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>OGR 2.3.0 </dd></dl>

</div>
</div>
<a id="a2b047fca89d06a08a5c34f210c4c97d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b047fca89d06a08a5c34f210c4c97d5">&#9670;&nbsp;</a></span>OGR_G_SymDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_SymDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute symmetric difference. </p>
<p>Generates a new geometry which is the symmetric difference of this geometry and the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method OGRGeometry::SymmetricDifference().</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the symmetric difference or NULL if the difference is empty or an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a6f67616eb88f479eba50f9783c8494d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f67616eb88f479eba50f9783c8494d9">&#9670;&nbsp;</a></span>OGR_G_Touches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Touches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for touching. </p>
<p>Tests if this geometry and the other geometry are touching.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#abd1be78538ab56a7c16cfa65797eeb0c" title="Test for touching.">OGRGeometry::Touches()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if they are touching, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a59a5b3f954b11cfbf6e78807c28d6090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a5b3f954b11cfbf6e78807c28d6090">&#9670;&nbsp;</a></span>OGR_G_Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>&#160;</td>
          <td class="paramname"><em>hTransform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply arbitrary coordinate transformation to geometry. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>Note that this function does not require that the geometry already have a spatial reference system. It will be assumed that they can be treated as having the source spatial reference system of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> object, and the actual SRS of the geometry will be ignored. On successful completion the output <a class="el" href="classOGRSpatialReference.html" title="This class represents an OpenGIS Spatial Reference System, and contains methods for converting betwee...">OGRSpatialReference</a> of the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> will be assigned to the geometry.</p>
<p>This function only does reprojection on a point-by-point basis. It does not include advanced logic to deal with discontinuities at poles or antimeridian. For that, use the <a class="el" href="ogr__api_8h.html#a9d6c040db3eed60df29528eee8b67d1d" title="Create a geometry transformer.">OGR_GeomTransformer_Create()</a> and <a class="el" href="ogr__api_8h.html#a64b248b82b3898573f8b6ff6fb87d5d8" title="Transforms a geometry.">OGR_GeomTransformer_Transform()</a> functions.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#aa9e8bfb3c2129f25cf622660f734e1ba" title="Apply arbitrary coordinate transformation to geometry.">OGRGeometry::transform</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to apply the transform to. </td></tr>
    <tr><td class="paramname">hTransform</td><td>handle on the transformation to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a id="a43af4c2127cea0a5059692a62c0feb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43af4c2127cea0a5059692a62c0feb63">&#9670;&nbsp;</a></span>OGR_G_TransformTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_G_TransformTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform geometry to new spatial reference system. </p>
<p>This function will transform the coordinates of a geometry from their current spatial reference system to a new target spatial reference system. Normally this means reprojecting the vectors, but it could include datum shifts, and changes of units.</p>
<p>This function will only work if the geometry already has an assigned spatial reference system, and if it is transformable to the target coordinate system.</p>
<p>Because this function requires internal creation and initialization of an <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> object it is significantly more expensive to use this function to transform many geometries than it is to create the <a class="el" href="classOGRCoordinateTransformation.html" title="Interface for transforming between coordinate systems.">OGRCoordinateTransformation</a> in advance, and call transform() with that transformation. This function exists primarily for convenience when only transforming a single geometry.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#abc0ec206bcafdd27eef5ef455d366af3" title="Transform geometry to new spatial reference system.">OGRGeometry::transformTo</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to apply the transform to. </td></tr>
    <tr><td class="paramname">hSRS</td><td>handle on the spatial reference system to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, or an error code. </dd></dl>

</div>
</div>
<a id="ae4e284189448b23bc3dae1ad7ab54b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e284189448b23bc3dae1ad7ab54b50">&#9670;&nbsp;</a></span>OGR_G_UnaryUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_UnaryUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the union of all components of a single geometry. </p>
<p>Usually used to convert a collection into the smallest set of polygons that cover the same area.</p>
<p>See <a href="https://postgis.net/docs/ST_UnaryUnion.html">https://postgis.net/docs/ST_UnaryUnion.html</a> for more details.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a744223cab4361ffcdab949cebf27d5ad" title="Returns the union of all components of a single geometry.">OGRGeometry::UnaryUnion()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="af58f2cfbdb2497659d2eabea73d3b8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58f2cfbdb2497659d2eabea73d3b8a0">&#9670;&nbsp;</a></span>OGR_G_Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute union. </p>
<p>Generates a new geometry which is the region of union of the two geometries operated on.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a9e4f808adcccaedbecc29fe034d312dc" title="Compute union.">OGRGeometry::Union()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs. </dd></dl>

</div>
</div>
<a id="a2bb45d7d6ca9641be5f0773f1d60aa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb45d7d6ca9641be5f0773f1d60aa0f">&#9670;&nbsp;</a></span>OGR_G_UnionCascaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_UnionCascaded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute union using cascading. </p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>The input geometry must be a MultiPolygon.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a94533c5ac2331889ac93089c3316971c" title="Compute union using cascading.">OGRGeometry::UnionCascaded()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry representing the union or NULL if an error occurs.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Use <a class="el" href="ogr__api_8h.html#ae4e284189448b23bc3dae1ad7ab54b50" title="Returns the union of all components of a single geometry.">OGR_G_UnaryUnion()</a> instead </dd></dl>

</div>
</div>
<a id="aadec1c54cea3139fce7b5866e41fc9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadec1c54cea3139fce7b5866e41fc9b8">&#9670;&nbsp;</a></span>OGR_G_Value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_G_Value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch point at given distance along curve. </p>
<p>This function relates to the SF COM ICurve::get_Value() method.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRCurve.html#a690570c5282483c043c0badbf94ce38b" title="Fetch point at given distance along curve.">OGRCurve::Value()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>curve geometry. </td></tr>
    <tr><td class="paramname">dfDistance</td><td>distance along the curve at which to sample position. This distance should be between zero and get_Length() for this curve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a point or NULL.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="a80ba9e516ccae381ae7240cc9684eb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ba9e516ccae381ae7240cc9684eb72">&#9670;&nbsp;</a></span>OGR_G_Within()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_Within </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hThis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOther</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for containment. </p>
<p>Tests if this geometry is within the other geometry.</p>
<p>Geometry validity is not checked. In case you are unsure of the validity of the input geometries, call IsValid() before, otherwise the result might be wrong.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeometry.html#a9803164ead0c4fbea9eafce64184160c" title="Test for containment.">OGRGeometry::Within()</a>.</p>
<p>This function is built on the GEOS library, check it for the definition of the geometry operation. If OGR is built without the GEOS library, this function will always fail, issuing a CPLE_NotSupported error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hThis</td><td>the geometry to compare. </td></tr>
    <tr><td class="paramname">hOther</td><td>the other geometry to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if hThis is within hOther, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="a5f7035a933b957a9d453184c154c237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7035a933b957a9d453184c154c237c">&#9670;&nbsp;</a></span>OGR_G_WkbSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_G_WkbSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This function returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This function relates to the SFCOM IWks::WkbSize() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a>.</p>
<p>Use <a class="el" href="ogr__api_8h.html#a39db2efdc712cb6b3f15d45905e6f712" title="Returns size of related binary representation.">OGR_G_WkbSizeEx()</a> if called on huge geometries (&gt; 2 GB serialized)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the binary size from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of binary representation in bytes. </dd></dl>

</div>
</div>
<a id="a39db2efdc712cb6b3f15d45905e6f712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39db2efdc712cb6b3f15d45905e6f712">&#9670;&nbsp;</a></span>OGR_G_WkbSizeEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t OGR_G_WkbSizeEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns size of related binary representation. </p>
<p>This function returns the exact number of bytes required to hold the well known binary representation of this geometry object. Its computation may be slightly expensive for complex geometries.</p>
<p>This function relates to the SFCOM IWks::WkbSize() method.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeometry.html#acd1a8164dae2e44e50990756ed6b8b4a" title="Returns size of related binary representation.">OGRGeometry::WkbSize()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>handle on the geometry to get the binary size from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of binary representation in bytes. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a9d6c040db3eed60df29528eee8b67d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6c040db3eed60df29528eee8b67d1d">&#9670;&nbsp;</a></span>OGR_GeomTransformer_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a> OGR_GeomTransformer_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a069f206f0e8e54328d648c14658cbf81">OGRCoordinateTransformationH</a>&#160;</td>
          <td class="paramname"><em>hCT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a geometry transformer. </p>
<p>This is a enhanced version of <a class="el" href="ogr__api_8h.html#a59a5b3f954b11cfbf6e78807c28d6090" title="Apply arbitrary coordinate transformation to geometry.">OGR_G_Transform()</a>.</p>
<p>When reprojecting geometries from a Polar Stereographic projection or a projection naturally crossing the antimeridian (like UTM Zone 60) to a geographic CRS, it will cut geometries along the antimeridian. So a LineString might be returned as a MultiLineString.</p>
<p>The WRAPDATELINE=YES option might be specified for circumstances to correct geometries that incorrectly go from a longitude on a side of the antimeridian to the other side, like a LINESTRING(-179 0,179 0) will be transformed to a MULTILINESTRING ((-179 0,-180 0),(180 0,179 0)). For that use case, hCT might be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hCT</td><td>Coordinate transformation object (will be cloned) or NULL. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options, or NULL. Supported options are: <ul>
<li>
WRAPDATELINE=YES </li>
<li>
DATELINEOFFSET=longitude_gap_in_degree. Defaults to 10. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformer object to free with <a class="el" href="ogr__api_8h.html#ae5729c801d758baee9dc23b95ac80f55" title="Destroy a geometry transformer allocated with OGR_GeomTransformer_Create()">OGR_GeomTransformer_Destroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="ae5729c801d758baee9dc23b95ac80f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5729c801d758baee9dc23b95ac80f55">&#9670;&nbsp;</a></span>OGR_GeomTransformer_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GeomTransformer_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a>&#160;</td>
          <td class="paramname"><em>hTransformer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a geometry transformer allocated with <a class="el" href="ogr__api_8h.html#a9d6c040db3eed60df29528eee8b67d1d" title="Create a geometry transformer.">OGR_GeomTransformer_Create()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTransformer</td><td>transformer object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="a64b248b82b3898573f8b6ff6fb87d5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b248b82b3898573f8b6ff6fb87d5d8">&#9670;&nbsp;</a></span>OGR_GeomTransformer_Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_GeomTransformer_Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#abfd327453a3ded09dad8dcfa88170dbb">OGRGeomTransformerH</a>&#160;</td>
          <td class="paramname"><em>hTransformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hTransformer</td><td>transformer object. </td></tr>
    <tr><td class="paramname">hGeom</td><td>Source geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new geometry (or NULL) to destroy with <a class="el" href="ogr__api_8h.html#ac4e665f5f9690c4fa0c190b930fe9492" title="Destroy geometry object.">OGR_G_DestroyGeometry()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.1 </dd></dl>

</div>
</div>
<a id="a9611cba58f204544ecad73fd8defe3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9611cba58f204544ecad73fd8defe3f3">&#9670;&nbsp;</a></span>OGR_GetFieldSubTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GetFieldSubTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eSubType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch human readable name for a field subtype. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#a51ec3ceae06d8a5113fc2a8e2e52e954" title="Fetch human readable name for a field subtype.">OGRFieldDefn::GetFieldSubTypeName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eSubType</td><td>the field subtype to get name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="af1e61b89ae2d799cf5e217d01ef7b415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e61b89ae2d799cf5e217d01ef7b415">&#9670;&nbsp;</a></span>OGR_GetFieldTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GetFieldTypeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch human readable name for a field type. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRFieldDefn.html#afc2a020f72be8296b6e09f5ab979f930" title="Fetch human readable name for a field type.">OGRFieldDefn::GetFieldTypeName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eType</td><td>the field type to get name for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name. </dd></dl>

</div>
</div>
<a id="add28d22dc63336e5f2a9d543e792982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add28d22dc63336e5f2a9d543e792982f">&#9670;&nbsp;</a></span>OGR_GFld_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a> OGR_GFld_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new field geometry definition. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ac69cdfca5b480465569b88bc4f9f7765" title="Constructor.">OGRGeomFieldDefn::OGRGeomFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the new field definition. </td></tr>
    <tr><td class="paramname">eType</td><td>the type of the new field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the new field definition.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a0f3e65993ea2b8b907e43ffa8b106871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e65993ea2b8b907e43ffa8b106871">&#9670;&nbsp;</a></span>OGR_GFld_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a geometry field definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a06ed8172ddb4962001be2e37b774e80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ed8172ddb4962001be2e37b774e80d">&#9670;&nbsp;</a></span>OGR_GFld_GetCoordinatePrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a> OGR_GFld_GetCoordinatePrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the coordinate precision associated to this geometry field. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#acda55805230956f36192db306d544ec3" title="Return the coordinate precision associated to this geometry field.">OGRGeomFieldDefn::GetCoordinatePrecision()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate precision </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ad9914366a6cc3b4169a3359c2b1ef614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9914366a6cc3b4169a3359c2b1ef614">&#9670;&nbsp;</a></span>OGR_GFld_GetNameRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GFld_GetNameRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#afee61d406460dd46eeaa48a77f477991" title="Fetch name of this field.">OGRGeomFieldDefn::GetNameRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the geometry field definition.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a7927b11a85659d8ce6da8857f52b05c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7927b11a85659d8ce6da8857f52b05c4">&#9670;&nbsp;</a></span>OGR_GFld_GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGR_GFld_GetSpatialRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch spatial reference system of this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#acdc7b11a77a8e3f838a2b33965e2971f" title="Fetch spatial reference system of this field.">OGRGeomFieldDefn::GetSpatialRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the field spatial reference system. It should not be modified.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a323f4350c2e90c6e67df37f68d244a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323f4350c2e90c6e67df37f68d244a0d">&#9670;&nbsp;</a></span>OGR_GFld_GetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_GFld_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch geometry type of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ac06e4141dee676afc00d33166c01d13f" title="Fetch geometry type of this field.">OGRGeomFieldDefn::GetType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to get type from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field geometry type.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="ab232798830d8dcae0742d83948e33d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab232798830d8dcae0742d83948e33d1a">&#9670;&nbsp;</a></span>OGR_GFld_IsIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_GFld_IsIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#aec9839abc6fa2633310ef691d753329a" title="Return whether this field should be omitted when fetching features.">OGRGeomFieldDefn::IsIgnored()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ignore state</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a9bfbda2b68e11227611ff74ee0105d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfbda2b68e11227611ff74ee0105d47">&#9670;&nbsp;</a></span>OGR_GFld_IsNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_GFld_IsNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this geometry field can receive null values. </p>
<p>By default, fields are nullable.</p>
<p>Even if this method returns FALSE (i.e not-nullable field), it doesn't mean that <a class="el" href="classOGRFeature.html#a905bb73fe5e6df57f1be5a8b77489b74" title="Test if a field has ever been assigned a value or not.">OGRFeature::IsFieldSet()</a> will necessary return TRUE, as fields can be temporary unset and null/not-null validation is usually done when <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">OGRLayer::CreateFeature()</a>/SetFeature() is called.</p>
<p>Note that not-nullable geometry fields might also contain 'empty' geometries.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a7c56d7cea54c57f9be60b0b76f9a03ff" title="Return whether this geometry field can receive null values.">OGRGeomFieldDefn::IsNullable()</a>.</p>
<p>Note that once a <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> has been added to a layer definition with OGRLayer::AddGeomFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetGeomFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b" title="Alter the definition of an existing geometry field on a layer.">OGRLayer::AlterGeomFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is authorized to be null. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="afad0d8a54fc213c10791b559de0fe5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad0d8a54fc213c10791b559de0fe5c7">&#9670;&nbsp;</a></span>OGR_GFld_SetCoordinatePrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetCoordinatePrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set coordinate precision associated to this geometry field. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a7e0eafa6aac7a4f01ce00aa4aefea193" title="Set coordinate precision associated to this geometry field.">OGRGeomFieldDefn::SetCoordinatePrecision()</a></p>
<p>Note that once a <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> has been added to a layer definition with OGRLayer::AddGeomFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetGeomFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition. Must not be NULL. </td></tr>
    <tr><td class="paramname">hGeomCoordPrec</td><td>Coordinate precision. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="af3a4e5e2af01140209e9d2814869eb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a4e5e2af01140209e9d2814869eb41">&#9670;&nbsp;</a></span>OGR_GFld_SetIgnored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetIgnored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this field should be omitted when fetching features. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a0266cdd27bf12420f0eb2107091a49b7" title="Set whether this field should be omitted when fetching features.">OGRGeomFieldDefn::SetIgnored()</a>.</p>
<p>This method should not be called on a object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetGeomFieldDefn(). Instead, the <a class="el" href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a" title="Set which fields can be omitted when retrieving features from the layer.">OGRLayer::SetIgnoredFields()</a> method should be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition </td></tr>
    <tr><td class="paramname">ignore</td><td>ignore state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a6c9b9d56381cae346c5129943641f628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9b9d56381cae346c5129943641f628">&#9670;&nbsp;</a></span>OGR_GFld_SetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the name of this field. </p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#ae3ca3a2ccdea222a2675cd0f7eeb57f7" title="Reset the name of this field.">OGRGeomFieldDefn::SetName()</a>.</p>
<p>Note that once a <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> has been added to a layer definition with OGRLayer::AddGeomFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetGeomFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b" title="Alter the definition of an existing geometry field on a layer.">OGRLayer::AlterGeomFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to apply the new name to. </td></tr>
    <tr><td class="paramname">pszName</td><td>the new name to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7e650dbb34d3eb1b1b8b2cd9e7b0a1">&#9670;&nbsp;</a></span>OGR_GFld_SetNullable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetNullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bNullableIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether this geometry field can receive null values. </p>
<p>By default, fields are nullable, so this method is generally called with FALSE to set a not-null constraint.</p>
<p>Drivers that support writing not-null constraint will advertise the GDAL_DCAP_NOTNULL_GEOMFIELDS driver metadata item.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#aac631bcd6cd10d531aa11062c9f2453c" title="Set whether this geometry field can receive null values.">OGRGeomFieldDefn::SetNullable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the field definition </td></tr>
    <tr><td class="paramname">bNullableIn</td><td>FALSE if the field must have a not-null constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="aa717acc8f4f5f33825334fe72edc2be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa717acc8f4f5f33825334fe72edc2be9">&#9670;&nbsp;</a></span>OGR_GFld_SetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetSpatialRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the spatial reference of this field. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRGeomFieldDefn.html#a9e5c13ee9c6c3ddb56b14c061fc1bfe7" title="Set the spatial reference of this field.">OGRGeomFieldDefn::SetSpatialRef()</a>.</p>
<p>This function drops the reference of the previously set SRS object and acquires a new reference on the passed object (if non-NULL).</p>
<p>Note that once a <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> has been added to a layer definition with OGRLayer::AddGeomFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetGeomFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b" title="Alter the definition of an existing geometry field on a layer.">OGRLayer::AlterGeomFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition </td></tr>
    <tr><td class="paramname">hSRS</td><td>the new SRS to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="affb3691474967ca5f0c9789e0626d55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3691474967ca5f0c9789e0626d55f">&#9670;&nbsp;</a></span>OGR_GFld_SetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_GFld_SetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a>&#160;</td>
          <td class="paramname"><em>eType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the geometry type of this field. </p>
<p>This should never be done to an <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> that is already part of an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>.</p>
<p>This function is the same as the CPP method <a class="el" href="classOGRGeomFieldDefn.html#a9b030e08d01a09b1917c1d01638a4ac8" title="Set the geometry type of this field.">OGRGeomFieldDefn::SetType()</a>.</p>
<p>Note that once a <a class="el" href="classOGRGeomFieldDefn.html" title="Definition of a geometry field of an OGRFeatureDefn.">OGRGeomFieldDefn</a> has been added to a layer definition with OGRLayer::AddGeomFieldDefn(), its setter methods should not be called on the object returned with <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>-&gt;GetGeomFieldDefn(). Instead, <a class="el" href="classOGRLayer.html#a49a87755bff79d25c5774280023dda0b" title="Alter the definition of an existing geometry field on a layer.">OGRLayer::AlterGeomFieldDefn()</a> should be called on a new instance of <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a>, for drivers that support AlterFieldDefn().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDefn</td><td>handle to the geometry field definition to set type to. </td></tr>
    <tr><td class="paramname">eType</td><td>the new field geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a3a595da83840038ef5c93ccef61a3f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a595da83840038ef5c93ccef61a3f77">&#9670;&nbsp;</a></span>OGR_GlobFldDomain_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a> OGR_GlobFldDomain_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eFieldType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eFieldSubType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszGlob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new glob field domain. </p>
<p>This is the same as the C++ method OGRGlobFieldDomain::OGRGlobFieldDomain()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Domain name. Should not be NULL. </td></tr>
    <tr><td class="paramname">pszDescription</td><td>Domain description (can be NULL) </td></tr>
    <tr><td class="paramname">eFieldType</td><td>Field type. </td></tr>
    <tr><td class="paramname">eFieldSubType</td><td>Field subtype. </td></tr>
    <tr><td class="paramname">pszGlob</td><td>Glob expression. Should not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new handle that should be freed with <a class="el" href="ogr__api_8h.html#a5b56883e79d620e4cf585e64f323787b" title="Destroy a field domain.">OGR_FldDomain_Destroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="afef323febaec609ab88b7d4d3ef03a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef323febaec609ab88b7d4d3ef03a3b">&#9670;&nbsp;</a></span>OGR_GlobFldDomain_GetGlob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_GlobFldDomain_GetGlob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the glob expression. </p>
<p>This is the same as the C++ method <a class="el" href="classOGRGlobFieldDomain.html#afa5d93ac26193dac2fea980491af667d" title="Get the glob expression.">OGRGlobFieldDomain::GetGlob()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the glob expression, or nullptr in case of error </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a679904d97c1084f309706ac3c6228cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679904d97c1084f309706ac3c6228cec">&#9670;&nbsp;</a></span>OGR_L_AlterFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_AlterFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the definition of an existing field on a layer. </p>
<p>You must use this to alter the definition of an existing field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCAlterFieldDefn capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly. Some drivers might also not support all update flags.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iField</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td class="paramname">hNewFieldDefn</td><td>new field definition </td></tr>
    <tr><td class="paramname">nFlags</td><td>combination of ALTER_NAME_FLAG, ALTER_TYPE_FLAG, ALTER_WIDTH_PRECISION_FLAG, ALTER_NULLABLE_FLAG and ALTER_DEFAULT_FLAG to indicate which of the name and/or type and/or width and precision fields and/or nullability from the new field definition must be taken into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a9d73a820734d51982ab964e6d57e7d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d73a820734d51982ab964e6d57e7d4f">&#9670;&nbsp;</a></span>OGR_L_AlterGeomFieldDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_AlterGeomFieldDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hNewGeomFieldDefn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alter the definition of an existing geometry field on a layer. </p>
<p>You must use this to alter the definition of an existing geometry field of a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the altered field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>Note that altering the SRS does <em>not</em> cause coordinate reprojection to occur: this is simply a modification of the layer metadata (correcting a wrong SRS definition). No modification to existing geometries will ever be performed, so this method cannot be used to e.g. promote single part geometries to their multipart equivalents.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCAlterGeomFieldDefn capability. Some drivers might not support all update flags. The GDAL_DMD_ALTER_GEOM_FIELD_DEFN_FLAGS driver metadata item can be queried to examine which flags may be supported by a driver.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#af52f539d34466c10b7c031a8270544b4" title="Alter the definition of an existing field on a layer.">OGRLayer::AlterFieldDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>index of the field whose definition must be altered. </td></tr>
    <tr><td class="paramname">hNewGeomFieldDefn</td><td>new field definition </td></tr>
    <tr><td class="paramname">nFlags</td><td>combination of ALTER_GEOM_FIELD_DEFN_NAME_FLAG, ALTER_GEOM_FIELD_DEFN_TYPE_FLAG, ALTER_GEOM_FIELD_DEFN_NULLABLE_FLAG, ALTER_GEOM_FIELD_DEFN_SRS_FLAG, ALTER_GEOM_FIELD_DEFN_SRS_COORD_EPOCH_FLAG to indicate which of the name and/or type and/or nullability and/or SRS and/or coordinate epoch from the new field definition must be taken into account. Or ALTER_GEOM_FIELD_DEFN_ALL_FLAG to update all members.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 3.6.0 </dd></dl>

</div>
</div>
<a id="ae12dcd5dc6dc5f930218573658f1b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12dcd5dc6dc5f930218573658f1b5c2">&#9670;&nbsp;</a></span>OGR_L_Clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clip off areas that are not covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer and in the method layer. The features in the result layer have the (possibly clipped) areas of features in the input layer and the attributes from the same features. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a822deb3b2d047185e3a454692619291c" title="Clip off areas that are not covered by the method layer.">OGRLayer::Clip()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a6135ef3b16c3cc974682365783603cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6135ef3b16c3cc974682365783603cc6">&#9670;&nbsp;</a></span>OGR_L_CommitTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CommitTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For datasources which support transactions, CommitTransaction commits a transaction. </p>
<p>If no transaction is active, or the commit fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a6cafa399e8f3027158787c87c3d1b97e" title="For datasources which support transactions, CommitTransaction commits a transaction.">OGRLayer::CommitTransaction()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="a301d319111285a47fe6cda6e079214f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301d319111285a47fe6cda6e079214f8">&#9670;&nbsp;</a></span>OGR_L_CreateFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CreateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and write a new feature within a layer. </p>
<p>The passed feature is written to the layer as a new feature, rather than overwriting an existing one. If the feature has a feature id other than OGRNullFID, then the native implementation may use that as the feature id of the new feature, but not necessarily. Upon successful return the passed feature will have been updated with the new feature id.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aaa1e32016f481596a55e1d988a15a067" title="Create and write a new feature within a layer.">OGRLayer::CreateFeature()</a>.</p>
<p>To create a feature, but set it if it exists see <a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGR_L_UpsertFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the feature to. </td></tr>
    <tr><td class="paramname">hFeat</td><td>the handle of the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a>, <a class="el" href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2" title="Update (part of) an existing feature.">OGR_L_UpdateFeature()</a>, <a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGR_L_UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="aab585ef1166c61c4819f7fd46ee4a275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab585ef1166c61c4819f7fd46ee4a275">&#9670;&nbsp;</a></span>OGR_L_CreateField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CreateField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a624dc73953f25ea4efd8686d5121249b">OGRFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new field on a layer. </p>
<p>You must use this to create new fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a69ece498332c3054281f17939dceeab4" title="Create a new field on a layer.">OGRLayer::CreateField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the field definition. </td></tr>
    <tr><td class="paramname">hField</td><td>handle of the field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="aaea1ddbc6c9dacc75986ea77ba1f56fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea1ddbc6c9dacc75986ea77ba1f56fc">&#9670;&nbsp;</a></span>OGR_L_CreateFieldFromArrowSchema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OGR_L_CreateFieldFromArrowSchema </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a field from an ArrowSchema. </p>
<p>This should only be used for attribute fields. Geometry fields should be created with CreateGeomField(). The FID field should also not be passed with this method.</p>
<p>Contrary to the IsArrowSchemaSupported() and WriteArrowBatch() methods, the passed schema must be for an individual field, and thus, is <em>not</em> of type struct (format=+s) (unless writing a set of fields grouped together in the same structure).</p>
<p>Additional field metadata can be speciffed through the ArrowSchema::metadata field with the potential following items: </p><ul>
<li>
"GDAL:OGR:alternative_name": value of <a class="el" href="classOGRFieldDefn.html#ad65cd1946750fb8bc80d9f8414e576bd" title="Fetch the alternative name (or &quot;alias&quot;) for this field.">OGRFieldDefn::GetAlternativeNameRef()</a> </li>
<li>
"GDAL:OGR:comment": value of <a class="el" href="classOGRFieldDefn.html#ab03617cad10b80e943b6419f17a1c489" title="Return the (optional) comment for this field.">OGRFieldDefn::GetComment()</a> </li>
<li>
"GDAL:OGR:default": value of <a class="el" href="classOGRFieldDefn.html#ac4210fa7c6f10ed090a5558224447cfa" title="Get default field value.">OGRFieldDefn::GetDefault()</a> </li>
<li>
"GDAL:OGR:subtype": value of <a class="el" href="classOGRFieldDefn.html#a3c18c491717be99e2e1a3c96cfc2ffd9" title="Fetch subtype of this field.">OGRFieldDefn::GetSubType()</a> </li>
<li>
"GDAL:OGR:width": value of <a class="el" href="classOGRFieldDefn.html#aa8c4090f59d60ca949ba3fd0eada9f36" title="Get the formatting width for this field.">OGRFieldDefn::GetWidth()</a> (serialized as a string) </li>
<li>
"GDAL:OGR:unique": value of <a class="el" href="classOGRFieldDefn.html#a20df702a2e152c946407d7c4796095a4" title="Return whether this field has a unique constraint.">OGRFieldDefn::IsUnique()</a> (serialized as "true" or "false") </li>
<li>
"GDAL:OGR:domain_name": value of <a class="el" href="classOGRFieldDefn.html#ae36192269558570b6627073f82542c9c" title="Return the name of the field domain for this field.">OGRFieldDefn::GetDomainName()</a> </li>
</ul>
<p>This method and CreateField() are mutually exclusive in the same session.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#a931c8aac9aa389fa58cacdecbf731579" title="Creates a field from an ArrowSchema.">OGRLayer::CreateFieldFromArrowSchema()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>Layer. </td></tr>
    <tr><td class="paramname">schema</td><td>Schema of the field to create. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options (none currently). Null terminated list, or nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<a id="af6908931c4f3ad364fef8d6e831363bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6908931c4f3ad364fef8d6e831363bc">&#9670;&nbsp;</a></span>OGR_L_CreateGeomField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_CreateGeomField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ab02dff2945904f6c0664e17a80c5f6bf">OGRGeomFieldDefnH</a>&#160;</td>
          <td class="paramname"><em>hField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bApproxOK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new geometry field on a layer. </p>
<p>You must use this to create new geometry fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the new field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCCreateField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>Drivers may or may not support not-null constraints. If they support creating fields with not-null constraints, this is generally before creating any feature to the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a69ece498332c3054281f17939dceeab4" title="Create a new field on a layer.">OGRLayer::CreateField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the field definition. </td></tr>
    <tr><td class="paramname">hField</td><td>handle of the geometry field definition to write to disk. </td></tr>
    <tr><td class="paramname">bApproxOK</td><td>If TRUE, the field may be created in a slightly different form depending on the limitations of the format driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.11 </dd></dl>

</div>
</div>
<a id="ae5acdeffac0c7a8ee33ac3a55db18949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5acdeffac0c7a8ee33ac3a55db18949">&#9670;&nbsp;</a></span>OGR_L_DeleteFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_DeleteFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete feature from layer. </p>
<p>The feature with the indicated feature id is deleted from the layer if supported by the driver. Most drivers do not support feature deletion, and will return OGRERR_UNSUPPORTED_OPERATION. The <a class="el" href="ogr__api_8h.html#a480adc8b839b04597f49583371d366fd" title="Test if this layer supported the named capability.">OGR_L_TestCapability()</a> function may be called with OLCDeleteFeature to check if the driver supports feature deletion.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#a2342e79e0248076c2205047e1928f296" title="Delete feature from layer.">OGRLayer::DeleteFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
    <tr><td class="paramname">nFID</td><td>the feature id to be deleted from the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist). </dd></dl>

</div>
</div>
<a id="afc861413683418eba5d31e487da2f9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc861413683418eba5d31e487da2f9e2">&#9670;&nbsp;</a></span>OGR_L_DeleteField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_DeleteField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iField</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing field on a layer. </p>
<p>You must use this to delete existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the deleted field. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCDeleteField capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aaebe7c671dca995549543eecf0f7a76a" title="Delete an existing field on a layer.">OGRLayer::DeleteField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iField</td><td>index of the field to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a0f8c47bbeae70e609f4e51a239784285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8c47bbeae70e609f4e51a239784285">&#9670;&nbsp;</a></span>OGR_L_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove areas that are covered by the method layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer but not in the method layer. The features in the result layer have attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a23fa292ae87af3bc0d3abb3963a71914" title="Remove areas that are covered by the method layer.">OGRLayer::Erase()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="affc3cef62be82ec4f811a89b1855cbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc3cef62be82ec4f811a89b1855cbd5">&#9670;&nbsp;</a></span>OGR_L_FindFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_FindFieldIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bExactMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of field in a layer. </p>
<p>The returned number is the index of the field in the layers, or -1 if the field doesn't exist.</p>
<p>If bExactMatch is set to FALSE and the field doesn't exists in the given form the driver might apply some changes to make it match, like those it might do if the layer was created (eg. like LAUNDER in the OCI driver).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aef41bcd7adad1ac5ddcef54d6b38713c" title="Find the index of field in the layer.">OGRLayer::FindFieldIndex()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>field index, or -1 if the field doesn't exist </dd></dl>

</div>
</div>
<a id="a8a545922d32601d007b9aad76357dd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a545922d32601d007b9aad76357dd09">&#9670;&nbsp;</a></span>OGR_L_GetArrowStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OGR_L_GetArrowStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArrayStream *&#160;</td>
          <td class="paramname"><em>out_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a Arrow C stream. </p>
<p>On successful return, and when the stream interfaces is no longer needed, it must be freed with out_stream-&gt;release(out_stream). Please carefully read <a href="https://arrow.apache.org/docs/format/CStreamInterface.html">https://arrow.apache.org/docs/format/CStreamInterface.html</a> for more details on using Arrow C stream.</p>
<p>The method may take into account ignored fields set with SetIgnoredFields() (the default implementation does), and should take into account filters set with SetSpatialFilter() and SetAttributeFilter(). Note however that specialized implementations may fallback to the default (slower) implementation when filters are set. Drivers that have a specialized implementation should advertise the OLCFastGetArrowStream capability.</p>
<p>There are extra precautions to take into account in a OGR context. Unless otherwise specified by a particular driver implementation, the get_schema(), get_next() and get_last_error() function pointers of the ArrowArrayStream structure should no longer be used after the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a>, from which the ArrowArrayStream structure was initialized, has been destroyed (typically at dataset closing). The reason is that those function pointers will typically point to methods of the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> instance. However, the ArrowSchema and ArrowArray structures filled from those callbacks can be used and must be released independently from the ArrowArrayStream or the layer.</p>
<p>Furthermore, unless otherwise specified by a particular driver implementation, only one ArrowArrayStream can be active at a time on a given layer (that is the last active one must be explicitly released before a next one is asked). Changing filter state, ignored columns, modifying the schema or using ResetReading()/GetNextFeature() while using a ArrowArrayStream is strongly discouraged and may lead to unexpected results. As a rule of thumb, no <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> methods that affect the state of a layer should be called on a layer, while an ArrowArrayStream on it is active.</p>
<p>Starting with GDAL 3.8, the ArrowSchema::metadata field filled by the get_schema() callback may be set with the potential following items: </p><ul>
<li>
"GDAL:OGR:alternative_name": value of <a class="el" href="classOGRFieldDefn.html#ad65cd1946750fb8bc80d9f8414e576bd" title="Fetch the alternative name (or &quot;alias&quot;) for this field.">OGRFieldDefn::GetAlternativeNameRef()</a> </li>
<li>
"GDAL:OGR:comment": value of <a class="el" href="classOGRFieldDefn.html#ab03617cad10b80e943b6419f17a1c489" title="Return the (optional) comment for this field.">OGRFieldDefn::GetComment()</a> </li>
<li>
"GDAL:OGR:default": value of <a class="el" href="classOGRFieldDefn.html#ac4210fa7c6f10ed090a5558224447cfa" title="Get default field value.">OGRFieldDefn::GetDefault()</a> </li>
<li>
"GDAL:OGR:subtype": value of <a class="el" href="classOGRFieldDefn.html#a3c18c491717be99e2e1a3c96cfc2ffd9" title="Fetch subtype of this field.">OGRFieldDefn::GetSubType()</a> </li>
<li>
"GDAL:OGR:width": value of <a class="el" href="classOGRFieldDefn.html#aa8c4090f59d60ca949ba3fd0eada9f36" title="Get the formatting width for this field.">OGRFieldDefn::GetWidth()</a> (serialized as a string) </li>
<li>
"GDAL:OGR:unique": value of <a class="el" href="classOGRFieldDefn.html#a20df702a2e152c946407d7c4796095a4" title="Return whether this field has a unique constraint.">OGRFieldDefn::IsUnique()</a> (serialized as "true" or "false") </li>
<li>
"GDAL:OGR:domain_name": value of <a class="el" href="classOGRFieldDefn.html#ae36192269558570b6627073f82542c9c" title="Return the name of the field domain for this field.">OGRFieldDefn::GetDomainName()</a> </li>
</ul>
<p>A potential usage can be: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ArrowArrayStream stream;</div>
<div class="line"><span class="keywordflow">if</span>( !<a class="code" href="ogr__api_8h.html#a8a545922d32601d007b9aad76357dd09">OGR_L_GetArrowStream</a>(hLayer, &amp;stream, <span class="keyword">nullptr</span>))</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d">CPLError</a>(CE_Failure, <a class="code" href="cpl__error_8h.html#a7151d0699caa1372a8566562390ff113">CPLE_AppDefined</a>,</div>
<div class="line">             <span class="stringliteral">&quot;OGR_L_GetArrowStream() failed\n&quot;</span>);</div>
<div class="line">    exit(1);</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>ArrowSchema schema;</div>
<div class="line"><span class="keywordflow">if</span>( stream.get_schema(&amp;stream, &amp;schema) == 0 )</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Do something useful</span></div>
<div class="line">    schema.release(schema);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">while</span>( <span class="keyword">true</span> )</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">struct </span>ArrowArray array;</div>
<div class="line">    <span class="comment">// Look for an error (get_next() returning a non-zero code), or</span></div>
<div class="line">    <span class="comment">// end of iteration (array.release == nullptr)</span></div>
<div class="line">    <span class="keywordflow">if</span>( stream.get_next(&amp;stream, &amp;array) != 0 ||</div>
<div class="line">        array.release == <span class="keyword">nullptr</span> )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Do something useful</span></div>
<div class="line">    array.release(&amp;array);</div>
<div class="line">}</div>
<div class="line">stream.release(&amp;stream);</div>
<div class="ttc" id="acpl__error_8h_html_a7151d0699caa1372a8566562390ff113"><div class="ttname"><a href="cpl__error_8h.html#a7151d0699caa1372a8566562390ff113">CPLE_AppDefined</a></div><div class="ttdeci">#define CPLE_AppDefined</div><div class="ttdoc">Application defined error.</div><div class="ttdef"><b>Definition:</b> cpl_error.h:100</div></div>
<div class="ttc" id="acpl__error_8h_html_afda4d86428c1c533449ae6a69cdf430d"><div class="ttname"><a href="cpl__error_8h.html#afda4d86428c1c533449ae6a69cdf430d">CPLError</a></div><div class="ttdeci">void CPLError(CPLErr eErrClass, CPLErrorNum err_no, const char *fmt,...)</div><div class="ttdoc">Report an error.</div><div class="ttdef"><b>Definition:</b> cpl_error.cpp:330</div></div>
<div class="ttc" id="aogr__api_8h_html_a8a545922d32601d007b9aad76357dd09"><div class="ttname"><a href="ogr__api_8h.html#a8a545922d32601d007b9aad76357dd09">OGR_L_GetArrowStream</a></div><div class="ttdeci">bool OGR_L_GetArrowStream(OGRLayerH hLayer, struct ArrowArrayStream *out_stream, char **papszOptions)</div><div class="ttdoc">Get a Arrow C stream.</div><div class="ttdef"><b>Definition:</b> ogrlayerarrow.cpp:2647</div></div>
</div><!-- fragment --><p>A full example is available in the <a href="https://gdal.org/tutorials/vector_api_tut.html#reading-from-ogr-using-the-arrow-c-stream-data-interface">Reading From OGR using the Arrow C Stream data interface</a> tutorial.</p>
<p>Options may be driver specific. The default implementation recognizes the following options: </p><ul>
<li>
INCLUDE_FID=YES/NO. Whether to include the FID column. Defaults to YES. </li>
<li>
MAX_FEATURES_IN_BATCH=integer. Maximum number of features to retrieve in a ArrowArray batch. Defaults to 65 536. </li>
<li>
TIMEZONE="unknown", "UTC", "(+|:)HH:MM" or any other value supported by Arrow. (GDAL &gt;= 3.8) Override the timezone flag nominally provided by <a class="el" href="classOGRFieldDefn.html#ab3cf869f6b571e011e28fa52b4a83947" title="Get the time zone flag.">OGRFieldDefn::GetTZFlag()</a>, and used for the Arrow field timezone declaration, with a user specified timezone. Note that datetime values in Arrow arrays are always stored in UTC, and that the time zone flag used by GDAL to convert to UTC is the one of the OGRField::Date::TZFlag member at the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> level. The conversion to UTC of a OGRField::Date is only done if both the timezone indicated by OGRField::Date::TZFlag and the one at the <a class="el" href="classOGRFieldDefn.html" title="Definition of an attribute of an OGRFeatureDefn.">OGRFieldDefn</a> level (or set by this TIMEZONE option) are not unknown. </li>
<li>
GEOMETRY_METADATA_ENCODING=OGC/GEOARROW (GDAL &gt;= 3.8). The default is OGC, which will lead to setting the Arrow geometry column metadata to ARROW:extension:name=ogc.wkb. If setting to GEOMETRY_METADATA_ENCODING to GEOARROW, ARROW:extension:name=geoarrow.wkb and ARROW:extension:metadata={"crs": &lt;projjson CRS representation&gt;&gt; are set.  </li>
</ul>
<p>The Arrow/Parquet drivers recognize the following option: </p><ul>
<li>
GEOMETRY_ENCODING=WKB. To force a fallback to the generic implementation when the native geometry encoding is not WKB. Otherwise the geometry will be returned with its native Arrow encoding (possibly using GeoArrow encoding). </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>Layer </td></tr>
    <tr><td class="paramname">out_stream</td><td>Output stream. Must <em>not</em> be NULL. The content of the structure does not need to be initialized. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of key=value options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="aa6c495581900c8301dff91d8cd3ee12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c495581900c8301dff91d8cd3ee12f">&#9670;&nbsp;</a></span>OGR_L_GetExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_GetExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the extent of this layer. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">OGRLayer::GetExtent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer from which to get extent. </td></tr>
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

</div>
</div>
<a id="aeed5833946cd34e49517eaedad17874d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed5833946cd34e49517eaedad17874d">&#9670;&nbsp;</a></span>OGR_L_GetExtent3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_GetExtent3D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope3D.html">OGREnvelope3D</a> *&#160;</td>
          <td class="paramname"><em>psExtent3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the 3D extent of this layer, on the specified geometry field. </p>
<p>Returns the 3D extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>(Contrarty to GetExtent() 2D), the returned extent will always take into account the attribute and spatial filters that may be installed.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>For layers that have no 3D geometries, the psExtent3D-&gt;MinZ and psExtent3D-&gt;MaxZ fields will be respectively set to +Infinity and -Infinity.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ad3c96b5540aaf8d5c2769430ed0e8be9" title="Fetch the 3D extent of this layer, on the specified geometry field.">OGRLayer::GetExtent3D()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>the layer to consider. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>0-based index of the geometry field to consider. </td></tr>
    <tr><td class="paramname">psExtent3D</td><td>the computed 3D extent of the layer. </td></tr>
    <tr><td class="paramname">bForce</td><td>if TRUE, the extent will be computed even if all the layer features have to be fetched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code in case of failure. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ac3dbfd4443c80dca0d93574f0c00d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dbfd4443c80dca0d93574f0c00d376">&#9670;&nbsp;</a></span>OGR_L_GetExtentEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_GetExtentEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOGREnvelope.html">OGREnvelope</a> *&#160;</td>
          <td class="paramname"><em>psExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the extent of this layer, on the specified geometry field. </p>
<p>Returns the extent (MBR) of the data in the layer. If bForce is FALSE, and it would be expensive to establish the extent then OGRERR_FAILURE will be returned indicating that the extent isn't know. If bForce is TRUE then some implementations will actually scan the entire layer once to compute the MBR of all the features in the layer.</p>
<p>Depending on the drivers, the returned extent may or may not take the spatial filter into account. So it is safer to call <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a> without setting a spatial filter.</p>
<p>Layers without any geometry may return OGRERR_FAILURE just indicating that no meaningful extents could be collected.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a3be658ddb5b33d1ed95c31286774bbd2" title="Fetch the extent of this layer.">OGRLayer::GetExtent()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer from which to get extent. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>the index of the geometry field on which to compute the extent. </td></tr>
    <tr><td class="paramname">psExtent</td><td>the structure in which the extent value will be returned. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the extent should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success, OGRERR_FAILURE if extent not known. </dd></dl>

</div>
</div>
<a id="a29d378c5092db944966398de8d1ac964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d378c5092db944966398de8d1ac964">&#9670;&nbsp;</a></span>OGR_L_GetFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_L_GetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nFeatureId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a feature by its identifier. </p>
<p>This function will attempt to read the identified feature. The nFID value cannot be OGRNullFID. Success or failure of this operation is unaffected by the spatial or attribute filters (and specialized implementations in drivers should make sure that they do not take into account spatial or attribute filters).</p>
<p>If this function returns a non-NULL feature, it is guaranteed that its feature id (<a class="el" href="ogr__api_8h.html#afc99defd1fb1f8f71ff89c38982f2103" title="Get feature identifier.">OGR_F_GetFID()</a>) will be the same as nFID.</p>
<p>Use OGR_L_TestCapability(OLCRandomRead) to establish if this layer supports efficient random access reading via <a class="el" href="ogr__api_8h.html#a29d378c5092db944966398de8d1ac964" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a>; however, the call should always work if the feature exists as a fallback implementation just scans all the features in the layer looking for the desired feature.</p>
<p>Sequential reads (with <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a>) are generally considered interrupted by a <a class="el" href="ogr__api_8h.html#a29d378c5092db944966398de8d1ac964" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a> call.</p>
<p>The returned feature should be free with <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb" title="Destroy feature.">OGR_F_Destroy()</a>.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ace902dfb44335fb1a877aa035ecff209" title="Fetch a feature by its identifier.">OGRLayer::GetFeature( )</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer that owned the feature. </td></tr>
    <tr><td class="paramname">nFeatureId</td><td>the feature id of the feature to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a feature now owned by the caller, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a08524b6961e52e1561308d2b0c598fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08524b6961e52e1561308d2b0c598fb2">&#9670;&nbsp;</a></span>OGR_L_GetFeatureCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a> OGR_L_GetFeatureCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bForce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the feature count in this layer. </p>
<p>Returns the number of features in the layer. For dynamic databases the count may not be exact. If bForce is FALSE, and it would be expensive to establish the feature count a value of -1 may be returned indicating that the count isn't know. If bForce is TRUE some implementations will actually scan the entire layer once to count objects.</p>
<p>The returned count takes the spatial filter into account.</p>
<p>Note that some implementations of this method may alter the read cursor of the layer.</p>
<p>This function is the same as the CPP <a class="el" href="classOGRLayer.html#a2d0e1a43fd1a0a6d55d766384da7b6a5" title="Fetch the feature count in this layer.">OGRLayer::GetFeatureCount()</a>.</p>
<p>Note: since GDAL 2.0, this method returns a GIntBig (previously a int)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer that owned the features. </td></tr>
    <tr><td class="paramname">bForce</td><td>Flag indicating whether the count should be computed even if it is expensive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>feature count, -1 if count not known. </dd></dl>

</div>
</div>
<a id="abfeb6e1258f113c6c45c8d6a43c8cfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeb6e1258f113c6c45c8d6a43c8cfa5">&#9670;&nbsp;</a></span>OGR_L_GetFIDColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetFIDColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the FID column, or "" if not supported. </p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#af0cb9a05310d7b17d9dfec9e83a18e61" title="This method returns the name of the underlying database column being used as the FID column,...">OGRLayer::GetFIDColumn()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fid column name. </dd></dl>

</div>
</div>
<a id="ab060e07e277cebd1d8504c449d97b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab060e07e277cebd1d8504c449d97b29f">&#9670;&nbsp;</a></span>OGR_L_GetGeometryColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetGeometryColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the name of the underlying database column being used as the geometry column, or "" if not supported. </p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use OGR_GFld_GetNameRef(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#af68036c23622c954ce3a91861f22b724" title="This method returns the name of the underlying database column being used as the geometry column,...">OGRLayer::GetGeometryColumn()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometry column name. </dd></dl>

</div>
</div>
<a id="a61c3e553be67cbec0a7794abdc0260ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c3e553be67cbec0a7794abdc0260ec">&#9670;&nbsp;</a></span>OGR_L_GetGeometryTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOGRGeometryTypeCounter.html">OGRGeometryTypeCounter</a>* OGR_L_GetGeometryTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnEntryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get actual geometry types found in features. </p>
<p>See <a class="el" href="classOGRLayer.html#a770e610904df8c3ebac47419e86ece69" title="Get actual geometry types found in features.">OGRLayer::GetGeometryTypes()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hLayer</td><td>Layer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iGeomField</td><td>Geometry field index. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nFlags</td><td>Hint flags. 0, or combination of OGR_GGT_COUNT_NOT_NEEDED, OGR_GGT_STOP_IF_MIXED, OGR_GGT_GEOMCOLLECTIONZ_TINZ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnEntryCount</td><td>Pointer to the number of entries in the returned array. Must not be NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pfnProgress</td><td>Cancellation callback. May be NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pProgressData</td><td>User data for the cancellation callback. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array of *pnEntryCount that must be freed with <a class="el" href="cpl__conv_8h.html#a21b7f312da39ddb0a12bdde06b153b48" title="Alias of VSIFree()">CPLFree()</a>, or NULL in case of error </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6 </dd></dl>

</div>
</div>
<a id="a0adea8ce1ca795ce0a6a76505f90f078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adea8ce1ca795ce0a6a76505f90f078">&#9670;&nbsp;</a></span>OGR_L_GetGeomType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">OGRwkbGeometryType</a> OGR_L_GetGeomType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the layer geometry type. </p>
<p>This returns the same result as OGR_FD_GetGeomType(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type.">OGR_L_GetGeomType()</a> directly can avoid lengthy layer definition initialization.</p>
<p>For layers with multiple geometry fields, this method only returns the geometry type of the first geometry column. For other columns, use OGR_GFld_GetType(OGR_FD_GetGeomFieldDefn(OGR_L_GetLayerDefn(hLayer), i)). For layers without any geometry field, this method returns wkbNone.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a818a25520ce08d5a681443348e930604" title="Return the layer geometry type.">OGRLayer::GetGeomType()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometry type </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a7b67ea4ab5892c6720460dc7f66eca2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b67ea4ab5892c6720460dc7f66eca2d">&#9670;&nbsp;</a></span>OGR_L_GetLayerDefn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a827cc74dba4613e928843c4b5f781618">OGRFeatureDefnH</a> OGR_L_GetLayerDefn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the schema information for this layer. </p>
<p>The returned handle to the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a>, and should not be modified or freed by the application. It encapsulates the attribute schema of the features of the layer.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a80473bcfd11341e70dd35bebe94026cf" title="Fetch the schema information for this layer.">OGRLayer::GetLayerDefn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the schema information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the feature definition. </dd></dl>

</div>
</div>
<a id="a88facf4f8e8b32278101d52ae094255c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88facf4f8e8b32278101d52ae094255c">&#9670;&nbsp;</a></span>OGR_L_GetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * OGR_L_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the layer name. </p>
<p>This returns the same content as OGR_FD_GetName(OGR_L_GetLayerDefn(hLayer)), but for a few drivers, calling <a class="el" href="ogr__api_8h.html#a88facf4f8e8b32278101d52ae094255c" title="Return the layer name.">OGR_L_GetName()</a> directly can avoid lengthy layer definition initialization.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a287f5ec7728cacc2f7d94882a9f1a22e" title="Return the layer name.">OGRLayer::GetName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the layer name (must not been freed) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.8.0 </dd></dl>

</div>
</div>
<a id="a6708c067521ab7b7f9c4ec0ebe221b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6708c067521ab7b7f9c4ec0ebe221b5b">&#9670;&nbsp;</a></span>OGR_L_GetNextFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a> OGR_L_GetNextFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the next available feature from this layer. </p>
<p>The returned feature becomes the responsibility of the caller to delete with <a class="el" href="ogr__api_8h.html#a16fb8126aa932f4b4acdaca5ea99bbbb" title="Destroy feature.">OGR_F_Destroy()</a>. It is critical that all features associated with an <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> (more specifically an <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a>) be deleted before that layer/datasource is deleted.</p>
<p>Only features matching the current spatial filter (set with SetSpatialFilter()) will be returned.</p>
<p>This function implements sequential access to the features of a layer. The <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a> function can be used to start at the beginning again.</p>
<p>Starting with GDAL 3.6, it is possible to retrieve them by batches, with a column-oriented memory layout, using the <a class="el" href="ogr__api_8h.html#a8a545922d32601d007b9aad76357dd09" title="Get a Arrow C stream.">OGR_L_GetArrowStream()</a> function.</p>
<p>Features returned by OGR_GetNextFeature() may or may not be affected by concurrent modifications depending on drivers. A guaranteed way of seeing modifications in effect is to call <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a> on layers where OGR_GetNextFeature() has been called, before reading again. Structural changes in layers (field addition, deletion, ...) when a read is in progress may or may not be possible depending on drivers. If a transaction is committed/aborted, the current sequential reading may or may not be valid after that operation and a call to <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a> might be needed.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a47d21ff33b32d14fa4e9885b9edecad6" title="Fetch the next available feature from this layer.">OGRLayer::GetNextFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer from which feature are read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to a feature, or NULL if no more features are available. </dd></dl>

</div>
</div>
<a id="a36d61f311c9f8c172ad118659358c60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d61f311c9f8c172ad118659358c60a">&#9670;&nbsp;</a></span>OGR_L_GetSpatialFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGR_L_GetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current spatial filter for this layer. </p>
<p>The returned pointer is to an internally owned object, and should not be altered or deleted by the caller.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#adc3735e444204d46f517eec251712f4d" title="This method returns the current spatial filter for this layer.">OGRLayer::GetSpatialFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the spatial filter from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the spatial filter geometry. </dd></dl>

</div>
</div>
<a id="a8b2a10085f410aa84172eba413408c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2a10085f410aa84172eba413408c39">&#9670;&nbsp;</a></span>OGR_L_GetSpatialRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a> OGR_L_GetSpatialRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the spatial reference system for this layer. </p>
<p>The returned object is owned by the <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> and should not be modified or freed by the application.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the spatial reference from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>spatial reference, or NULL if there isn't one. </dd></dl>

</div>
</div>
<a id="a1841a38e9dc7a6f2047fdc1c463ef808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1841a38e9dc7a6f2047fdc1c463ef808">&#9670;&nbsp;</a></span>OGR_L_GetSupportedSRSList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>* OGR_L_GetSupportedSRSList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of SRS supported. </p>
<p>The base implementation of this method will return an empty list. Some drivers (OAPIF, WFS) may return a non-empty list.</p>
<p>One of the SRS returned may be passed to SetActiveSRS() to change the active SRS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hLayer</td><td>Layer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iGeomField</td><td>Geometry field index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnCount</td><td>Number of values in returned array. Must not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of supported SRS, to be freeds with <a class="el" href="ogr__srs__api_8h.html#a0d2f386cc06888e791df28828aaeae00" title="Free return of OSRIdentifyMatches()">OSRFreeSRSArray()</a>, or nullptr </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a67948074f2e2942cebdd0f90bbec8aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67948074f2e2942cebdd0f90bbec8aa9">&#9670;&nbsp;</a></span>OGR_L_Identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify the features of this layer with the ones from the identity layer. </p>
<p>The result layer contains features whose geometries represent areas that are in the input layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer.  </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is YES, to add features with lower dimension geometry, but only if the result layer has an unknown geometry type.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a385ff64cc8b070819da0a7e121ff07b3" title="Identify the features of this layer with the ones from the identity layer.">OGRLayer::Identity()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a5c353cc32c9dd02967a7bed1450d2524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c353cc32c9dd02967a7bed1450d2524">&#9670;&nbsp;</a></span>OGR_L_Intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Intersection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersection of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are common between features in the input layer and in the method layer. The features in the result layer have attributes from both input and method layers. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer.  </li>
<li>
PRETEST_CONTAINMENT=YES/NO. Set to YES to pretest the containment of features of method layer within the features of this layer. This will speed up the method significantly in some cases. Requires that the prepared geometries are in effect.  </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is YES, to add features with lower dimension geometry, but only if the result layer has an unknown geometry type.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a5202606175f7e7dcd76c3eb237ac8303" title="Intersection of two layers.">OGRLayer::Intersection()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="abe072d5f6595a0cddd1cddbeb38416fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe072d5f6595a0cddd1cddbeb38416fb">&#9670;&nbsp;</a></span>OGR_L_IsArrowSchemaSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OGR_L_IsArrowSchemaSupported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppszErrorMsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the provided ArrowSchema is supported for writing. </p>
<p>This function exists since not all drivers may support all Arrow data types.</p>
<p>The ArrowSchema must be of type struct (format=+s)</p>
<p>It is recommended to call this function before calling <a class="el" href="ogr__api_8h.html#afd53afc03673f67f4023108147d44989" title="Writes a batch of rows from an ArrowArray.">OGR_L_WriteArrowBatch()</a>.</p>
<p>This is the same as the C++ method <a class="el" href="classOGRLayer.html#aad6238309c2ca47804da68096f838740" title="Returns whether the provided ArrowSchema is supported for writing.">OGRLayer::IsArrowSchemaSupported()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">hLayer</td><td>Layer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">schema</td><td>Schema of type struct (format = '+s') </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">papszOptions</td><td>Options (none currently). Null terminated list, or nullptr. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppszErrorMsg</td><td>nullptr, or pointer to a string that will contain the reason of the failure, when this function returns false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ArrowSchema is supported for writing. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<a id="a952e14b2016b5542ca1a7b54929ee719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952e14b2016b5542ca1a7b54929ee719">&#9670;&nbsp;</a></span>OGR_L_Rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszNewName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename layer. </p>
<p>This operation is implemented only by layers that expose the OLCRename capability, and drivers that expose the GDAL_DCAP_RENAME_LAYERS capability</p>
<p>This operation will fail if a layer with the new name already exists.</p>
<p>On success, GetDescription() and GetLayerDefn()-&gt;GetName() will return pszNewName.</p>
<p>Renaming the layer may interrupt current feature iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>Layer to rename. </td></tr>
    <tr><td class="paramname">pszNewName</td><td>New layer name. Must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.5 </dd></dl>

</div>
</div>
<a id="ad20a3796ee63935285976ee425878927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20a3796ee63935285976ee425878927">&#9670;&nbsp;</a></span>OGR_L_ReorderField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_ReorderField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iOldFieldPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNewFieldPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder an existing field on a layer. </p>
<p>This function is a convenience wrapper of <a class="el" href="ogr__api_8h.html#a4cc576cb39e1dd4a1f074125199245bb" title="Reorder all the fields of a layer.">OGR_L_ReorderFields()</a> dedicated to move a single field.</p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>The field definition that was at initial position iOldFieldPos will be moved at position iNewFieldPos, and elements between will be shuffled accordingly.</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderField(1, 3) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ab4c02b991bfa78552eeb0cbcdcf1aed8" title="Reorder an existing field on a layer.">OGRLayer::ReorderField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">iOldFieldPos</td><td>previous position of the field to move. Must be in the range [0,GetFieldCount()-1]. </td></tr>
    <tr><td class="paramname">iNewFieldPos</td><td>new position of the field to move. Must be in the range [0,GetFieldCount()-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="a4cc576cb39e1dd4a1f074125199245bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc576cb39e1dd4a1f074125199245bb">&#9670;&nbsp;</a></span>OGR_L_ReorderFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_ReorderFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>panMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder all the fields of a layer. </p>
<p>You must use this to reorder existing fields on a real layer. Internally the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> for the layer will be updated to reflect the reordering of the fields. Applications should never modify the <a class="el" href="classOGRFeatureDefn.html" title="Definition of a feature class or feature layer.">OGRFeatureDefn</a> used by a layer directly.</p>
<p>This function should not be called while there are feature objects in existence that were obtained or created with the previous layer definition.</p>
<p>panMap is such that,for each field definition at position i after reordering, its position before reordering was panMap[i].</p>
<p>For example, let suppose the fields were "0","1","2","3","4" initially. ReorderFields([0,2,3,1,4]) will reorder them as "0","2","3","1","4".</p>
<p>Not all drivers support this function. You can query a layer to check if it supports it with the OLCReorderFields capability. Some drivers may only support this method while there are still no features in the layer. When it is supported, the existing features of the backing file/database should be updated accordingly.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aebd364a150d91f8d65d967646e0f92d3" title="Reorder all the fields of a layer.">OGRLayer::ReorderFields()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer. </td></tr>
    <tr><td class="paramname">panMap</td><td>an array of GetLayerDefn()-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature.">OGRFeatureDefn::GetFieldCount()</a> elements which is a permutation of [0, GetLayerDefn()-&gt;<a class="el" href="classOGRFeatureDefn.html#a3abba98e1e957a01b3af0b9e0f73f493" title="Fetch number of fields on this feature.">OGRFeatureDefn::GetFieldCount()</a>-1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.9.0 </dd></dl>

</div>
</div>
<a id="ab0383004bf637171648a9d03a80f15a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0383004bf637171648a9d03a80f15a4">&#9670;&nbsp;</a></span>OGR_L_ResetReading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_ResetReading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset feature reading to start on the first feature. </p>
<p>This affects GetNextFeature() and GetArrowStream().</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aad0f2cd7f0587584b8f382c6a913583c" title="Reset feature reading to start on the first feature.">OGRLayer::ResetReading()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which features are read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a823a6c351dccf751777f67801dd7f9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823a6c351dccf751777f67801dd7f9c5">&#9670;&nbsp;</a></span>OGR_L_RollbackTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_RollbackTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For datasources which support transactions, RollbackTransaction will roll back a datasource to its state before the start of the current transaction. </p>
<p>If no transaction is active, or the rollback fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#ab046dbffc4fbd5bacc6ef75da0686d82" title="For datasources which support transactions, RollbackTransaction will roll back a datasource to its st...">OGRLayer::RollbackTransaction()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="a250f26d915e09dc32622663ba76e9a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250f26d915e09dc32622663ba76e9a16">&#9670;&nbsp;</a></span>OGR_L_SetActiveSRS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetActiveSRS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the active SRS. </p>
<p>The passed SRS must be in the list returned by GetSupportedSRSList() (the actual pointer may be different, but should be tested as identical with <a class="el" href="classOGRSpatialReference.html#afd86486cb2e7291c6d1647986a4bd318" title="Do these two spatial references describe the same system ?">OGRSpatialReference::IsSame()</a>).</p>
<p>Changing the active SRS affects: </p><ul>
<li>
the SRS in which geometries of returned features are expressed, </li>
<li>
the SRS in which geometries of passed features (CreateFeature(), SetFeature()) are expressed, </li>
<li>
the SRS returned by GetSpatialRef() and GetGeomFieldDefn()-&gt;GetSpatialRef(), </li>
<li>
the SRS used to interpret SetSpatialFilter() values. </li>
</ul>
<p>This also resets feature reading and the spatial filter. Note however that this does not modify the storage SRS of the features of geometries. Said otherwise, this setting is volatile and has no persistent effects after dataset reopening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>Layer. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>Geometry field index. </td></tr>
    <tr><td class="paramname">hSRS</td><td>SRS to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE in case of success, OGRERR_FAILURE if the passed SRS is not in GetSupportedSRSList(). </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7 </dd></dl>

</div>
</div>
<a id="a4000d426bf26ad7cc7d4012634c93f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4000d426bf26ad7cc7d4012634c93f09">&#9670;&nbsp;</a></span>OGR_L_SetAttributeFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetAttributeFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszQuery</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new attribute query. </p>
<p>This function sets the attribute query string to be used when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> function. Only features for which the query evaluates as true will be returned.</p>
<p>The query string should be in the format of an SQL WHERE clause. For instance "population &gt; 1000000 and population &lt; 5000000" where population is an attribute in the layer. The query format is normally a SQL WHERE clause as described in the <a href="https://gdal.org/user/ogr_sql_dialect.html#where">"WHERE"</a> section of the OGR SQL dialect documentation. In some cases (RDBMS backed drivers, SQLite, GeoPackage) the native capabilities of the database may be used to to interpret the WHERE clause, in which case the capabilities will be broader than those of OGR SQL.</p>
<p>Note that installing a query string will generally result in resetting the current reading position (ala <a class="el" href="ogr__api_8h.html#ab0383004bf637171648a9d03a80f15a4" title="Reset feature reading to start on the first feature.">OGR_L_ResetReading()</a>).</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#acb2c6cc5fa3577df5be538284c1b0dde" title="Set a new attribute query.">OGRLayer::SetAttributeFilter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which attribute query will be executed. </td></tr>
    <tr><td class="paramname">pszQuery</td><td>query in restricted SQL WHERE format, or NULL to clear the current query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if successfully installed, or an error code if the query expression is in error, or some other failure occurs. </dd></dl>

</div>
</div>
<a id="a5b380520d0999422987f06b6e31b9b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b380520d0999422987f06b6e31b9b00">&#9670;&nbsp;</a></span>OGR_L_SetFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite/replace an existing feature. </p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>.</p>
<p>Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a>.</p>
<p>The way unset fields in the provided poFeature are processed is driver dependent: </p><ul>
<li>
SQL based drivers which implement SetFeature() through SQL UPDATE will skip unset fields, and thus the content of the existing feature will be preserved.  </li>
<li>
The shapefile driver will write a NULL value in the DBF file.  </li>
<li>
The GeoJSON driver will take into account unset fields to remove the corresponding JSON member.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a681139bfd585b74d7218e51a32144283" title="Rewrite/replace an existing feature.">OGRLayer::SetFeature()</a>.</p>
<p>To set a feature, but create it if it doesn't exist see <a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGR_L_UpsertFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the feature. </td></tr>
    <tr><td class="paramname">hFeat</td><td>the feature to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2" title="Update (part of) an existing feature.">OGR_L_UpdateFeature()</a>, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a>, <a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGR_L_UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="a6d43f1474201356bed2e6f92e7d37154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d43f1474201356bed2e6f92e7d37154">&#9670;&nbsp;</a></span>OGR_L_SetIgnoredFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetIgnoredFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>papszFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set which fields can be omitted when retrieving features from the layer. </p>
<p>If the driver supports this functionality (testable using OLCIgnoreFields capability), it will not fetch the specified fields in subsequent calls to GetFeature() / GetNextFeature() and thus save some processing time and/or bandwidth.</p>
<p>Besides field names of the layers, the following special fields can be passed: "OGR_GEOMETRY" to ignore geometry and "OGR_STYLE" to ignore layer style.</p>
<p>By default, no fields are ignored.</p>
<p>Note that fields that are used in an attribute filter should generally not be set as ignored fields, as most drivers (such as those relying on the OGR SQL engine) will be unable to correctly evaluate the attribute filter.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aaf3f2e7ee476337082cea814226be11a" title="Set which fields can be omitted when retrieving features from the layer.">OGRLayer::SetIgnoredFields()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
    <tr><td class="paramname">papszFields</td><td>an array of field names terminated by NULL item. If NULL is passed, the ignored list is cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if all field names have been resolved (even if the driver does not support this method) </dd></dl>

</div>
</div>
<a id="a8b4427a82ea3de3bed7acff19b6e8e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4427a82ea3de3bed7acff19b6e8e33">&#9670;&nbsp;</a></span>OGR_L_SetNextByIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SetNextByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#af4f1fd7d2338bb38f28bdf32a0724e83">GIntBig</a>&#160;</td>
          <td class="paramname"><em>nIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move read cursor to the nIndex'th feature in the current resultset. </p>
<p>This method allows positioning of a layer such that the GetNextFeature() call will read the requested feature, where nIndex is an absolute index into the current result set. So, setting it to 3 would mean the next feature read with GetNextFeature() would have been the 4th feature to have been read if sequential reading took place from the beginning of the layer, including accounting for spatial and attribute filters.</p>
<p>Only in rare circumstances is SetNextByIndex() efficiently implemented. In all other cases the default implementation which calls ResetReading() and then calls GetNextFeature() nIndex times is used. To determine if fast seeking is available on the current layer use the TestCapability() method with a value of OLCFastSetNextByIndex.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#ac0b0869ff6fcadda35cbac1f3edf8eae" title="Move read cursor to the nIndex&#39;th feature in the current resultset.">OGRLayer::SetNextByIndex()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer </td></tr>
    <tr><td class="paramname">nIndex</td><td>the index indicating how many steps into the result set to seek.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a id="a678d1735bc82533614ac005691d1138c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678d1735bc82533614ac005691d1138c">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features whose envelope (as returned by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGR_G_GetEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>Starting with GDAL 2.3, features with null or empty geometries will never be considered as matching a spatial filter.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the layer (as returned by <a class="el" href="ogr__api_8h.html#a8b2a10085f410aa84172eba413408c39" title="Fetch the spatial reference system for this layer.">OGR_L_GetSpatialRef()</a>). In the future this may be generalized.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00c8a1a968542d389f86ed1b4edd5823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c8a1a968542d389f86ed1b4edd5823">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilterEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new spatial filter. </p>
<p>This function set the geometry to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> function. Only features that geometrically intersect the filter geometry will be returned.</p>
<p>Currently this test is may be inaccurately implemented, but it is guaranteed that all features who's envelope (as returned by <a class="el" href="ogr__api_8h.html#a617a9c9ea85157661619a1d8f0a69cf9" title="Computes and returns the bounding envelope for this geometry in the passed psEnvelope structure.">OGR_G_GetEnvelope()</a>) overlaps the envelope of the spatial filter will be returned. This can result in more shapes being returned that should strictly be the case.</p>
<p>This function makes an internal copy of the passed geometry. The passed geometry remains the responsibility of the caller, and may be safely destroyed.</p>
<p>For the time being the passed filter geometry should be in the same SRS as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). In the future this may be generalized.</p>
<p>Note that only the last spatial filter set is applied, even if several successive calls are done with different iGeomField values.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">hGeom</td><td>handle to the geometry to use as a filtering region. NULL may be passed indicating that the current spatial filter should be cleared, but no new one instituted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a5cba569e0779a02a95327f041d9f7a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cba569e0779a02a95327f041d9f7a13">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilterRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as the layer as a whole (as returned by <a class="el" href="classOGRLayer.html#a75c06b4993f8eb76b569f37365cd19ab" title="Fetch the spatial reference system for this layer.">OGRLayer::GetSpatialRef()</a>). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460" title="Set a new rectangular spatial filter.">OGRLayer::SetSpatialFilterRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489241dfe65d6e089809d3258c4f79f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489241dfe65d6e089809d3258c4f79f5">&#9670;&nbsp;</a></span>OGR_L_SetSpatialFilterRectEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_L_SetSpatialFilterRectEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iGeomField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMinY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new rectangular spatial filter. </p>
<p>This method set rectangle to be used as a spatial filter when fetching features via the <a class="el" href="ogr__api_8h.html#a6708c067521ab7b7f9c4ec0ebe221b5b" title="Fetch the next available feature from this layer.">OGR_L_GetNextFeature()</a> method. Only features that geometrically intersect the given rectangle will be returned.</p>
<p>The x/y values should be in the same coordinate system as as the geometry field definition it corresponds to (as returned by GetLayerDefn()-&gt;OGRFeatureDefn::GetGeomFieldDefn(iGeomField)-&gt;GetSpatialRef()). Internally this method is normally implemented as creating a 5 vertex closed rectangular polygon and passing it to <a class="el" href="classOGRLayer.html#a0b4ab45cf97cbc470f0d60474d3e4169" title="Set a new spatial filter.">OGRLayer::SetSpatialFilter()</a>. It exists as a convenience.</p>
<p>The only way to clear a spatial filter set with this method is to call OGRLayer::SetSpatialFilter(NULL).</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#acd16bcdb3e8f720003fb24cd68f25460" title="Set a new rectangular spatial filter.">OGRLayer::SetSpatialFilterRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer on which to set the spatial filter. </td></tr>
    <tr><td class="paramname">iGeomField</td><td>index of the geometry field on which the spatial filter operates. </td></tr>
    <tr><td class="paramname">dfMinX</td><td>the minimum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMinY</td><td>the minimum Y coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxX</td><td>the maximum X coordinate for the rectangular region. </td></tr>
    <tr><td class="paramname">dfMaxY</td><td>the maximum Y coordinate for the rectangular region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 1.11 </dd></dl>

</div>
</div>
<a id="a8180ea56ca7f677eb5da05c8cfcb77be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8180ea56ca7f677eb5da05c8cfcb77be">&#9670;&nbsp;</a></span>OGR_L_StartTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_StartTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For datasources which support transactions, StartTransaction creates a transaction. </p>
<p>If starting the transaction fails, will return OGRERR_FAILURE. Datasources which do not support transactions will always return OGRERR_NONE.</p>
<p>Note: as of GDAL 2.0, use of this API is discouraged when the dataset offers dataset level transaction with <a class="el" href="classGDALDataset.html#a3e4161f148fac57dac5cfe4900421348" title="For datasources which support transactions, StartTransaction creates a `transaction.">GDALDataset::StartTransaction()</a>. The reason is that most drivers can only offer transactions at dataset level, and not layer level. Very few drivers really support transactions at layer scope.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a2855f6fae6f97fa1cebcc2f57a0f974f" title="For datasources which support transactions, StartTransaction creates a transaction.">OGRLayer::StartTransaction()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>

</div>
</div>
<a id="a03249311ff4c88b2fac5f728be63b549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03249311ff4c88b2fac5f728be63b549">&#9670;&nbsp;</a></span>OGR_L_SymDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SymDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symmetrical difference of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer or in the method layer but not in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a781aa76c6b44b19de09f61816e32245b" title="Symmetrical difference of two layers.">OGRLayer::SymDifference()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a9d845a6cf6652756925530418905471a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d845a6cf6652756925530418905471a">&#9670;&nbsp;</a></span>OGR_L_SyncToDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_SyncToDisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending changes to disk. </p>
<p>This call is intended to force the layer to flush any pending writes to disk, and leave the disk file in a consistent state. It would not normally have any effect on read-only datasources.</p>
<p>Some layers do not implement this method, and will still return OGRERR_NONE. The default implementation just returns OGRERR_NONE. An error is only returned if an error occurs while attempting to flush to disk.</p>
<p>In any event, you should always close any opened datasource with <a class="el" href="ogr__api_8h.html#a4823e7c3513cd9d57254364de9a1d021" title="Closes opened datasource and releases allocated resources.">OGR_DS_Destroy()</a> that will ensure all data is correctly flushed.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#aebb07284c734e485d8611b7c8599254f" title="Flush pending changes to disk.">OGRLayer::SyncToDisk()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if no error occurs (even if nothing is done) or an error code. </dd></dl>

</div>
</div>
<a id="a480adc8b839b04597f49583371d366fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480adc8b839b04597f49583371d366fd">&#9670;&nbsp;</a></span>OGR_L_TestCapability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_L_TestCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this layer supported the named capability. </p>
<p>The capability codes that can be tested are represented as strings, but #defined constants exists to ensure correct spelling. Specific layer types may implement class specific capabilities, but this can't generally be discovered by the caller. </p>
<ul>
<li>
<p class="startli"><b>OLCRandomRead</b> / "RandomRead": TRUE if the GetFeature() method is implemented in an optimized way for this layer, as opposed to the default implementation using ResetReading() and GetNextFeature() to find the requested feature id.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCSequentialWrite</b> / "SequentialWrite": TRUE if the CreateFeature() method works for this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCRandomWrite</b> / "RandomWrite": TRUE if the SetFeature() method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCUpsertFeature</b> / "UpsertFeature": TRUE if the UpsertFeature() method is operational on this layer. Note this means that this particular layer is writable. The same <a class="el" href="classOGRLayer.html" title="This class represents a layer of simple features, with access methods.">OGRLayer</a> class may return FALSE for other layer instances that are effectively read-only.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSpatialFilter</b> / "FastSpatialFilter": TRUE if this layer implements spatial filtering efficiently. Layers that effectively read all features, and test them with the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a> intersection methods should return FALSE. This can be used as a clue by the application whether it should build and maintain its own spatial index for features in this layer.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastFeatureCount</b> / "FastFeatureCount": TRUE if this layer can return a feature count (via <a class="el" href="ogr__api_8h.html#a08524b6961e52e1561308d2b0c598fb2" title="Fetch the feature count in this layer.">OGR_L_GetFeatureCount()</a>) efficiently, i.e. without counting the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastGetExtent</b> / "FastGetExtent": TRUE if this layer can return its data extent (via <a class="el" href="ogr__api_8h.html#aa6c495581900c8301dff91d8cd3ee12f" title="Fetch the extent of this layer.">OGR_L_GetExtent()</a>) efficiently, i.e. without scanning all the features. In some cases this will return TRUE until a spatial filter is installed after which it will return FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCFastSetNextByIndex</b> / "FastSetNextByIndex": TRUE if this layer can perform the SetNextByIndex() call efficiently, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateField</b> / "CreateField": TRUE if this layer can create new fields on the current layer using CreateField(), otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCreateGeomField</b> / "CreateGeomField": (GDAL &gt;= 1.11) TRUE if this layer can create new geometry fields on the current layer using CreateGeomField(), otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteField</b> / "DeleteField": TRUE if this layer can delete existing fields on the current layer using DeleteField(), otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCReorderFields</b> / "ReorderFields": TRUE if this layer can reorder existing fields on the current layer using ReorderField() or ReorderFields(), otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterFieldDefn</b> / "AlterFieldDefn": TRUE if this layer can alter the definition of an existing field on the current layer using AlterFieldDefn(), otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCAlterGeomFieldDefn</b> / "AlterGeomFieldDefn": TRUE if this layer can alter the definition of an existing geometry field on the current layer using AlterGeomFieldDefn(), otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCDeleteFeature</b> / "DeleteFeature": TRUE if the DeleteFeature() method is supported on this layer, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCStringsAsUTF8</b> / "StringsAsUTF8": TRUE if values of OFTString fields are assured to be in UTF-8 format. If FALSE the encoding of fields is uncertain, though it might still be UTF-8.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCTransactions</b> / "Transactions": TRUE if the StartTransaction(), CommitTransaction() and RollbackTransaction() methods work in a meaningful way, otherwise FALSE.</p>
<p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>OLCCurveGeometries</b> / "CurveGeometries": TRUE if this layer supports writing curve geometries or may return such geometries. (GDAL 2.0).</p>
<p class="interli"></p>
<p class="interli"></p>
<p class="endli"></p>
</li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#aeedbda1a62f9b89b8e5f24332cf22286" title="Test if this layer supported the named capability.">OGRLayer::TestCapability()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to get the capability from. </td></tr>
    <tr><td class="paramname">pszCap</td><td>the name of the capability to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the layer has the requested capability, or FALSE otherwise. OGRLayers will return FALSE for any unrecognized capabilities.</dd></dl>

</div>
</div>
<a id="ac8edb8696c2b046370e29efdd73787f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8edb8696c2b046370e29efdd73787f7">&#9670;&nbsp;</a></span>OGR_L_Union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of two layers. </p>
<p>The result layer contains features whose geometries represent areas that are in either in the input layer, in the method layer, or in both. The features in the result layer have attributes from both input and method layers. For features which represent areas that are only in the input or in the method layer the respective attributes have undefined values. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input and method layers.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in input and in method layer, then the attribute in the result feature will get the value from the feature of the method layer (even if it is undefined).</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
<li>
USE_PREPARED_GEOMETRIES=YES/NO. Set to NO to not use prepared geometries to pretest intersection of features of method layer with features of this layer.  </li>
<li>
KEEP_LOWER_DIMENSION_GEOMETRIES=YES/NO. Set to NO to skip result features with lower dimension geometry that would otherwise be added to the result layer. The default is YES, to add features with lower dimension geometry, but only if the result layer has an unknown geometry type.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#adf0598c7dab1f4dbe3e2735e27450c9c" title="Union of two layers.">OGRLayer::Union()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a87b478c971619145dee7d8d8deeac702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b478c971619145dee7d8d8deeac702">&#9670;&nbsp;</a></span>OGR_L_Update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>pLayerResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALProgressFunc&#160;</td>
          <td class="paramname"><em>pfnProgress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pProgressArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update this layer with features from the update layer. </p>
<p>The result layer contains features whose geometries represent areas that are either in the input layer or in the method layer. The features in the result layer have areas of the features of the method layer or those ares of the features of the input layer that are not covered by the method layer. The features of the result layer get their attributes from the input layer. The schema of the result layer can be set by the user or, if it is empty, is initialized to contain all fields in the input layer.</p>
<dl class="section note"><dt>Note</dt><dd>If the schema of the result is set by user and contains fields that have the same name as a field in the method layer, then the attribute in the result feature the originates from the method layer will get the value from the feature of the method layer.</dd>
<dd>
For best performance use the minimum amount of features in the method layer and copy it into a memory layer.</dd>
<dd>
This method relies on GEOS support. Do not use unless the GEOS support is compiled in.</dd></dl>
<p>The recognized list of options is : </p><ul>
<li>
SKIP_FAILURES=YES/NO. Set it to YES to go on, even when a feature could not be inserted or a GEOS call failed.  </li>
<li>
PROMOTE_TO_MULTI=YES/NO. Set to YES to convert Polygons into MultiPolygons, LineStrings to MultiLineStrings or Points to MultiPoints (only since GDAL 3.9.2 for the later)  </li>
<li>
INPUT_PREFIX=string. Set a prefix for the field names that will be created from the fields of the input layer.  </li>
<li>
METHOD_PREFIX=string. Set a prefix for the field names that will be created from the fields of the method layer.  </li>
</ul>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a6b86f3a070fe99e39631c994be4fce08" title="Update this layer with features from the update layer.">OGRLayer::Update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLayerInput</td><td>the input layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerMethod</td><td>the method layer. Should not be NULL.</td></tr>
    <tr><td class="paramname">pLayerResult</td><td>the layer where the features resulting from the operation are inserted. Should not be NULL. See above the note about the schema.</td></tr>
    <tr><td class="paramname">papszOptions</td><td>NULL terminated list of options (may be NULL).</td></tr>
    <tr><td class="paramname">pfnProgress</td><td>a GDALProgressFunc() compatible callback function for reporting progress or NULL.</td></tr>
    <tr><td class="paramname">pProgressArg</td><td>argument to be passed to pfnProgress. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if there was an error or the execution was interrupted, OGRERR_NONE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The first geometry field is always used.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>OGR 1.10 </dd></dl>

</div>
</div>
<a id="a897b3d8c8c11a3947fd5eb9a27b47da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897b3d8c8c11a3947fd5eb9a27b47da2">&#9670;&nbsp;</a></span>OGR_L_UpdateFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_UpdateFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUpdatedFieldsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panUpdatedFieldsIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nUpdatedGeomFieldsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>panUpdatedGeomFieldsIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUpdateStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update (part of) an existing feature. </p>
<p>This function will update the specified attribute and geometry fields of a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>.</p>
<p>Use OGR_L_TestCapability(OLCRandomWrite) to establish if this layer supports random access writing via UpdateFeature(). And to know if the driver supports a dedicated/efficient UpdateFeature() method, test for the OLCUpdateFeature capability.</p>
<p>The way unset fields in the provided poFeature are processed is driver dependent: </p><ul>
<li>
SQL based drivers which implement SetFeature() through SQL UPDATE will skip unset fields, and thus the content of the existing feature will be preserved.  </li>
<li>
The shapefile driver will write a NULL value in the DBF file.  </li>
<li>
The GeoJSON driver will take into account unset fields to remove the corresponding JSON member.  </li>
</ul>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#ad4ff65e1809eefacfa1d8f56deb1b39d" title="Update (part of) an existing feature.">OGRLayer::UpdateFeature()</a>.</p>
<p>To fully replace a feature, see <a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a></p>
<p>Note that after this call the content of hFeat might have changed, and will not* reflect the content you would get with <a class="el" href="ogr__api_8h.html#a29d378c5092db944966398de8d1ac964" title="Fetch a feature by its identifier.">OGR_L_GetFeature()</a>. In particular for performance reasons, passed geometries might have been "stolen", in particular for the default implementation of UpdateFeature() which relies on GetFeature() + SetFeature().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the feature.</td></tr>
    <tr><td class="paramname">hFeat</td><td>the feature to update.</td></tr>
    <tr><td class="paramname">nUpdatedFieldsCount</td><td>number of attribute fields to update. May be 0</td></tr>
    <tr><td class="paramname">panUpdatedFieldsIdx</td><td>array of nUpdatedFieldsCount values, each between 0 and GetLayerDefn()-&gt;GetFieldCount() - 1, indicating which fields of hFeat must be updated in the layer.</td></tr>
    <tr><td class="paramname">nUpdatedGeomFieldsCount</td><td>number of geometry fields to update. May be 0</td></tr>
    <tr><td class="paramname">panUpdatedGeomFieldsIdx</td><td>array of nUpdatedGeomFieldsCount values, each between 0 and GetLayerDefn()-&gt;GetGeomFieldCount() - 1, indicating which geometry fields of hFeat must be updated in the layer.</td></tr>
    <tr><td class="paramname">bUpdateStyleString</td><td>whether the feature style string in the layer should be updated with the one of hFeat.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE if the operation works, otherwise an appropriate error code (e.g OGRERR_NON_EXISTING_FEATURE if the feature does not exist).</dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.7</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2" title="Update (part of) an existing feature.">OGR_L_UpdateFeature()</a>, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a>, <a class="el" href="ogr__api_8h.html#a6fab9d73c63f923b185e4bf965208bf3" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGR_L_UpsertFeature()</a> </dd></dl>

</div>
</div>
<a id="a6fab9d73c63f923b185e4bf965208bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fab9d73c63f923b185e4bf965208bf3">&#9670;&nbsp;</a></span>OGR_L_UpsertFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGR_L_UpsertFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite/replace an existing feature or create a new feature within a layer. </p>
<p>This function will write a feature to the layer, based on the feature id within the <a class="el" href="classOGRFeature.html" title="A simple feature, including geometry and attributes.">OGRFeature</a>. If the feature id doesn't exist a new feature will be written. Otherwise, the existing feature will be rewritten.</p>
<p>Use OGR_L_TestCapability(OLCUpsertFeature) to establish if this layer supports upsert writing.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRLayer.html#a0fde458509b0cccc23d2ce89c1fd9dfb" title="Rewrite/replace an existing feature or create a new feature within a layer.">OGRLayer::UpsertFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>handle to the layer to write the feature to. </td></tr>
    <tr><td class="paramname">hFeat</td><td>the handle of the feature to write to disk.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.6.0</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a5b380520d0999422987f06b6e31b9b00" title="Rewrite/replace an existing feature.">OGR_L_SetFeature()</a>, <a class="el" href="ogr__api_8h.html#a301d319111285a47fe6cda6e079214f8" title="Create and write a new feature within a layer.">OGR_L_CreateFeature()</a>, <a class="el" href="ogr__api_8h.html#a897b3d8c8c11a3947fd5eb9a27b47da2" title="Update (part of) an existing feature.">OGR_L_UpdateFeature()</a> </dd></dl>

</div>
</div>
<a id="afd53afc03673f67f4023108147d44989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd53afc03673f67f4023108147d44989">&#9670;&nbsp;</a></span>OGR_L_WriteArrowBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OGR_L_WriteArrowBatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a635095fa23dfea934f4bb2df38fb9a67">OGRLayerH</a>&#160;</td>
          <td class="paramname"><em>hLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ArrowSchema *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ArrowArray *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a batch of rows from an ArrowArray. </p>
<p>This is semantically close to calling CreateFeature() with multiple features at once.</p>
<p>The ArrowArray must be of type struct (format=+s), and its children generally map to a OGR attribute or geometry field (unless they are struct themselves).</p>
<p>Method IsArrowSchemaSupported() can be called to determine if the schema will be supported by WriteArrowBatch().</p>
<p>OGR fields for the corresponding children arrays must exist and be of a compatible type. For attribute fields, they should generally be created with CreateFieldFromArrowSchema(). This is strictly required for output drivers Arrow or Parquet, and strongly recommended otherwise. For geometry fields, they should be created either implicitly at CreateLayer() type (if geom_type != wkbNone), or explicitly with CreateGeomField().</p>
<p>Starting with GDAL 3.9, some tolerance has been introduced in the base implementation of WriteArrowBatch() for scenarios that involve appending to an already existing output layer when the input Arrow field type and the OGR layer field type are 32/64-bi integers or real number, but do not match exactly, which may cause lossy conversions. The IF_FIELD_NOT_PRESERVED option can be used to control the behavior in case of lossy conversion.</p>
<p>Arrays for geometry columns should be of binary or large binary type and contain WKB geometry.</p>
<p>Note that the passed array may be set to a released state (array-&gt;release==NULL) after this call (not by the base implementation, but in specialized ones such as Parquet or Arrow for example)</p>
<p>Supported options of the base implementation are: </p><ul>
<li>
FID=name. Name of the FID column in the array. If not provided, GetFIDColumn() is used to determine it. The special name <a class="el" href="classOGRLayer.html#aeaa832ad40d9bf5e4a23e43c8c92c2ce" title="Field name used by GetArrowSchema() for a FID column when GetFIDColumn() is not set.">OGRLayer::DEFAULT_ARROW_FID_NAME</a> is also recognized if neither FID nor GetFIDColumn() are set. The corresponding ArrowArray must be of type int32 (i) or int64 (l). On input, values of the FID column are used to create the feature. On output, the values of the FID column may be set with the FID of the created feature (if the array is not released).  </li>
<li>
IF_FID_NOT_PRESERVED=NOTHING/ERROR/WARNING. Action to perform when the input FID is not preserved in the output layer. The default is NOTHING. Setting it to ERROR will cause the function to error out. Setting it to WARNING will cause the function to emit a warning but continue its processing.  </li>
<li>
IF_FIELD_NOT_PRESERVED=ERROR/WARNING. (since GDAL 3.9) Action to perform when the input field value is not preserved in the output layer. The default is WARNING, which will cause the function to emit a warning but continue its processing. Setting it to ERROR will cause the function to error out if a lossy conversion is detected.  </li>
<li>
GEOMETRY_NAME=name. Name of the geometry column. If not provided, GetGeometryColumn() is used. The special name <a class="el" href="classOGRLayer.html#ae079dc0eac54cc4ad068c7bdfb295acd" title="Field name used by GetArrowSchema() for the name of the (single) geometry column (returned by GetGeom...">OGRLayer::DEFAULT_ARROW_GEOMETRY_NAME</a> is also recognized if neither GEOMETRY_NAME nor GetGeometryColumn() are set. Geometry columns are also identified if they have ARROW:extension:name=ogc.wkb as a field metadata. The corresponding ArrowArray must be of type binary (w) or large binary (W).  </li>
</ul>
<p>The following example demonstrates how to copy a layer from one format to another one (assuming it has at most a single geometry column): </p><div class="fragment"><div class="line"><span class="keyword">def </span>copy_layer(src_lyr, out_filename, out_format, lcos = {}):</div>
<div class="line">    stream = src_lyr.GetArrowStream()</div>
<div class="line">    schema = stream.GetSchema()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># If the source layer has a FID column and the output driver supports</span></div>
<div class="line">    <span class="comment"># a FID layer creation option, set it to the source FID column name.</span></div>
<div class="line">    <span class="keywordflow">if</span> src_lyr.GetFIDColumn():</div>
<div class="line">        creationOptions = gdal.GetDriverByName(out_format).GetMetadataItem(</div>
<div class="line">            <span class="stringliteral">&quot;DS_LAYER_CREATIONOPTIONLIST&quot;</span></div>
<div class="line">        )</div>
<div class="line">        <span class="keywordflow">if</span> creationOptions <span class="keywordflow">and</span> <span class="stringliteral">&#39;&quot;FID&quot;&#39;</span> <span class="keywordflow">in</span> creationOptions:</div>
<div class="line">            lcos[<span class="stringliteral">&quot;FID&quot;</span>] = src_lyr.GetFIDColumn()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">with</span> ogr.GetDriverByName(out_format).CreateDataSource(out_filename) <span class="keyword">as</span> out_ds:</div>
<div class="line">        <span class="keywordflow">if</span> src_lyr.GetLayerDefn().GetGeomFieldCount() &gt; 1:</div>
<div class="line">            out_lyr = out_ds.CreateLayer(</div>
<div class="line">                src_lyr.GetName(), geom_type=ogr.wkbNone, options=lcos</div>
<div class="line">            )</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(src_lyr.GetLayerDefn().GetGeomFieldCount()):</div>
<div class="line">                out_lyr.CreateGeomField(src_lyr.GetLayerDefn().GetGeomFieldDefn(i))</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            out_lyr = out_ds.CreateLayer(</div>
<div class="line">                src_lyr.GetName(),</div>
<div class="line">                geom_type=src_lyr.GetGeomType(),</div>
<div class="line">                srs=src_lyr.GetSpatialRef(),</div>
<div class="line">                options=lcos,</div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line">        success, error_msg = out_lyr.IsArrowSchemaSupported(schema)</div>
<div class="line">        <span class="keyword">assert</span> success, error_msg</div>
<div class="line"> </div>
<div class="line">        src_geom_field_names = [</div>
<div class="line">            src_lyr.GetLayerDefn().GetGeomFieldDefn(i).GetName()</div>
<div class="line">            <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(src_lyr.GetLayerDefn().GetGeomFieldCount())</div>
<div class="line">        ]</div>
<div class="line">        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(schema.GetChildrenCount()):</div>
<div class="line">            <span class="comment"># GetArrowStream() may return &quot;OGC_FID&quot; for a unnamed source FID</span></div>
<div class="line">            <span class="comment"># column and &quot;wkb_geometry&quot; for a unnamed source geometry column.</span></div>
<div class="line">            <span class="comment"># Also test GetFIDColumn() and src_geom_field_names if they are</span></div>
<div class="line">            <span class="comment"># named.</span></div>
<div class="line">            <span class="keywordflow">if</span> (</div>
<div class="line">                schema.GetChild(i).GetName()</div>
<div class="line">                <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&quot;OGC_FID&quot;</span>, <span class="stringliteral">&quot;wkb_geometry&quot;</span>, src_lyr.GetFIDColumn())</div>
<div class="line">                <span class="keywordflow">and</span> schema.GetChild(i).GetName() <span class="keywordflow">not</span> <span class="keywordflow">in</span> src_geom_field_names</div>
<div class="line">            ):</div>
<div class="line">                out_lyr.CreateFieldFromArrowSchema(schema.GetChild(i))</div>
<div class="line"> </div>
<div class="line">        write_options = []</div>
<div class="line">        <span class="keywordflow">if</span> src_lyr.GetFIDColumn():</div>
<div class="line">            write_options.append(<span class="stringliteral">&quot;FID=&quot;</span> + src_lyr.GetFIDColumn())</div>
<div class="line">        <span class="keywordflow">if</span> (</div>
<div class="line">            src_lyr.GetLayerDefn().GetGeomFieldCount() == 1</div>
<div class="line">            <span class="keywordflow">and</span> src_lyr.GetGeometryColumn()</div>
<div class="line">        ):</div>
<div class="line">            write_options.append(<span class="stringliteral">&quot;GEOMETRY_NAME=&quot;</span> + src_lyr.GetGeometryColumn())</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">            array = stream.GetNextRecordBatch()</div>
<div class="line">            <span class="keywordflow">if</span> array <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">                <span class="keywordflow">break</span></div>
<div class="line">            out_lyr.WriteArrowBatch(schema, array, write_options)</div>
</div><!-- fragment --><p>This method and CreateFeature() are mutually exclusive in the same session.</p>
<p>This method is the same as the C++ method <a class="el" href="classOGRLayer.html#adaaae8cb73e0e45d6eb8a06a44b4836c" title="Writes a batch of rows from an ArrowArray.">OGRLayer::WriteArrowBatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLayer</td><td>Layer. </td></tr>
    <tr><td class="paramname">schema</td><td>Schema of array. </td></tr>
    <tr><td class="paramname">array</td><td>Array of type struct. It may be released (array-&gt;release==NULL) after calling this method. </td></tr>
    <tr><td class="paramname">papszOptions</td><td>Options. Null terminated list, or nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of success </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.8 </dd></dl>

</div>
</div>
<a id="af5a860f0e94cfc2bb1997ca532ee40a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a860f0e94cfc2bb1997ca532ee40a8">&#9670;&nbsp;</a></span>OGR_RangeFldDomain_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a> OGR_RangeFldDomain_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">OGRFieldType</a>&#160;</td>
          <td class="paramname"><em>eFieldType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a24d96814a798fa79bffd2b8ce6135284">OGRFieldSubType</a>&#160;</td>
          <td class="paramname"><em>eFieldSubType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>psMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMinIsInclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>psMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMaxIsInclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new range field domain. </p>
<p>This is the same as the C++ method OGRRangeFieldDomain::OGRRangeFieldDomain().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>Domain name. Should not be NULL. </td></tr>
    <tr><td class="paramname">pszDescription</td><td>Domain description (can be NULL) </td></tr>
    <tr><td class="paramname">eFieldType</td><td>Field type. Among OFTInteger, OFTInteger64, OFTReal and OFTDateTime. </td></tr>
    <tr><td class="paramname">eFieldSubType</td><td>Field subtype. </td></tr>
    <tr><td class="paramname">psMin</td><td>Minimum value (can be NULL). The member in the union that is read is consistent with eFieldType </td></tr>
    <tr><td class="paramname">bMinIsInclusive</td><td>Whether the minimum value is included in the range. </td></tr>
    <tr><td class="paramname">psMax</td><td>Maximum value (can be NULL). The member in the union that is read is consistent with eFieldType </td></tr>
    <tr><td class="paramname">bMaxIsInclusive</td><td>Whether the maximum value is included in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new handle that should be freed with <a class="el" href="ogr__api_8h.html#a5b56883e79d620e4cf585e64f323787b" title="Destroy a field domain.">OGR_FldDomain_Destroy()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a60e498eb7b31e2e4bda104286b019bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e498eb7b31e2e4bda104286b019bf0">&#9670;&nbsp;</a></span>OGR_RangeFldDomain_GetMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="unionOGRField.html">OGRField</a>* OGR_RangeFldDomain_GetMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbIsInclusiveOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum value. </p>
<p>Which member in the returned <a class="el" href="unionOGRField.html" title="OGRFeature field attribute value union.">OGRField</a> enum must be read depends on the field type.</p>
<p>If no maximum value is set, the <a class="el" href="ogr__api_8h.html#ae23095c63fc350d712940bdbf440bbcb" title="Returns whether a raw field is unset.">OGR_RawField_IsUnset()</a> will return true when called on the result.</p>
<p>This is the same as the C++ method <a class="el" href="classOGRRangeFieldDomain.html#ab6a974a169d7af890ad9d998ffdfe562" title="Get the maximum value.">OGRRangeFieldDomain::GetMax()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
    <tr><td class="paramname">pbIsInclusiveOut</td><td>set to true if the maximum is included in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum value. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a464d587e32614ff09117cb2b1d9aa217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464d587e32614ff09117cb2b1d9aa217">&#9670;&nbsp;</a></span>OGR_RangeFldDomain_GetMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="unionOGRField.html">OGRField</a>* OGR_RangeFldDomain_GetMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aafbd7571f377f30aac50ed2b22cd9bc7">OGRFieldDomainH</a>&#160;</td>
          <td class="paramname"><em>hFieldDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbIsInclusiveOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum value. </p>
<p>Which member in the returned <a class="el" href="unionOGRField.html" title="OGRFeature field attribute value union.">OGRField</a> enum must be read depends on the field type.</p>
<p>If no minimum value is set, the <a class="el" href="ogr__api_8h.html#ae23095c63fc350d712940bdbf440bbcb" title="Returns whether a raw field is unset.">OGR_RawField_IsUnset()</a> will return true when called on the result.</p>
<p>This is the same as the C++ method <a class="el" href="classOGRRangeFieldDomain.html#a08ba0fde56803e9f89020361ee10d190" title="Get the minimum value.">OGRRangeFieldDomain::GetMin()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hFieldDomain</td><td>Field domain handle. </td></tr>
    <tr><td class="paramname">pbIsInclusiveOut</td><td>set to true if the minimum is included in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum value. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="aa9a401e6dbd5577396b567791cf85115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a401e6dbd5577396b567791cf85115">&#9670;&nbsp;</a></span>OGR_RawField_IsNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_RawField_IsNull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a raw field is null. </p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#aa4d08c0ac3b9624955e682a9a2afe2b1" title="Test if a field is null.">OGR_F_IsFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="ae23095c63fc350d712940bdbf440bbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23095c63fc350d712940bdbf440bbcb">&#9670;&nbsp;</a></span>OGR_RawField_IsUnset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_RawField_IsUnset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a raw field is unset. </p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#abb018a9030ed76353ae26082deaaef11" title="Test if a field has ever been assigned a value or not.">OGR_F_IsFieldSet()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="acf6c613c24de0e11fe259e86160157d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6c613c24de0e11fe259e86160157d3">&#9670;&nbsp;</a></span>OGR_RawField_SetNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_RawField_SetNull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw field as null. </p>
<p>This should be called on a un-initialized field. In particular this will not free any memory dynamically allocated.</p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#a090a6a8d699d4eed977ce9fcf028137a" title="Clear a field, marking it as null.">OGR_F_SetFieldNull()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="acaac3d8e8d01fa83a52dd2d95aac0cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaac3d8e8d01fa83a52dd2d95aac0cc3">&#9670;&nbsp;</a></span>OGR_RawField_SetUnset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_RawField_SetUnset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionOGRField.html">OGRField</a> *&#160;</td>
          <td class="paramname"><em>puField</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw field as unset. </p>
<p>This should be called on a un-initialized field. In particular this will not free any memory dynamically allocated.</p>
<p>Note: this function is rather low-level and should be rarely used in client code. Use instead <a class="el" href="ogr__api_8h.html#aa70b7675a003141e63f9603c752ee22e" title="Clear a field, marking it as unset.">OGR_F_UnsetField()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">puField</td><td>pointer to raw field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.2 </dd></dl>

</div>
</div>
<a id="af358ec087124f355fca02bf33a1e0027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358ec087124f355fca02bf33a1e0027">&#9670;&nbsp;</a></span>OGR_SM_AddPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_AddPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a part (style tool) to the current style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a3b893dd11e0f009fca53bf42d16abf47" title="Add a part (style tool) to the current style.">OGRStyleMgr::AddPart()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">hST</td><td>the style tool defining the part to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on errors. </dd></dl>

</div>
</div>
<a id="a358c1558e61951b2e1e338ead8401ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358c1558e61951b2e1e338ead8401ad8">&#9670;&nbsp;</a></span>OGR_SM_AddStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_AddStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a style to the current style table. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#ae0846db4a996586b38ea31e69e71b697" title="Add a style to the current style table.">OGRStyleMgr::AddStyle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">pszStyleName</td><td>the name of the style to add. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>the style string to use, or NULL to use the style stored in the manager.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on errors. </dd></dl>

</div>
</div>
<a id="ab30cc732f956f17bbd13995bc648cb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30cc732f956f17bbd13995bc648cb0a">&#9670;&nbsp;</a></span>OGR_SM_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a> OGR_SM_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOGRStyleMgr.html" title="This class represents a style manager.">OGRStyleMgr</a> factory. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#af360b6a3d0fee4af9a7716fb2a563269" title="Constructor.">OGRStyleMgr::OGRStyleMgr()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>pointer to <a class="el" href="classOGRStyleTable.html" title="This class represents a style table.">OGRStyleTable</a> or NULL if not working with a style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the new style manager object. </dd></dl>

</div>
</div>
<a id="a474fca7d9327da916305ec1276a57443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474fca7d9327da916305ec1276a57443">&#9670;&nbsp;</a></span>OGR_SM_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_SM_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Style Manager. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a534a68c59c66901a6fc01d72130337ae" title="Destructor.">OGRStyleMgr::~OGRStyleMgr()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61d4e04abb6e3c59ed570c62dffc4164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d4e04abb6e3c59ed570c62dffc4164">&#9670;&nbsp;</a></span>OGR_SM_GetPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> OGR_SM_GetPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPartId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a part (style tool) from the current style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a49a82adac48cbd82bfe5c7bb2ccf8376" title="Fetch a part (style tool) from the current style.">OGRStyleMgr::GetPart()</a>.</p>
<p>This function instantiates a new object that should be freed with <a class="el" href="ogr__api_8h.html#a5d1ecf398ee062f3f5a297f70244497a" title="Destroy Style Tool.">OGR_ST_Destroy()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">nPartId</td><td>the part number (0-based index). </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>(optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRStyleToolH of the requested part (style tools) or NULL on error. </dd></dl>

</div>
</div>
<a id="ad272704a535c0fa8cfd7b097eb4968dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad272704a535c0fa8cfd7b097eb4968dc">&#9670;&nbsp;</a></span>OGR_SM_GetPartCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_GetPartCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of parts in a style. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a5745b19d32448c321fcb0e0e9c88843b" title="Get the number of parts in a style.">OGRStyleMgr::GetPartCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>(optional) the style string on which to operate. If NULL then the current style string stored in the style manager is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of parts (style tools) in the style. </dd></dl>

</div>
</div>
<a id="afca737ee6586ce8078b52108707b0b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca737ee6586ce8078b52108707b0b6a">&#9670;&nbsp;</a></span>OGR_SM_InitFromFeature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_SM_InitFromFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#aa4ebb4d695364da5635718ec664b95bf">OGRFeatureH</a>&#160;</td>
          <td class="paramname"><em>hFeat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize style manager from the style string of a feature. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#adadbb0a44c3ca3bd11801ee64568d2a6" title="Initialize style manager from the style string of a feature.">OGRStyleMgr::InitFromFeature()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">hFeat</td><td>handle to the new feature from which to read the style.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the style string read from the feature, or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ade49bffec1e796ddf4419f5cbe34fda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade49bffec1e796ddf4419f5cbe34fda8">&#9670;&nbsp;</a></span>OGR_SM_InitStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_SM_InitStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a52e20dd0f2767e72fdf1cd84bfa58edd">OGRStyleMgrH</a>&#160;</td>
          <td class="paramname"><em>hSM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize style manager from the style string. </p>
<p>Style string can be an expanded style string (e.g. "PEN(c:#FF0000,w:5px)"), or (starting with GDAL 3.5.1), a reference to a style name starting with @ (e.g. "@my_style") registered in the associated style table.</p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleMgr.html#a31e29e999940de709c00f3e985ab3365" title="Initialize style manager from the style string.">OGRStyleMgr::InitStyleString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSM</td><td>handle to the style manager. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>the style string to use (can be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on errors. </dd></dl>

</div>
</div>
<a id="afb15db531e15a484e7bda8e88383ea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb15db531e15a484e7bda8e88383ea3a">&#9670;&nbsp;</a></span>OGR_ST_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a> OGR_ST_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a999df73d8937a8c3f553103956352817">OGRSTClassId</a>&#160;</td>
          <td class="paramname"><em>eClassId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> factory. </p>
<p>This function is a constructor for <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> derived classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eClassId</td><td>subclass of style tool to create. One of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the new style tool object or NULL if the creation failed. </dd></dl>

</div>
</div>
<a id="a5d1ecf398ee062f3f5a297f70244497a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1ecf398ee062f3f5a297f70244497a">&#9670;&nbsp;</a></span>OGR_ST_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Style Tool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96082cdf432271acfa3b3777c3be853b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96082cdf432271acfa3b3777c3be853b">&#9670;&nbsp;</a></span>OGR_ST_GetParamDbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGR_ST_GetParamDbl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bValueIsNull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool parameter value as a double. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' GetParamDbl() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">bValueIsNull</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameter value as double and sets bValueIsNull. </dd></dl>

</div>
</div>
<a id="ad4168832561881cb75dcc7c35935cdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4168832561881cb75dcc7c35935cdd3">&#9670;&nbsp;</a></span>OGR_ST_GetParamNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_ST_GetParamNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bValueIsNull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool parameter value as an integer. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' GetParamNum() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">bValueIsNull</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameter value as integer and sets bValueIsNull. </dd></dl>

</div>
</div>
<a id="aecadf5738c3b96093605b352a95869f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecadf5738c3b96093605b352a95869f1">&#9670;&nbsp;</a></span>OGR_ST_GetParamStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_ST_GetParamStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bValueIsNull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool parameter value as string. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' GetParamStr() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">bValueIsNull</td><td>pointer to an integer that will be set to TRUE or FALSE to indicate whether the parameter value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameter value as string and sets bValueIsNull. </dd></dl>

</div>
</div>
<a id="a906f5e2b901413a0ab5fa35d649847fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906f5e2b901413a0ab5fa35d649847fc">&#9670;&nbsp;</a></span>OGR_ST_GetRGBFromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_ST_GetRGBFromString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnRed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnGreen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnBlue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format. </p>
<p>Maps to <a class="el" href="classOGRStyleTool.html#ac52668cd3fe4b74860137d36f6e9f0d4" title="Return the r,g,b,a components of a color encoded in #RRGGBB[AA] format.">OGRStyleTool::GetRGBFromString()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">pszColor</td><td>the color to parse </td></tr>
    <tr><td class="paramname">pnRed</td><td>pointer to an int in which the red value will be returned </td></tr>
    <tr><td class="paramname">pnGreen</td><td>pointer to an int in which the green value will be returned </td></tr>
    <tr><td class="paramname">pnBlue</td><td>pointer to an int in which the blue value will be returned </td></tr>
    <tr><td class="paramname">pnAlpha</td><td>pointer to an int in which the (optional) alpha value will be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the color could be successfully parsed, or FALSE in case of errors. </dd></dl>

</div>
</div>
<a id="a4089c70ce3b1cbea0e45c3375d5093f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4089c70ce3b1cbea0e45c3375d5093f0">&#9670;&nbsp;</a></span>OGR_ST_GetStyleString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_ST_GetStyleString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the style string for this Style Tool. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' GetStyleString() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style string for this style tool or "" if the hST is invalid. </dd></dl>

</div>
</div>
<a id="aae8d0ee36b82c9d1d8d1a0e9b36f2d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8d0ee36b82c9d1d8d1a0e9b36f2d35">&#9670;&nbsp;</a></span>OGR_ST_GetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#a999df73d8937a8c3f553103956352817">OGRSTClassId</a> OGR_ST_GetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine type of Style Tool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style tool type, one of OGRSTCPen (1), OGRSTCBrush (2), OGRSTCSymbol (3) or OGRSTCLabel (4). Returns OGRSTCNone (0) if the OGRStyleToolH is invalid. </dd></dl>

</div>
</div>
<a id="afb52e40f289848d1f228849b6dae2463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb52e40f289848d1f228849b6dae2463">&#9670;&nbsp;</a></span>OGR_ST_GetUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#aac601656ab03334951883a7041fc0482">OGRSTUnitId</a> OGR_ST_GetUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Style Tool units. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style tool units. </dd></dl>

</div>
</div>
<a id="a764f52f8a72e950d0a5d84b7a7b37fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764f52f8a72e950d0a5d84b7a7b37fc8">&#9670;&nbsp;</a></span>OGR_ST_SetParamDbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamDbl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool parameter value from a double. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' SetParamDbl() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">dfValue</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0397850aed3282865b444d65d2deb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0397850aed3282865b444d65d2deb0e">&#9670;&nbsp;</a></span>OGR_ST_SetParamNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool parameter value from an integer. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' SetParamNum() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">nValue</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88e9561d9a62d6f8368d526eb0468b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e9561d9a62d6f8368d526eb0468b3a">&#9670;&nbsp;</a></span>OGR_ST_SetParamStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetParamStr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool parameter value from a string. </p>
<p>Maps to the <a class="el" href="classOGRStyleTool.html" title="This class represents a style tool.">OGRStyleTool</a> subclasses' SetParamStr() methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eParam</td><td>the parameter id from the enumeration corresponding to the type of this style tool (one of the OGRSTPenParam, OGRSTBrushParam, OGRSTSymbolParam or OGRSTLabelParam enumerations) </td></tr>
    <tr><td class="paramname">pszValue</td><td>the new parameter value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9c5b94e6ca32cd53c6a7a9ebc73012c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c5b94e6ca32cd53c6a7a9ebc73012c">&#9670;&nbsp;</a></span>OGR_ST_SetUnit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_ST_SetUnit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a92f1ce388fcfa9dfcedf873eb417e1c5">OGRStyleToolH</a>&#160;</td>
          <td class="paramname"><em>hST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#aac601656ab03334951883a7041fc0482">OGRSTUnitId</a>&#160;</td>
          <td class="paramname"><em>eUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfGroundPaperScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Style Tool units. </p>
<p>This function is the same as <a class="el" href="classOGRStyleTool.html#abfc35434fef971aa98be8f15059a81da" title="Set Style Tool units.">OGRStyleTool::SetUnit()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hST</td><td>handle to the style tool. </td></tr>
    <tr><td class="paramname">eUnit</td><td>the new unit. </td></tr>
    <tr><td class="paramname">dfGroundPaperScale</td><td>ground to paper scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacd2a4f109627f282c42229eaad7cdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd2a4f109627f282c42229eaad7cdfd">&#9670;&nbsp;</a></span>OGR_STBL_AddStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_AddStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszStyleString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new style in the table. </p>
<p>No comparison will be done on the Style string, only on the name. This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#aff722d3fc7c167259dd79986a2574993" title="Add a new style in the table.">OGRStyleTable::AddStyle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name the style to add. </td></tr>
    <tr><td class="paramname">pszStyleString</td><td>the style string to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a id="a98697c161a0d07fd2f81b3129deddb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98697c161a0d07fd2f81b3129deddb36">&#9670;&nbsp;</a></span>OGR_STBL_Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a> OGR_STBL_Create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOGRStyleTable.html" title="This class represents a style table.">OGRStyleTable</a> factory. </p>
<p>This function is the same as the C++ method OGRStyleTable::OGRStyleTable().</p>
<dl class="section return"><dt>Returns</dt><dd>a handle to the new style table object. </dd></dl>

</div>
</div>
<a id="a5cf4e22eb7ef07c4a3249c21dce48764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf4e22eb7ef07c4a3249c21dce48764">&#9670;&nbsp;</a></span>OGR_STBL_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_STBL_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hSTBL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy Style Table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSTBL</td><td>handle to the style table to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57ca305147b3b5a6c3f5fafaee7bc06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ca305147b3b5a6c3f5fafaee7bc06a">&#9670;&nbsp;</a></span>OGR_STBL_Find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_Find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a style string by name. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a83347c8a447e454b825784c8f7ce1661" title="Get a style string by name.">OGRStyleTable::Find()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszName</td><td>the name of the style string to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the style string matching the name or NULL if not found or error. </dd></dl>

</div>
</div>
<a id="af8214328c6866f0eb85bba376d94a05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8214328c6866f0eb85bba376d94a05e">&#9670;&nbsp;</a></span>OGR_STBL_GetLastStyleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_GetLastStyleName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the style name of the last style string fetched with OGR_STBL_GetNextStyle. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#afc78310da48449b9f6a79d20d73e5944" title="Get style name by style string.">OGRStyleTable::GetStyleName()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Name of the last style string or NULL on error. </dd></dl>

</div>
</div>
<a id="ad901a29f17b139108cc6390b9a075e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad901a29f17b139108cc6390b9a075e89">&#9670;&nbsp;</a></span>OGR_STBL_GetNextStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* OGR_STBL_GetNextStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next style string from the table. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a51ec658481656b3a3c7748622924eaf5" title="Get the next style string from the table.">OGRStyleTable::GetNextStyle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next style string or NULL on error. </dd></dl>

</div>
</div>
<a id="aed731a5a6fbedde73ed5063d62f3004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed731a5a6fbedde73ed5063d62f3004e">&#9670;&nbsp;</a></span>OGR_STBL_LoadStyleTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_LoadStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a style table from a file. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a1d8b2702ca6c6469d03316b6c9341739" title="Load a style table from a file.">OGRStyleTable::LoadStyleTable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>the name of the file to load from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a id="a69ccd53d6d374d66d42266b3543509f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ccd53d6d374d66d42266b3543509f7">&#9670;&nbsp;</a></span>OGR_STBL_ResetStyleStringReading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGR_STBL_ResetStyleStringReading </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the next style pointer to 0. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#aeb0398e3eb69ff4bacebf5fb928f5482" title="Reset the next style pointer to 0.">OGRStyleTable::ResetStyleStringReading()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3e3aca0d4f3fefe3dd64da65814dda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e3aca0d4f3fefe3dd64da65814dda7">&#9670;&nbsp;</a></span>OGR_STBL_SaveStyleTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGR_STBL_SaveStyleTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ade9fad6abd55f6760170e0e47a7455d8">OGRStyleTableH</a>&#160;</td>
          <td class="paramname"><em>hStyleTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a style table to a file. </p>
<p>This function is the same as the C++ method <a class="el" href="classOGRStyleTable.html#a5395e712fa91a3d26f6aed779760983c" title="Save a style table to a file.">OGRStyleTable::SaveStyleTable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStyleTable</td><td>handle to the style table. </td></tr>
    <tr><td class="paramname">pszFilename</td><td>the name of the file to save to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a id="a74f64386be8d675e8da33d289ccc9892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f64386be8d675e8da33d289ccc9892">&#9670;&nbsp;</a></span>OGRBuildPolygonFromEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a> OGRBuildPolygonFromEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bBestEffort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bAutoClose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> *&#160;</td>
          <td class="paramname"><em>peErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a ring from a bunch of arcs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hLines</td><td>handle to an <a class="el" href="classOGRGeometryCollection.html" title="A collection of 1 or more geometry objects.">OGRGeometryCollection</a> (or <a class="el" href="classOGRMultiLineString.html" title="A collection of OGRLineString.">OGRMultiLineString</a>) containing the line string geometries to be built into rings. </td></tr>
    <tr><td class="paramname">bBestEffort</td><td>not yet implemented???. </td></tr>
    <tr><td class="paramname">bAutoClose</td><td>indicates if the ring should be close when first and last points of the ring are the same. </td></tr>
    <tr><td class="paramname">dfTolerance</td><td>tolerance into which two arcs are considered close enough to be joined. </td></tr>
    <tr><td class="paramname">peErr</td><td>OGRERR_NONE on success, or OGRERR_FAILURE on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a handle to the new geometry, a polygon. </dd></dl>

</div>
</div>
<a id="ae5d5a052ed1046ec85236fe4a92733e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d5a052ed1046ec85236fe4a92733e2">&#9670;&nbsp;</a></span>OGRCleanupAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRCleanupAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean-up all drivers (including raster ones starting with GDAL 2.0. </p>
<p>See <a class="el" href="gdal_8h.html#a4769d3eda338f797b30405062deb9180" title="Destroy the driver manager.">GDALDestroyDriverManager()</a> </p>

</div>
</div>
<a id="ad70e09598881642379f42d7d7f3281a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70e09598881642379f42d7d7f3281a9">&#9670;&nbsp;</a></span>OGRCreatePreparedGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a> OGRCreatePreparedGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a prepared geometry. </p>
<p>To free with <a class="el" href="ogr__api_8h.html#abd20f8ac4f660a63d0378ef5a8047727" title="Destroys a prepared geometry.">OGRDestroyPreparedGeometry()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeom</td><td>input geometry to prepare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to a prepared geometry. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="abd20f8ac4f660a63d0378ef5a8047727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd20f8ac4f660a63d0378ef5a8047727">&#9670;&nbsp;</a></span>OGRDestroyPreparedGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRDestroyPreparedGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a>&#160;</td>
          <td class="paramname"><em>hPreparedGeom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a prepared geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hPreparedGeom</td><td>preprated geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="a88df313ed48b64f371fbbd7ac4021550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88df313ed48b64f371fbbd7ac4021550">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a> OGRGeomCoordinatePrecisionCreate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>. </p>
<p>The default X,Y,Z,M resolutions are set to OGR_GEOM_COORD_PRECISION_UNKNOWN.</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="aa8ba15322c93ff0113335525dd6a062f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ba15322c93ff0113335525dd6a062f">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeomCoordinatePrecisionDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance or nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a48dfcd9e95e5cf41962f2b910160f017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dfcd9e95e5cf41962f2b910160f017">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionGetFormats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** OGRGeomCoordinatePrecisionGetFormats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of format names for coordinate precision format specific options. </p>
<p>An example of a supported value for pszFormatName is "FileGeodatabase" for layers of the OpenFileGDB driver.</p>
<p>The returned values may be used for the pszFormatName argument of <a class="el" href="ogr__api_8h.html#a7030715259644f64ecf8087170db5227" title="Get format specific coordinate precision options.">OGRGeomCoordinatePrecisionGetFormatSpecificOptions()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null-terminated list to free with <a class="el" href="cpl__string_8h.html#a5a39b9c5896a273cc6f06c1d5be93238" title="Free string list.">CSLDestroy()</a>, or nullptr. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a7030715259644f64ecf8087170db5227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7030715259644f64ecf8087170db5227">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionGetFormatSpecificOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a> OGRGeomCoordinatePrecisionGetFormatSpecificOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormatName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get format specific coordinate precision options. </p>
<p>An example of a supported value for pszFormatName is "FileGeodatabase" for layers of the OpenFileGDB driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
    <tr><td class="paramname">pszFormatName</td><td>A format name (one of those returned by <a class="el" href="ogr__api_8h.html#a48dfcd9e95e5cf41962f2b910160f017" title="Get the list of format names for coordinate precision format specific options.">OGRGeomCoordinatePrecisionGetFormats()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a null-terminated list, or nullptr. The list must <em>not</em> be freed, and is owned by hGeomCoordPrec </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a6b92ec14b6fd2ee458aa3f47f3d9ac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b92ec14b6fd2ee458aa3f47f3d9ac93">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionGetMResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeomCoordinatePrecisionGetMResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the M resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the the M resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> or OGR_GEOM_COORD_PRECISION_UNKNOWN </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a9fb8a87a442b07ccd069ddf913608585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb8a87a442b07ccd069ddf913608585">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionGetXYResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeomCoordinatePrecisionGetXYResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the X/Y resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the the X/Y resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> or OGR_GEOM_COORD_PRECISION_UNKNOWN </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a13d1a1049ef521c7072dd9e840db9567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d1a1049ef521c7072dd9e840db9567">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionGetZResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double OGRGeomCoordinatePrecisionGetZResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Z resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the the Z resolution of a <a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> or OGR_GEOM_COORD_PRECISION_UNKNOWN </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ade4d3a7bfc56898febdde93ad542ead3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4d3a7bfc56898febdde93ad542ead3">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeomCoordinatePrecisionSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXYResolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZResolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMResolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the resolution of the geometry coordinate components. </p>
<p>For the X, Y and Z ordinates, the precision should be expressed in the units of the CRS of the geometry. So typically degrees for geographic CRS, or meters/feet/US-feet for projected CRS. Users might use <a class="el" href="ogr__api_8h.html#aacb9249dce947c203e640ce432547703" title="Set the resolution of the geometry coordinate components.">OGRGeomCoordinatePrecisionSetFromMeter()</a> for an even more convenient interface.</p>
<p>For a projected CRS with meters as linear unit, 1e-3 corresponds to a millimetric precision. For a geographic CRS in 8.9e-9 corresponds to a millimetric precision (for a Earth CRS)</p>
<p>Resolution should be stricty positive, or set to OGR_GEOM_COORD_PRECISION_UNKNOWN when unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
    <tr><td class="paramname">dfXYResolution</td><td>Resolution for for X and Y coordinates. </td></tr>
    <tr><td class="paramname">dfZResolution</td><td>Resolution for for Z coordinates. </td></tr>
    <tr><td class="paramname">dfMResolution</td><td>Resolution for for M coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a4b74fbc01b7c28024d1c0d67d5f9a2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b74fbc01b7c28024d1c0d67d5f9a2b7">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionSetFormatSpecificOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeomCoordinatePrecisionSetFormatSpecificOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszFormatName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cpl__port_8h.html#ad6399986f130f30db93917dd65434a06">CSLConstList</a>&#160;</td>
          <td class="paramname"><em>papszOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set format specific coordinate precision options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
    <tr><td class="paramname">pszFormatName</td><td>A format name (must not be null) </td></tr>
    <tr><td class="paramname">papszOptions</td><td>null-terminated list of options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="aacb9249dce947c203e640ce432547703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb9249dce947c203e640ce432547703">&#9670;&nbsp;</a></span>OGRGeomCoordinatePrecisionSetFromMeter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRGeomCoordinatePrecisionSetFromMeter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hGeomCoordPrec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a23361112dba57d043fa64632348c0870">OGRSpatialReferenceH</a>&#160;</td>
          <td class="paramname"><em>hSRS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfXYMeterResolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfZMeterResolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dfMResolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the resolution of the geometry coordinate components. </p>
<p>For the X, Y and Z ordinates, the precision should be expressed in meter, e.g 1e-3 for millimetric precision.</p>
<p>Resolution should be stricty positive, or set to OGR_GEOM_COORD_PRECISION_UNKNOWN when unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hGeomCoordPrec</td><td><a class="el" href="structOGRGeomCoordinatePrecision.html" title="Geometry coordinate precision.">OGRGeomCoordinatePrecision</a> instance (must not be null) </td></tr>
    <tr><td class="paramname">hSRS</td><td>Spatial reference system, used for metric to SRS unit conversion (must not be null) </td></tr>
    <tr><td class="paramname">dfXYMeterResolution</td><td>Resolution for for X and Y coordinates, in meter. </td></tr>
    <tr><td class="paramname">dfZMeterResolution</td><td>Resolution for for Z coordinates, in meter. </td></tr>
    <tr><td class="paramname">dfMResolution</td><td>Resolution for for M coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a3f8080605cad5aeef9519c38fe160b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8080605cad5aeef9519c38fe160b51">&#9670;&nbsp;</a></span>OGRGetDriver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> OGRGetDriver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDriver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the indicated driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a391569a2a964a17ca4d77d32da150dc6" title="Fetch driver by index.">GDALGetDriver()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDriver</td><td>the driver index, from 0 to GetDriverCount()-1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to the driver, or NULL if iDriver is out of range. </dd></dl>

</div>
</div>
<a id="ae814db7e2212b9bbb0fd8c361bee11fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814db7e2212b9bbb0fd8c361bee11fe">&#9670;&nbsp;</a></span>OGRGetDriverByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> OGRGetDriverByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the indicated driver. </p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRSFDriver*. If a C++ object is needed, the handle should be cast to GDALDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#ae8ae868eef1e4773283d137b0a1adfc4" title="Fetch a driver based on the short name.">GDALGetDriverByName()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the driver name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the driver, or NULL if no driver with that name is found </dd></dl>

</div>
</div>
<a id="ad0f6d2bbd269b56a61d1c1841dac2575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f6d2bbd269b56a61d1c1841dac2575">&#9670;&nbsp;</a></span>OGRGetDriverCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGetDriverCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch the number of registered drivers. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#aa506c0cdcb923528f3e7d4f1dec9b4b5" title="Fetch the number of registered drivers.">GDALGetDriverCount()</a> in GDAL 2.0</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the drivers count. </dd></dl>

</div>
</div>
<a id="a6bcaa56ea34ca19dec8ef120cd34616e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcaa56ea34ca19dec8ef120cd34616e">&#9670;&nbsp;</a></span>OGRGetGEOSVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OGRGetGEOSVersion </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMajor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnMinor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pnPatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the GEOS version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnMajor</td><td>Pointer to major version number, or NULL </td></tr>
    <tr><td class="paramname">pnMinor</td><td>Pointer to minor version number, or NULL </td></tr>
    <tr><td class="paramname">pnPatch</td><td>Pointer to patch version number, or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if GDAL is built against GEOS </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.4.0 </dd></dl>

</div>
</div>
<a id="af7f6cfab316f5f22962bcd85216c4684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f6cfab316f5f22962bcd85216c4684">&#9670;&nbsp;</a></span>OGRGetNonLinearGeometriesEnabledFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRGetNonLinearGeometriesEnabledFlag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flag to enable/disable returning non-linear geometries in the C API. </p>
<p>return TRUE if non-linear geometries might be returned (default value is TRUE).</p>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ogr__api_8h.html#a31febe0b845d7cc0052767e6257e7349" title="Set flag to enable/disable returning non-linear geometries in the C API.">OGRSetNonLinearGeometriesEnabledFlag()</a> </dd></dl>

</div>
</div>
<a id="a82ea15e982aaebea0fdada8eb3248d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ea15e982aaebea0fdada8eb3248d64">&#9670;&nbsp;</a></span>OGRHasPreparedGeometrySupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRHasPreparedGeometrySupport </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if GEOS has prepared geometry support. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE </dd></dl>

</div>
</div>
<a id="a123bb02ac8c5cfe143e132f627531125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123bb02ac8c5cfe143e132f627531125">&#9670;&nbsp;</a></span>OGROpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGROpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *&#160;</td>
          <td class="paramname"><em>pahDriverList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file / data source with one of the registered drivers. </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source.</p>
<p>If this function fails, <a class="el" href="cpl__error_8h.html#a7f71ade3bb0a0e9e45802975ec59ff5e" title="Get the last error message.">CPLGetLastErrorMsg()</a> can be used to check if there is an error message explaining why.</p>
<p>For drivers supporting the VSI virtual file API, it is possible to open a file in a .zip archive (see <a class="el" href="cpl__vsi_8h.html#a884fac3cd6be2c09deb807e959d78b3a" title="Install ZIP file system handler.">VSIInstallZipFileHandler()</a>), in a .tar/.tar.gz/.tgz archive (see <a class="el" href="cpl__vsi_8h.html#ad6dd983338849e7da4eaa88f6458ab64" title="Install /vsitar/ file system handler.">VSIInstallTarFileHandler()</a>) or on a HTTP / FTP server (see <a class="el" href="cpl__vsi_8h.html#a4f791960f2d86713d16e99e9c0c36258" title="Install /vsicurl/ HTTP/FTP file system handler (requires libcurl)">VSIInstallCurlFileHandler()</a>)</p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a9cb8585d0b3c16726b08e25bcc94274a" title="Open a raster or vector file as a GDALDataset.">GDALOpenEx()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the file, or data source to open. </td></tr>
    <tr><td class="paramname">bUpdate</td><td>FALSE for read-only access (the default) or TRUE for read-write access. </td></tr>
    <tr><td class="paramname">pahDriverList</td><td>if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise a handle to a <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>. This <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> should be closed by deleting the object when it is no longer needed.</dd></dl>
<p><b>Example:</b></p>
<pre>
  OGRDataSourceH        hDS;
  OGRSFDriverH        *pahDriver;

  hDS = OGROpen( "polygon.shp", 0, pahDriver );
  if( hDS == NULL )
  {
      return;
  }

  ... use the data source ...

  OGRReleaseDataSource( hDS );
</pre> 
</div>
</div>
<a id="aff0a37e24d4acaa8b394a0e07d7de432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0a37e24d4acaa8b394a0e07d7de432">&#9670;&nbsp;</a></span>OGROpenShared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a> OGROpenShared </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pszName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#acb21d6f230ef8a5d2c1e65bf98473eca">OGRSFDriverH</a> *&#160;</td>
          <td class="paramname"><em>pahDriverList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file / data source with one of the registered drivers if not already opened, or increment reference count of already opened data source previously opened with <a class="el" href="ogr__api_8h.html#aff0a37e24d4acaa8b394a0e07d7de432" title="Open a file / data source with one of the registered drivers if not already opened,...">OGROpenShared()</a> </p>
<p>This function loops through all the drivers registered with the driver manager trying each until one succeeds with the given data source.</p>
<p>If this function fails, <a class="el" href="cpl__error_8h.html#a7f71ade3bb0a0e9e45802975ec59ff5e" title="Get the last error message.">CPLGetLastErrorMsg()</a> can be used to check if there is an error message explaining why.</p>
<p>NOTE: Starting with GDAL 2.0, it is <em>NOT</em> safe to cast the returned handle to OGRDataSource*. If a C++ object is needed, the handle should be cast to GDALDataset*. Similarly, the returned OGRSFDriverH handle should be cast to GDALDriver*, and NOT* OGRSFDriver*.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a9cb8585d0b3c16726b08e25bcc94274a" title="Open a raster or vector file as a GDALDataset.">GDALOpenEx()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszName</td><td>the name of the file, or data source to open. </td></tr>
    <tr><td class="paramname">bUpdate</td><td>FALSE for read-only access (the default) or TRUE for read-write access. </td></tr>
    <tr><td class="paramname">pahDriverList</td><td>if non-NULL, this argument will be updated with a pointer to the driver which was used to open the data source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error or if the pass name is not supported by this driver, otherwise a handle to a <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a>. This <a class="el" href="classGDALDataset.html" title="A set of associated raster bands, usually from one file.">GDALDataset</a> should be closed by deleting the object when it is no longer needed.</dd></dl>
<p><b>Example:</b></p>
<pre>
  OGRDataSourceH  hDS;
  OGRSFDriverH        *pahDriver;

  hDS = OGROpenShared( "polygon.shp", 0, pahDriver );
  if( hDS == NULL )
  {
      return;
  }

  ... use the data source ...

  OGRReleaseDataSource( hDS );
</pre> 
</div>
</div>
<a id="adb67db2345c1599239a5f46b57bf4ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb67db2345c1599239a5f46b57bf4ea2">&#9670;&nbsp;</a></span>OGRPreparedGeometryContains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRPreparedGeometryContains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a>&#160;</td>
          <td class="paramname"><em>hPreparedGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOtherGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a prepared geometry contains a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hPreparedGeom</td><td>prepared geometry. </td></tr>
    <tr><td class="paramname">hOtherGeom</td><td>other geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE. </dd></dl>

</div>
</div>
<a id="ade5d8dbcfc8ba66adcc26181f8a8337d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5d8dbcfc8ba66adcc26181f8a8337d">&#9670;&nbsp;</a></span>OGRPreparedGeometryIntersects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRPreparedGeometryIntersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ogr__api_8h.html#adc1edf7eb8c3b0dadf4cc9cdbb777ad3">OGRPreparedGeometryH</a>&#160;</td>
          <td class="paramname"><em>hPreparedGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="ogr__api_8h.html#a147386126eed05cc383cb3eb1b34104c">OGRGeometryH</a>&#160;</td>
          <td class="paramname"><em>hOtherGeom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a prepared geometry intersects with a geometry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hPreparedGeom</td><td>prepared geometry. </td></tr>
    <tr><td class="paramname">hOtherGeom</td><td>other geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.3 </dd></dl>

</div>
</div>
<a id="ae904632d0bc86ba5501921ca594e18da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae904632d0bc86ba5501921ca594e18da">&#9670;&nbsp;</a></span>OGRRegisterAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OGRRegisterAll </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register all drivers. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a9d40bc998bd6ed07ccde96028e85ae26" title="Register all known configured GDAL drivers.">GDALAllRegister()</a> in GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ad3abed0c3b232fe55a580726536fe6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3abed0c3b232fe55a580726536fe6fa">&#9670;&nbsp;</a></span>OGRReleaseDataSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ogr__core_8h.html#abd3e8d61c1e766992bdc71f846d56f65">OGRErr</a> OGRReleaseDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#ae37d6a007fbf6453a11062443c9cc2a4">OGRDataSourceH</a>&#160;</td>
          <td class="paramname"><em>hDS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop a reference to this datasource, and if the reference count drops to zero close (destroy) the datasource. </p>
<p>Internally this actually calls the OGRSFDriverRegistrar::ReleaseDataSource() method. This method is essentially a convenient alias.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>Use <a class="el" href="gdal_8h.html#a7c728fbbef87fe4929e6dd418f4035fa" title="Close GDAL dataset.">GDALClose()</a> in GDAL 2.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDS</td><td>handle to the data source to release</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>OGRERR_NONE on success or an error code. </dd></dl>

</div>
</div>
<a id="a31febe0b845d7cc0052767e6257e7349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31febe0b845d7cc0052767e6257e7349">&#9670;&nbsp;</a></span>OGRSetNonLinearGeometriesEnabledFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRSetNonLinearGeometriesEnabledFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flag to enable/disable returning non-linear geometries in the C API. </p>
<p>This flag has only an effect on the <a class="el" href="ogr__api_8h.html#a1bf9596756aeacec4da502383c378f5c" title="Fetch a handle to feature geometry.">OGR_F_GetGeometryRef()</a>, <a class="el" href="ogr__api_8h.html#a37aa8b53b1fc8816c5b7bcbbcb6a46ca" title="Fetch a handle to feature geometry.">OGR_F_GetGeomFieldRef()</a>, <a class="el" href="ogr__api_8h.html#a0adea8ce1ca795ce0a6a76505f90f078" title="Return the layer geometry type.">OGR_L_GetGeomType()</a>, <a class="el" href="ogr__api_8h.html#a323f4350c2e90c6e67df37f68d244a0d" title="Fetch geometry type of this field.">OGR_GFld_GetType()</a> and <a class="el" href="ogr__api_8h.html#add0b3a6b6062122e4f4316d194d2a1cf" title="Fetch the geometry base type of the passed feature definition.">OGR_FD_GetGeomType()</a> C API, and corresponding methods in the SWIG bindings. It is meant as making it simple for applications using the OGR C API not to have to deal with non-linear geometries, even if such geometries might be returned by drivers. In which case, they will be transformed into their closest linear geometry, by doing linear approximation, with <a class="el" href="ogr__api_8h.html#a4e5f995d159279739909196d45ba09e5" title="Convert to another geometry type.">OGR_G_ForceTo()</a>.</p>
<p>Libraries should generally <em>not</em> use that method, since that could interfere with other libraries or applications.</p>
<p>Note that it <em>does</em> not affect the behavior of the C++ API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bFlag</td><td>TRUE if non-linear geometries might be returned (default value). FALSE to ask for non-linear geometries to be approximated as linear geometries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 2.0 </dd></dl>

</div>
</div>
<a id="ac0fd87e8fdaa144dc7b3fa7dfa1f1582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fd87e8fdaa144dc7b3fa7dfa1f1582">&#9670;&nbsp;</a></span>OGRwkbExportOptionsCreate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a>* OGRwkbExportOptionsCreate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create geometry WKB export options. </p>
<p>The default is Intel order, old-OGC wkb variant and 0 discarded lsb bits.</p>
<dl class="section return"><dt>Returns</dt><dd>object to be freed with <a class="el" href="ogr__api_8h.html#a09772060693f83825a84fefccde55579" title="Destroy object returned by OGRwkbExportOptionsCreate()">OGRwkbExportOptionsDestroy()</a>. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a09772060693f83825a84fefccde55579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09772060693f83825a84fefccde55579">&#9670;&nbsp;</a></span>OGRwkbExportOptionsDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRwkbExportOptionsDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy object returned by <a class="el" href="ogr__api_8h.html#ac0fd87e8fdaa144dc7b3fa7dfa1f1582" title="Create geometry WKB export options.">OGRwkbExportOptionsCreate()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psOptions</td><td>WKB export options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a37004f0eb914340874e9da08975c76f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37004f0eb914340874e9da08975c76f7">&#9670;&nbsp;</a></span>OGRwkbExportOptionsSetByteOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRwkbExportOptionsSetByteOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a36cc1f4d807ba8f6fb8951f3adf251e2">OGRwkbByteOrder</a>&#160;</td>
          <td class="paramname"><em>eByteOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the WKB byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psOptions</td><td>WKB export options </td></tr>
    <tr><td class="paramname">eByteOrder</td><td>Byte order: wkbXDR (big-endian) or wkbNDR (little-endian, Intel) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="a45319b3639338ced05d17e543444c882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45319b3639338ced05d17e543444c882">&#9670;&nbsp;</a></span>OGRwkbExportOptionsSetPrecision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRwkbExportOptionsSetPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__api_8h.html#a3f6f27b9210fc32231a13736ee3f2916">OGRGeomCoordinatePrecisionH</a>&#160;</td>
          <td class="paramname"><em>hPrecisionOptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set precision options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psOptions</td><td>WKB export options </td></tr>
    <tr><td class="paramname">hPrecisionOptions</td><td>Precision options (might be null to reset them) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
<a id="ab68b69a13ac7f162c8a240c2daa957a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68b69a13ac7f162c8a240c2daa957a3">&#9670;&nbsp;</a></span>OGRwkbExportOptionsSetVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OGRwkbExportOptionsSetVariant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOGRwkbExportOptions.html">OGRwkbExportOptions</a> *&#160;</td>
          <td class="paramname"><em>psOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ogr__core_8h.html#a6716bd3399c31e7bc8b0fd94fd7d9ba6">OGRwkbVariant</a>&#160;</td>
          <td class="paramname"><em>eWkbVariant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the WKB variant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psOptions</td><td>WKB export options </td></tr>
    <tr><td class="paramname">eWkbVariant</td><td>variant: wkbVariantOldOgc, wkbVariantIso, wkbVariantPostGIS1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>GDAL 3.9 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
