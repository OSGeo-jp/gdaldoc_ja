<!DOCTYPE html>
<html class="writer-html5" lang="ja" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OGR SQL 方言 &mdash; GDAL  ドキュメント</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d10597a4" />
      <link rel="stylesheet" type="text/css" href="../_static/css/gdal.css?v=e152ac3b" />

  
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="canonical" href="https://gdal.org/user/ogr_sql_dialect.html"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=c033477b"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/translations.js?v=91613774"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="author" title="このドキュメントについて" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="SQL SQLite方言" href="sql_sqlite_dialect.html" />
    <link rel="prev" title="OGR SQL方言とSQLITE SQL方言" href="ogr_sql_sqlite_dialect.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../index.html">
            
              <img src="../_static/gdalicon.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../download.html">ダウンロード</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programs/index.html">プログラム</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/raster/index.html">ラスタードライバー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../drivers/vector/index.html">ベクタードライバー</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">ユーザー</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="raster_data_model.html">ラスターデータモデル</a></li>
<li class="toctree-l2"><a class="reference internal" href="multidim_raster_data_model.html">多次元ラスターデータモデル</a></li>
<li class="toctree-l2"><a class="reference internal" href="vector_data_model.html">ベクターデーターモデル</a></li>
<li class="toctree-l2"><a class="reference internal" href="gnm_data_model.html">地理ネットワークデータモデル</a></li>
<li class="toctree-l2"><a class="reference internal" href="multithreading.html">マルチスレッディング</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="ogr_sql_sqlite_dialect.html">OGR SQL方言とSQLITE SQL方言</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="ogr_sql_sqlite_dialect.html#dialects">方言</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">OGR SQL 方言</a></li>
<li class="toctree-l4"><a class="reference internal" href="sql_sqlite_dialect.html">SQL SQLite方言</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ogr_sql_sqlite_dialect.html#executesql">ExecuteSQL()</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="virtual_file_systems.html">GDAL仮想ファイルシステム</a></li>
<li class="toctree-l2"><a class="reference internal" href="ogr_feature_style.html">Feature Style Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="coordinate_epoch.html">Coordinate epoch support</a></li>
<li class="toctree-l2"><a class="reference internal" href="configoptions.html">Configuration options</a></li>
<li class="toctree-l2"><a class="reference internal" href="gdal_python_utilities.html">GDAL Python Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">チュートリアル</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">開発</a></li>
<li class="toctree-l1"><a class="reference internal" href="../community/index.html">コミュニティ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sponsors/index.html">スポンサー</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">どのように貢献できますか?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">ライセンス</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDAL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html"> GDAL  ドキュメント </a> &raquo;</li>
      
          <li><a href="index.html">ユーザー向けドキュメント</a> &raquo;</li>
      
          <li><a href="ogr_sql_sqlite_dialect.html">OGR SQL方言とSQLITE SQL方言</a> &raquo;</li>
      
      <li>OGR SQL 方言</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/OSGeo/gdal/edit/master/doc/source/user/ogr_sql_dialect.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="sql_sqlite_dialect.html" class="btn btn-neutral float-right" title="SQL SQLite方言" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ogr_sql_sqlite_dialect.html" class="btn btn-neutral float-left" title="OGR SQL方言とSQLITE SQL方言" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ogr-sql-dialect">
<span id="id1"></span><h1>OGR SQL 方言<a class="headerlink" href="#ogr-sql-dialect" title="Link to this heading"></a></h1>
<p>GDALDataset は <a class="reference internal" href="../api/gdaldataset_cpp.html#_CPPv4N11GDALDataset10ExecuteSQLEPKcP11OGRGeometryPKc" title="GDALDataset::ExecuteSQL"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">GDALDataset::ExecuteSQL()</span></code></a> メソッドを使ってデータソースに対してコマンドを実行することができます. 理論的にはどんな種類のコマンドでもこの方法で処理できますが, 実際にはこのメカニズムはアプリケーションに対して SQL SELECT の機能の一部を提供するために使用されます. このページでは OGR に実装された一般的な SQL 実装と, ドライバー固有の SQL サポートに関する問題について説明します.</p>
<p><code class="docutils literal notranslate"><span class="pre">OGRSQL</span></code> 方言は, <a class="reference internal" href="../api/gdaldataset_cpp.html#_CPPv4N11GDALDataset10ExecuteSQLEPKcP11OGRGeometryPKc" title="GDALDataset::ExecuteSQL"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">GDALDataset::ExecuteSQL()</span></code></a> の方言パラメータとして渡される <code class="docutils literal notranslate"><span class="pre">OGRSQL</span></code> 文字列, または <a class="reference internal" href="../programs/ogrinfo.html#ogrinfo"><span class="std std-ref">ogrinfo</span></a> または <a class="reference internal" href="../programs/ogr2ogr.html#ogr2ogr"><span class="std std-ref">ogr2ogr</span></a> ユーティリティの <cite>-dialect</cite> オプションスイッチでリクエストすることができます.</p>
<p>代わりの方言である <code class="docutils literal notranslate"><span class="pre">SQLite</span></code> 方言は, <code class="docutils literal notranslate"><span class="pre">OGRSQL</span></code> 方言の代わりに使用することができます. 詳細については <a class="reference internal" href="sql_sqlite_dialect.html#sql-sqlite-dialect"><span class="std std-ref">SQL SQLite方言</span></a> ページを参照してください.</p>
<p>OGRLayer クラスは <a class="reference internal" href="../api/ogrlayer_cpp.html#_CPPv4N8OGRLayer18SetAttributeFilterEPKc" title="OGRLayer::SetAttributeFilter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">OGRLayer::SetAttributeFilter()</span></code></a> メソッドを使用して返される地物に属性クエリフィルタを適用することもサポートしています. 属性フィルタの構文は OGR SQL SELECT 文の WHERE 句と同じです. したがって, WHERE 句に関するすべてのことは <code class="docutils literal notranslate"><span class="pre">SetAttributeFilter()</span></code> メソッドのコンテキストで適用されます.</p>
<section id="select">
<h2>SELECT<a class="headerlink" href="#select" title="Link to this heading"></a></h2>
<p>SELECT ステートメントは, レイヤーの地物 (RDBMS のテーブル行に類似) を取得するために使用されます. クエリの結果は地物の一時的なレイヤーとして表されます. データソースのレイヤーは RDBMS のテーブルに類似し, 地物の属性は列値に類似しています. OGR SQL SELECT ステートメントの最も単純な形式は次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<p>この場合, &quot;polylayer&quot; という名前のレイヤーからすべての地物が取得され, それらの地物のすべての属性が返されます. これは基本的にレイヤーに直接アクセスするのと同等です. この例では, &quot;*&quot; はレイヤーから取得するフィールドのリストで, &quot;*&quot; はすべてのフィールドを取得することを意味します.</p>
<p>この少し洗練された形式は, レイヤーからすべての地物を取得しますが, スキーマにはジオメトリ列と EAS_ID および PROP_VALUE 属性のみが含まれます. OGR SQL 方言では, ジオメトリ列は常に結果に含まれるため, SQL ステートメントに表示する必要はありません.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">eas_id</span><span class="p">,</span><span class="w"> </span><span class="n">prop_value</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<p>WHERE 句で取得する地物を制限し, 結果をソートするより野心的な SELECT は次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">polylayer</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">prop_value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">220000</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">prop_value</span><span class="w"> </span><span class="k">DESC</span>
</pre></div>
</div>
<p>この SELECT ステートメントは, ジオメトリと eas_id 属性の異なる値の数を含む 1 つの属性 (&quot;count_eas_id&quot; のような名前) を持つ 1 つの地物のみを生成します.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">eas_id</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<section id="general-syntax">
<h3>一般的な構文<a class="headerlink" href="#general-syntax" title="Link to this heading"></a></h3>
<p>SELECT ステートメントの一般的な構文は次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="p">[</span><span class="n">fields</span><span class="p">]</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">layer_name</span><span class="w"> </span><span class="p">[</span><span class="k">JOIN</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">[</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">[</span><span class="k">LIMIT</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">[</span><span class="k">OFFSET</span><span class="w"> </span><span class="p">...]</span>
</pre></div>
</div>
</section>
<section id="list-operators">
<h3>リスト演算子<a class="headerlink" href="#list-operators" title="Link to this heading"></a></h3>
<p>フィールドリストは, 出力地物にソースレイヤーから持ち込まれるフィールドのカンマ区切りリストです. フィールドリストに表示される順序で出力地物に表示されるため, フィールドリストを使用してフィールドの順序を変更することができます. 特殊文字 <code class="docutils literal notranslate"><span class="pre">*</span></code> は &quot;すべてのフィールド&quot; を意味します. <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">EXCLUDE</span> <span class="pre">([fields])</span></code> 構文を使用して, 括弧内にリストされていないすべてのフィールドを選択することができます.</p>
<p>フィールドリストの特殊な形式は, DISTINCT キーワードを使用します. これは, 指定された属性のすべての異なる値のリストを返します. DISTINCT キーワードが使用されると, フィールドリストには 1 つの属性のみが表示されます. DISTINCT キーワードは, どの種類のフィールドに対しても使用できます. 現在, OGR SQL では文字列値に対する DISTINCT テストは大文字小文字を区別しません. DISTINCT キーワードを使用した SELECT の結果は, 1 つの列 (操作されたフィールドと同じ名前) を持つレイヤーであり, 異なる値ごとに 1 つの地物があります. ジオメトリは破棄されます. 異なる値はメモリ内で組み立てられるため, 大量のメモリが使用される可能性があります.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">areacode</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<p>列に適用できるいくつかの集計演算子もあります. 1 つのフィールドに集計演算子が適用されると, すべてのフィールドに集計演算子が適用される必要があります. 集計演算子は次のとおりです:</p>
<ul class="simple">
<li><p>COUNT: インスタンスの数</p></li>
<li><p>AVG: 数値の平均:</p></li>
<li><p>SUM: 数値の合計</p></li>
<li><p>MIN: レキシカルまたは数値の最小値</p></li>
<li><p>MAX: レキシカルまたは数値の最大値</p></li>
<li><p>STDDEV_POP: (GDAL &gt;= 3.10) 数値 <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_deviation#Population_standard_deviation">母集団標準偏差</a>.  Date/DateTime/Time フィールドに適用されると, 秒単位の値が返されます.</p></li>
<li><p>STDDEV_SAMP: (GDAL &gt;= 3.10) 数値 <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation">標本標準偏差</a>.  Date/DateTime/Time フィールドに適用されると, 秒単位の値が返されます.</p></li>
</ul>
<p>この例では, 地積の物件価値に関するさまざまな集計情報が生成されます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">MIN</span><span class="p">(</span><span class="n">prop_value</span><span class="p">),</span><span class="w"> </span><span class="k">MAX</span><span class="p">(</span><span class="n">prop_value</span><span class="p">),</span><span class="w"> </span><span class="k">AVG</span><span class="p">(</span><span class="n">prop_value</span><span class="p">),</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">prop_value</span><span class="p">),</span>
<span class="w">    </span><span class="k">COUNT</span><span class="p">(</span><span class="n">prop_value</span><span class="p">),</span><span class="w"> </span><span class="n">STDDEV_POP</span><span class="p">(</span><span class="n">prop_value</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">prov_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Ontario&#39;</span>
</pre></div>
</div>
<p>COUNT() 演算子を DISTINCT SELECT に適用して, 異なる値の数を取得することも可能です. たとえば:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">areacode</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<p>特別な場合として, COUNT() 演算子にフィールド名の代わりに &quot;*&quot; 引数を指定することができます. これはすべてのレコードをカウントするための短い形式です.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<p>フィールド名はテーブル名で接頭辞を付けることもできますが, これは結合を行う場合にのみ本当に意味があります. JOIN セクションでさらに説明されています.</p>
<p>フィールド定義は算術演算および関数演算子を使用した複雑な式にすることもできます. ただし, DISTINCT キーワードや MIN, MAX, AVG, SUM などの集計演算子は式フィールドに適用できません. ブール値の結果となる式 (比較, 論理演算子) も使用できます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">cost</span><span class="o">+</span><span class="n">tax</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">invoice</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">CONCAT</span><span class="p">(</span><span class="n">owner_first_name</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">owner_last_name</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">properties</span>
</pre></div>
</div>
<section id="functions">
<h4>関数<a class="headerlink" href="#functions" title="Link to this heading"></a></h4>
<p>SUBSTR 関数は文字列から部分文字列を抽出するために使用できます. 構文は次のようになります: SUBSTR(string_expr, start_offset [, length]). string_expr の start_offset から始まる部分文字列を抽出します (1 が string_expr の最初の文字, 2 が 2 番目の文字, など...). start_offset が負の値の場合, 部分文字列は文字列の末尾から抽出されます (-1 が文字列の最後の文字, -2 が最後の文字の前の文字, ...). length が指定されている場合, 文字列から最大 length 文字が抽出されます. それ以外の場合, 文字列の残りが抽出されます.</p>
<p>注意: 現時点では, 文字はバイトと同等と見なされており, UTF-8 のようなマルチバイトエンコーディングには適していないかもしれません.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">SUBSTR</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">xxx</span><span class="w">   </span><span class="c1">--&gt; &#39;ab&#39;</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">SUBSTR</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="w">   </span><span class="k">FROM</span><span class="w"> </span><span class="n">xxx</span><span class="w">   </span><span class="c1">--&gt; &#39;def&#39;</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">SUBSTR</span><span class="p">(</span><span class="s1">&#39;abcdef&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="w">  </span><span class="k">FROM</span><span class="w"> </span><span class="n">xxx</span><span class="w">   </span><span class="c1">--&gt; &#39;ef&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">hstore_get_value()</span></code> 関数は, 'key=&gt;value,other_key=&gt;other_value,...' のようにフォーマットされた HSTORE 文字列からキーに関連付けられた値を抽出するために使用できます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">hstore_get_value</span><span class="p">(</span><span class="s1">&#39;a =&gt; b, &quot;key with space&quot;=&gt; &quot;value with space&quot;&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;key with space&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">xxx</span><span class="w"> </span><span class="c1">--&gt; &#39;value with space&#39;</span>
</pre></div>
</div>
</section>
<section id="using-the-field-name-alias">
<h4>フィールド名別名の使用<a class="headerlink" href="#using-the-field-name-alias" title="Link to this heading"></a></h4>
<p>OGR SQL は, 以下の例に示すように, AS キーワードを使用して SQL92 仕様に従ってフィールドの名前を変更することをサポートしています:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">OGR_STYLE</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">STYLE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
<p>フィールド名別名は, 列仕様の最後の操作として使用できます. したがって, 演算子内でフィールドの名前を変更することはできませんが, 次の 2 つのように列式全体の名前を変更することができます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="n">areacode</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="ss">&quot;count&quot;</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">dollars</span><span class="o">*</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">cents</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">polylayer</span>
</pre></div>
</div>
</section>
<section id="changing-the-type-of-the-fields">
<h4>フィールドの型を変更する<a class="headerlink" href="#changing-the-type-of-the-fields" title="Link to this heading"></a></h4>
<p>OGR SQL は, 以下の例に示すように, SQL92 に準拠した CAST 演算子を使用して列の型を変更することをサポートしています:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">OGR_STYLE</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">character</span><span class="p">(</span><span class="mi">255</span><span class="p">))</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">rivers</span>
</pre></div>
</div>
<p>現在, 次のターゲット型へのキャストがサポートされています:</p>
<ul class="simple">
<li><p>boolean</p></li>
<li><p>character(フィールド長). デフォルトでは, フィールド長=1.</p></li>
<li><p>float(フィールド長)</p></li>
<li><p>numeric(フィールド長, フィールド精度)</p></li>
<li><p>smallint(フィールド長) : 16 ビット符号付き整数</p></li>
<li><p>integer(フィールド長)</p></li>
<li><p>bigint(フィールド長), 64 ビット整数, SQL92 の拡張</p></li>
<li><p>date(フィールド長)</p></li>
<li><p>time(フィールド長)</p></li>
<li><p>timestamp(フィールド長)</p></li>
<li><p>geometry, geometry(ジオメトリタイプ), geometry(ジオメトリタイプ,epsg_code)</p></li>
</ul>
<p>フィールド長と/またはフィールド精度を指定することは任意です. character() の幅として可変幅を示すために, 幅としてゼロの明示的な値を使用できます. 'integer list', 'double list' および 'string list' OGR データ型への変換はサポートされていません. これは SQL92 仕様に準拠していません.</p>
<p>CAST 演算子は WHERE 句を含む式のどこにでも適用できますが, 出力フィールドのフォーマットの詳細な制御は, CAST 演算子がフィールド定義リストのフィールドで最も外側の演算子である場合にのみサポートされます. 他のコンテキストでは, 数値, 文字列および日付データ型間の変換には依然として有用です.</p>
<p>WKT 文字列をジオメトリにキャストすることが許可されています. geometry_type は POINT[Z], LINESTRING[Z], POLYGON[Z], MULTIPOINT[Z], MULTILINESTRING[Z], MULTIPOLYGON[Z], GEOMETRYCOLLECTION[Z] または GEOMETRY[Z] にすることができます.</p>
</section>
<section id="string-literals-and-identifiers-quoting">
<h4>文字列リテラルと識別子の引用<a class="headerlink" href="#string-literals-and-identifiers-quoting" title="Link to this heading"></a></h4>
<p>文字列リテラルと識別子の引用に関しては, 厳密な SQL92 ルールが適用されます.</p>
<p>文字列リテラル (定数) はシングルクォート文字で囲む必要があります. 例: WHERE a_field = 'a_value'</p>
<p>識別子 (列名およびテーブル名) は特殊文字を含まないか SQL 予約キーワードでない場合は引用符なしで使用できます. それ以外の場合は, ダブルクォート文字で囲む必要があります. 例: WHERE &quot;from&quot; = 5.</p>
</section>
</section>
<section id="where">
<h3>WHERE<a class="headerlink" href="#where" title="Link to this heading"></a></h3>
<p>WHERE 句の引数は, ソースレイヤーからレコードを選択するために使用される論理式です. WHERE 文内での使用に加えて, WHERE 句の処理は, <a class="reference internal" href="../api/ogrlayer_cpp.html#_CPPv4N8OGRLayer18SetAttributeFilterEPKc" title="OGRLayer::SetAttributeFilter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">OGRLayer::SetAttributeFilter()</span></code></a> を介した通常のレイヤーの OGR 属性クエリにも使用されます.</p>
<p>SELECT ステートメントのフィールド選択句の式で使用できる算術演算子およびその他の関数演算子に加えて, WHERE コンテキストでは論理演算子も使用でき, 式の評価値は論理値 (true または false) である必要があります.</p>
<p>使用可能な論理演算子は <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> および <code class="docutils literal notranslate"><span class="pre">ILIKE</span></code>, <code class="docutils literal notranslate"><span class="pre">BETWEEN</span></code> および <code class="docutils literal notranslate"><span class="pre">IN</span></code> です. ほとんどの演算子は自明ですが, <code class="docutils literal notranslate"><span class="pre">!=</span></code> は <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> と同じであり, 文字列の等価性は大文字小文字を区別しませんが, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> および <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 演算子は大文字小文字を区別します.</p>
<p>GDAL 3.1 以降, LIKE は大文字小文字を区別し, ILIKE は大文字小文字を区別しません. 以前のバージョンでは, LIKE も大文字小文字を区別しませんでした. GDAL 3.1 で以前の動作が必要な場合は, <a class="reference internal" href="configoptions.html#config-OGR_SQL_LIKE_AS_ILIKE"><code class="docutils literal notranslate"><span class="pre">OGR_SQL_LIKE_AS_ILIKE</span></code></a> を <code class="docutils literal notranslate"><span class="pre">YES</span></code> に設定できます.</p>
<p>GDAL 3.9 以降, OLCStringsAsUTF8 機能を宣言しているレイヤー (つまり, String 型のフィールドの内容が UTF-8 でエンコードされている) では, UTF-8 文字が <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> および <code class="docutils literal notranslate"><span class="pre">ILIKE</span></code> 演算子によって考慮されます. ILIKE の大文字小文字を区別しない比較の場合, これは <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)">ASCII</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)">Latin-1 Supplement</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Latin_Extended-A">Latin Extended-A</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Latin_Extended-B">Latin Extended-B</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Greek_and_Coptic">Greek and Coptic</a> および <a class="reference external" href="https://en.wikipedia.org/wiki/Greek_and_Coptic">Cyrillic</a> Unicode カテゴリに制限されます.</p>
<p><code class="docutils literal notranslate"><span class="pre">LIKE</span></code> および <code class="docutils literal notranslate"><span class="pre">ILIKE</span></code> 演算子の値引数は, 値文字列が一致するパターンです. このパターンでは, パーセント (%) は任意の文字数に一致し, アンダースコア ( _ ) は任意の 1 文字に一致します. ESCAPE escape_char 可能なエスケープ文字句を追加することで, パーセントまたはアンダースコア文字をエスケープ文字で先行させることで通常の文字として検索できます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">String</span><span class="w">             </span><span class="n">Pattern</span><span class="w">       </span><span class="n">Matches</span><span class="o">?</span>
<span class="c1">------             -------       --------</span>
<span class="n">Alberta</span><span class="w">            </span><span class="n">ALB</span><span class="o">%</span><span class="w">          </span><span class="n">Yes</span>
<span class="n">Alberta</span><span class="w">            </span><span class="n">_lberta</span><span class="w">       </span><span class="n">Yes</span>
<span class="n">St</span><span class="p">.</span><span class="w"> </span><span class="n">Alberta</span><span class="w">        </span><span class="n">_lberta</span><span class="w">       </span><span class="k">No</span>
<span class="n">St</span><span class="p">.</span><span class="w"> </span><span class="n">Alberta</span><span class="w">        </span><span class="o">%</span><span class="n">lberta</span><span class="w">       </span><span class="n">Yes</span>
<span class="n">Robarts</span><span class="w"> </span><span class="n">St</span><span class="p">.</span><span class="w">        </span><span class="o">%</span><span class="n">Robarts</span><span class="o">%</span><span class="w">     </span><span class="n">Yes</span>
<span class="mi">12345</span><span class="w">              </span><span class="mi">123</span><span class="o">%</span><span class="mi">45</span><span class="w">        </span><span class="n">Yes</span>
<span class="mi">123</span><span class="p">.</span><span class="mi">45</span><span class="w">             </span><span class="mi">12</span><span class="o">?</span><span class="mi">45</span><span class="w">         </span><span class="k">No</span>
<span class="n">N0N</span><span class="w"> </span><span class="mi">1</span><span class="n">P0</span><span class="w">            </span><span class="o">%</span><span class="n">N0N</span><span class="o">%</span><span class="w">         </span><span class="n">Yes</span>
<span class="n">L4C</span><span class="w"> </span><span class="mi">5</span><span class="n">E2</span><span class="w">            </span><span class="o">%</span><span class="n">N0N</span><span class="o">%</span><span class="w">         </span><span class="k">No</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IN</span></code> は, 値のリストを引数として受け取り, 属性値が提供されたセットに属しているかどうかをテストします.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">Value</span><span class="w">              </span><span class="n">Value</span><span class="w"> </span><span class="k">Set</span><span class="w">            </span><span class="n">Matches</span><span class="o">?</span>
<span class="c1">------             -------              --------</span>
<span class="mi">321</span><span class="w">                </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="mi">456</span><span class="p">,</span><span class="mi">123</span><span class="p">)</span><span class="w">         </span><span class="k">No</span>
<span class="s1">&#39;Ontario&#39;</span><span class="w">          </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Ontario&#39;</span><span class="p">,</span><span class="s1">&#39;BC&#39;</span><span class="p">)</span><span class="w">  </span><span class="n">Yes</span>
<span class="s1">&#39;Ont&#39;</span><span class="w">              </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Ontario&#39;</span><span class="p">,</span><span class="s1">&#39;BC&#39;</span><span class="p">)</span><span class="w">  </span><span class="k">No</span>
<span class="mi">1</span><span class="w">                  </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="w">         </span><span class="k">No</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BETWEEN</span></code> 演算子の構文は &quot;field_name BETWEEN value1 AND value2&quot; であり, &quot;field_name &gt;= value1 AND field_name &lt;= value2&quot; と等価です.</p>
<p>上記のバイナリ演算子に加えて, フィールドが null かどうかをテストするための追加の演算子があります. これらは <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NULL</span></code> および <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span> <span class="pre">NULL</span></code> 演算子です.</p>
<p>基本的なフィールドテストは, <code class="docutils literal notranslate"><span class="pre">AND</span></code>, <code class="docutils literal notranslate"><span class="pre">OR</span></code> および単項論理 <code class="docutils literal notranslate"><span class="pre">NOT</span></code> を含む論理演算子を使用して, より複雑な述語に組み合わせることができます. 優先順位を明確にするために, サブ式を括弧で囲む必要があります. いくつかのより複雑な述語は次のとおりです:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">prop_value</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">100000</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="p">(</span><span class="n">prop_value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">200000</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="p">(</span><span class="n">area_code</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;N0N%&#39;</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">prop_value</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="p">(</span><span class="n">prop_value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100000</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="where-limitations">
<h3>WHERE 制限<a class="headerlink" href="#where-limitations" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>フィールドはすべて主テーブル (FROM 句にリストされているテーブル) から取得する必要があります.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> および <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> を除くすべての文字列比較は大文字小文字を区別しません.</p></li>
</ul>
</section>
<section id="order-by">
<h3>ORDER BY<a class="headerlink" href="#order-by" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> 句は, 返される地物を 1 つまたは複数のフィールドで昇順または降順に並べ替えるために使用されます. ASC または DESC キーワードが提供されていない場合, 昇順 (増加) 順序がデフォルトです. 例:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">class_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">prop_value</span><span class="w"> </span><span class="k">DESC</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">prop_value</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">prop_value</span><span class="w"> </span><span class="k">ASC</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">zip_code</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">zip_code</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">property</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">prop_value</span><span class="w"> </span><span class="k">ASC</span><span class="p">,</span><span class="w"> </span><span class="n">another_field</span><span class="w"> </span><span class="k">DESC</span>
</pre></div>
</div>
<p>ORDER BY 句は, 地物セットを 2 回通過させます. 1 つ目は, 地物 ID に対応するフィールド値のインメモリテーブルを構築するためのものであり, 2 つ目は, ソートされた順序で地物 ID で地物を取得するためのものです. 地物 ID で効率的にランダムに地物を読み取れない形式では, これは非常に高価な操作になる可能性があります.</p>
<p>文字列フィールド値のソートは, 他の多くの OGR SQL の部分とは異なり, 大文字小文字を区別します.</p>
</section>
<section id="limit-and-offset">
<h3>LIMIT および OFFSET<a class="headerlink" href="#limit-and-offset" title="Link to this heading"></a></h3>
<p>GDAL 2.2 以降, <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> 句を使用して返される地物の数を制限することができます. 例:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">5</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">OFFSET</span></code> 句を使用して, 結果セットの最初の地物をスキップすることができます. OFFSET の後の値はスキップされる地物の数です. たとえば, 結果セットから最初の 3 つの地物をスキップするには:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="k">OFFSET</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
<p>両方の句を組み合わせることができます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">poly</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="k">OFFSET</span><span class="w"> </span><span class="mi">3</span>
</pre></div>
</div>
</section>
<section id="joins">
<h3>JOINs<a class="headerlink" href="#joins" title="Link to this heading"></a></h3>
<p>OGR SQL は, 1 対 1 の JOIN の制限された形式をサポートしています. これにより, 問い合わせられている主テーブルとそれと共有キーを持つ副テーブルの間でレコードを参照することができます. たとえば, 都市の位置のテーブルには, 国名を取得するための参照として使用できる <strong>nation_id</strong> 列が含まれているかもしれません. 結合されたクエリは次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">city</span>
<span class="w">    </span><span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">nation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">id</span>
</pre></div>
</div>
<p>このクエリは, 都市テーブルのすべてのフィールドと, nation テーブルから取得された国名を持つ追加の &quot;nation.name&quot; フィールドを持つテーブルになります. これは, nation テーブル内のレコードを参照して, &quot;id&quot; フィールドの値が city.nation_id フィールドと同じ値であるレコードを探します.</p>
<p>JOIN にはいくつかの追加の問題があります. 1 つは, フィールド名にテーブル修飾子の概念があることです. たとえば, city レイヤーの nation_id フィールドを示すために, nation_id ではなく city.nation_id を参照します. テーブル名修飾子は, フィールドリストおよび JOIN 句内の <code class="docutils literal notranslate"><span class="pre">ON</span></code> 句でのみ使用できます.</p>
<p>ワイルドカードもやや複雑です. 通常の <code class="docutils literal notranslate"><span class="pre">*</span></code> ワイルドカードを使用して, 主テーブル (<strong>city</strong> この場合) および副テーブル (<strong>nation</strong> この場合) のすべてのフィールドを選択できます. ただし, 主テーブルまたは副テーブルのフィールドのみを選択するには, アスタリスクの前にテーブル名を付けます.</p>
<p>クエリレイヤーのフィールド名は, フィールドリストでテーブル名が修飾子として指定されている場合, テーブル名で修飾されます. さらに, 以前のフィールドと競合する場合, フィールド名はテーブル名で修飾されます. たとえば, 次の選択は, city および nation テーブルの両方に nation_id および name フィールド名がある場合, <strong>name, nation_id, nation.nation_id</strong> および <strong>nation.name</strong> フィールドを持つ結果セットになる可能性があります.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">nation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">nation_id</span>
</pre></div>
</div>
<p>一方, nation テーブルに continent_id フィールドがある場合でも, city テーブルにはない場合, そのフィールドは結果セットで修飾する必要はありません. ただし, 選択されたものが次のステートメントのように見える場合, すべての結果フィールドはテーブル名で修飾されます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">city</span>
<span class="w">    </span><span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">nation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">nation_id</span>
</pre></div>
</div>
<p>上記の例では, nation テーブルは city テーブルと同じデータソースにありました. ただし, OGR の JOIN サポートには, 異なるデータソース (異なる形式の可能性がある) のテーブルに対して JOIN する機能が含まれています. これは, 2 番目のテーブル名にデータソース名を修飾することで示されます. この場合, 2 番目のデータソースは通常の OGR セマンティクスを使用して開かれ, クエリ結果が不要になるまで 2 番目のテーブルにアクセスするために使用されます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">city</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="s1">&#39;/usr2/data/nation.dbf&#39;</span><span class="p">.</span><span class="n">nation</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">nation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">nation_id</span>
</pre></div>
</div>
<p>非常に有用ではないかもしれませんが, 一部の SELECT ステートメントを簡素化するためにテーブルエイリアスを導入することも可能です. これは, 同じ名前のテーブルが異なるデータソースから使用されている状況を明確にするのにも役立ちます. たとえば, 実際のテーブル名が複雑な場合, 次のようなことをしたいかもしれません:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">project_615_city</span><span class="w"> </span><span class="k">c</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="s1">&#39;/usr2/data/project_615_nation.dbf&#39;</span><span class="p">.</span><span class="n">project_615_nation</span><span class="w"> </span><span class="n">n</span>
<span class="w">            </span><span class="k">ON</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">nation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">nation_id</span>
</pre></div>
</div>
<p>1 つのクエリで複数の JOIN を行うことができます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">prov</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">city</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">province</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">prov_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">province</span><span class="p">.</span><span class="n">id</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">city</span><span class="p">.</span><span class="n">nation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nation</span><span class="p">.</span><span class="n">id</span>
</pre></div>
</div>
<p>ON の後の式は通常, &quot;{primary_table}.{field_name} = {secondary_table}.{field_name}&quot; の形式であり, その順序です. 複数の比較演算子を含むより複雑なブール式を使用することも可能ですが, 以下の &quot;JOIN 制限&quot; セクションで言及されている制限があります. 特に, 複数の JOIN (3 つ以上のテーブル) の場合, JOIN で比較されるフィールドは, 主テーブル (FROM 後のテーブル) およびアクティブ JOIN のテーブルに属している必要があります.</p>
</section>
<section id="join-limitations">
<h3>JOIN 制限<a class="headerlink" href="#join-limitations" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>JOIN は, 2 番目のテーブルが使用されているキー フィールドにインデックスが付いていない場合, 非常に高価な操作になる可能性があります.</p></li>
<li><p>JOIN フィールドは, 現時点では WHERE 句や ORDER BY 句で使用できません. JOIN は, 基本的にすべての主テーブルのサブセットが完了した後, および ORDER BY パスの後に評価されます.</p></li>
<li><p>JOIN フィールドは, 後の JOIN でキーとして使用できません. したがって, city の省 ID を使用して省レコードを検索し, 次に省 ID から国 ID を使用して国レコードを検索することはできません. これは望ましいことであり, 実装できる可能性がありますが, 現在はサポートされていません.</p></li>
<li><p>JOIN されたテーブルのデータソース名は, 現在のプロセスの作業ディレクトリに対して評価されます. 主データソースへのパスではありません.</p></li>
<li><p>これは, RDBMS の意味での真の LEFT または RIGHT JOIN ではありません. JOIN キーに対する 2 番目のレコードが存在するかどうかにかかわらず, 主レコードの 1 つだけが結果セットに返されます. 2 番目のレコードが見つからない場合, 2 番目の派生フィールドは NULL になります. 複数の一致する 2 番目のフィールドが見つかった場合, 最初のフィールドのみが使用されます.</p></li>
</ul>
</section>
<section id="union-all">
<h3>UNION ALL<a class="headerlink" href="#union-all" title="Link to this heading"></a></h3>
<p>SQL エンジンは, UNION ALL で結合された複数の SELECT を処理できます. UNION ALL の効果は, 右の SELECT ステートメントによって返された行を左の SELECT ステートメントによって返された行に連結することです.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="p">[(]</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">field_list</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">first_layer</span><span class="w"> </span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="n">where_expr</span><span class="p">]</span><span class="w"> </span><span class="p">[)]</span>
<span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="p">[(]</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">field_list</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">second_layer</span><span class="w"> </span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="n">where_expr</span><span class="p">]</span><span class="w"> </span><span class="p">[)]</span>
<span class="p">[</span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="p">[(]</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">field_list</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">third_layer</span><span class="w"> </span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="n">where_expr</span><span class="p">]</span><span class="w"> </span><span class="p">[)]]</span><span class="o">*</span>
</pre></div>
</div>
</section>
<section id="union-all-restrictions">
<h3>UNION ALL 制限<a class="headerlink" href="#union-all-restrictions" title="Link to this heading"></a></h3>
<p>OGR における UNION ALL の処理は, SQL 標準と異なります. SQL 標準では, 各 SELECT の列が同一でない場合にも受け入れられます. その場合, 各 SELECT ステートメントのすべてのフィールドのスーパーセットを返します.</p>
<p>さらに, 制限があります: ORDER BY は各 SELECT に対してのみ指定でき, UNION の結果のレベルでは指定できません.</p>
</section>
</section>
<section id="special-fields">
<h2>特殊フィールド<a class="headerlink" href="#special-fields" title="Link to this heading"></a></h2>
<p>OGR SQL クエリプロセッサは, 地物の一部の属性を組み込みの特殊フィールドとして扱い, 他のフィールドと一緒に SQL ステートメントで使用できます. これらのフィールドは, それぞれ SELECT リスト, WHERE 句および ORDER BY 句に配置できます. 特殊フィールドはデフォルトでは結果に含まれませんが, SELECT リストに追加することで明示的に含めることができます. フィールド値にアクセスするとき, 特殊フィールドは, 同じ名前のデータソース内の他のフィールドよりも優先されます.</p>
<section id="feature-id-fid">
<h3>地物 ID (FID)<a class="headerlink" href="#feature-id-fid" title="Link to this heading"></a></h3>
<p>通常, 地物 ID は地物の特別なプロパティであり, 地物の属性として扱われません. 場合によっては, クエリや結果セットで地物 ID を通常のフィールドとして利用できると便利です. これを行うには, <code class="docutils literal notranslate"><span class="pre">FID</span></code> という名前を使用します. レイヤーに名前付きの FID 列がある場合 (<a class="reference internal" href="../api/ogrlayer_cpp.html#_CPPv4N8OGRLayer12GetFIDColumnEv" title="OGRLayer::GetFIDColumn"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">OGRLayer::GetFIDColumn()</span></code></a> != &quot;&quot;), この名前も使用できます.</p>
<p>フィールドワイルドカードの展開には地物 ID は含まれませんが, 次のような構文を使用して明示的に含めることができます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">FID</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span>
</pre></div>
</div>
</section>
<section id="geometry-field">
<h3>ジオメトリ フィールド<a class="headerlink" href="#geometry-field" title="Link to this heading"></a></h3>
<p>OGR SQL 方言は, データソースのジオメトリ フィールドをデフォルトで結果セットに追加します. ユーザーはジオメトリを明示的に選択する必要はありませんが, それを行うことも可能です. ジオメトリが必要な唯一のフィールドの場合が一般的な使用ケースです. この場合, SQL ステートメントで使用するジオメトリ フィールドの名前は, <a class="reference internal" href="../api/ogrlayer_cpp.html#_CPPv4N8OGRLayer17GetGeometryColumnEv" title="OGRLayer::GetGeometryColumn"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">OGRLayer::GetGeometryColumn()</span></code></a> によって返される名前であり, <strong class="program">ogrinfo</strong> 出力の &quot;Geometry Column = ...&quot; でもあります. メソッドが空の文字列を返す場合, 特別な名前 &quot;_ogr_geometry_&quot; を使用する必要があります. 名前はアンダースコアで始まり, SQL 構文では, ダブルクォートの間に現れる必要があります. さらに, コマンドラインインタプリタは, ダブルクォートをエスケープする必要がある場合があり, 最終的な SELECT ステートメントは次のようになります:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="ss">&quot;_ogr_geometry_&quot;</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span>
</pre></div>
</div>
</section>
<section id="ogr-geometry">
<h3>OGR_GEOMETRY<a class="headerlink" href="#ogr-geometry" title="Link to this heading"></a></h3>
<p>一部のデータソース (MapInfo tab など) は, 同じレイヤー内で異なるタイプのジオメトリを処理できます. <code class="docutils literal notranslate"><span class="pre">OGR_GEOMETRY</span></code> 特殊フィールドは, <a class="reference internal" href="../api/ogrgeometry_cpp.html#_CPPv4NK11OGRGeometry15getGeometryNameEv" title="OGRGeometry::getGeometryName"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">OGRGeometry::getGeometryName()</span></code></a> によって返されるジオメトリ タイプを表し, さまざまなタイプを区別するために使用できます. このフィールドを使用することで, ジオメトリの特定のタイプを次のように選択できます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">OGR_GEOMETRY</span><span class="o">=</span><span class="s1">&#39;POINT&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">OGR_GEOMETRY</span><span class="o">=</span><span class="s1">&#39;POLYGON&#39;</span>
</pre></div>
</div>
</section>
<section id="ogr-geom-wkt">
<h3>OGR_GEOM_WKT<a class="headerlink" href="#ogr-geom-wkt" title="Link to this heading"></a></h3>
<p>ジオメトリの Well Known Text 表現も特殊フィールドとして使用できます. ジオメトリの WKT を選択するには, <code class="docutils literal notranslate"><span class="pre">OGR_GEOM_WKT</span></code> を選択リストに含めることができます. たとえば:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">OGR_GEOM_WKT</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">OGR_GEOM_WKT</span></code> と <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 演算子を WHERE 句で使用することで, OGR_GEOMETRY を使用するのと同様の効果を得ることができます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">OGR_GEOM_WKT</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">OGR_GEOM_WKT</span>
<span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;POINT%&#39;</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">OGR_GEOM_WKT</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;POLYGON%&#39;</span>
</pre></div>
</div>
</section>
<section id="ogr-geom-area">
<h3>OGR_GEOM_AREA<a class="headerlink" href="#ogr-geom-area" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">OGR_GEOM_AREA</span></code> 特殊フィールドは, OGRSurface::get_Area() メソッドによって計算された地物のジオメトリの面積を返します. OGRGeometryCollection および OGRMultiPolygon の場合, 値はそのメンバーの面積の合計です. 非サーフェス ジオメトリの場合, 返される面積は 0.0 です.</p>
<p>たとえば, 指定された面積より大きいポリゴン地物のみを選択するには:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">OGR_GEOM_AREA</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10000000</span>
</pre></div>
</div>
</section>
<section id="ogr-style">
<h3>OGR_STYLE<a class="headerlink" href="#ogr-style" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">OGR_STYLE</span></code> 特殊フィールドは, OGRFeature::GetStyleString() によって返される地物のスタイル文字列を表します. このフィールドと <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> 演算子を使用して, クエリの結果をスタイルでフィルタリングすることができます. たとえば, 注釈地物を次のように選択できます:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">OGR_STYLE</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;LABEL%&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">OGR_STYLE</span></code> フィールド名を特殊フィールド名として使用して, 通常は他のフィールドまたは文字列リテラルをエイリアスすることで, <a class="reference internal" href="../api/ogrfeature_cpp.html#_CPPv4N10OGRFeature14SetStyleStringEPKc" title="OGRFeature::SetStyleString"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">OGRFeature::SetStyleString()</span></code></a> 値を設定する別の方法として使用することができます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;BRUSH(fc:#01234567)&#39;</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">OGR_STYLE</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">source_layer</span>
</pre></div>
</div>
<p>デフォルトでは, OGR_STYLE フィールドは通常のフィールドとして表示されます. これを避けたい場合, GDAL 3.10 以降では, フィールド仕様の最後に HIDDEN キーワードを追加することで非表示にすることができます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">EXCLUDE</span><span class="p">(</span><span class="n">my_style_field</span><span class="p">),</span><span class="w"> </span><span class="n">my_style_field</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">OGR_STYLE</span><span class="w"> </span><span class="n">HIDDEN</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">source_layer</span>
</pre></div>
</div>
</section>
</section>
<section id="create-index">
<h2>CREATE INDEX<a class="headerlink" href="#create-index" title="Link to this heading"></a></h2>
<p>一部の OGR SQL ドライバーは, 属性インデックスの作成をサポートしています. 現在, これには Shapefile ドライバーが含まれています. インデックスは, <strong>fieldname = value</strong> の形式の非常に単純な属性クエリを加速します. これは <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> 機能で使用されるものです. nation テーブルの nation_id フィールドに属性インデックスを作成するには, 次のようなコマンドを使用します:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">nation_id</span>
</pre></div>
</div>
<section id="index-limitations">
<h3>Index 制限<a class="headerlink" href="#index-limitations" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>新しい地物がレイヤーに追加されたり削除されたりするときに, インデックスは動的に維持されません.</p></li>
<li><p>非常に長い文字列 (256 文字より長い?) は現在インデックス化できません.</p></li>
<li><p>インデックスを再作成するには, レイヤーのすべてのインデックスを削除してから, すべてのインデックスを再作成する必要があります.</p></li>
<li><p>インデックスは, 複雑なクエリでは使用されません. 現在, 加速されるのは単純な &quot;field = value&quot; クエリのみです.</p></li>
</ul>
</section>
</section>
<section id="drop-index">
<h2>DROP INDEX<a class="headerlink" href="#drop-index" title="Link to this heading"></a></h2>
<p>OGR SQL DROP INDEX コマンドは, 特定のテーブルのすべてのインデックスを削除するか, 特定の列のインデックスのみを削除するために使用できます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">nation_id</span>
<span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">nation</span>
</pre></div>
</div>
</section>
<section id="alter-table">
<h2>ALTER TABLE<a class="headerlink" href="#alter-table" title="Link to this heading"></a></h2>
<p>次の OGR SQL ALTER TABLE コマンドを使用できます.</p>
<p>-&quot;ALTER TABLE tablename ADD [COLUMN] columnname columntype&quot; は, 新しいフィールドを追加します. レイヤーが OLCCreateField 機能を宣言している場合にサポートされます. -&quot;ALTER TABLE tablename RENAME [COLUMN] oldcolumnname TO newcolumnname&quot; は, 既存のフィールドの名前を変更します. レイヤーが OLCAlterFieldDefn 機能を宣言している場合にサポートされます. -&quot;ALTER TABLE tablename ALTER [COLUMN] columnname TYPE columntype&quot; は, 既存のフィールドのタイプを変更します. レイヤーが OLCAlterFieldDefn 機能を宣言している場合にサポートされます. -&quot;ALTER TABLE tablename DROP [COLUMN] columnname&quot; は, 既存のフィールドを削除します. レイヤーが OLCDeleteField 機能を宣言している場合にサポートされます.</p>
<p>columntype 値は, 上記で説明した CAST 演算子でサポートされているタイプの構文に従います.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">myfield</span><span class="w"> </span><span class="nb">integer</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">RENAME</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">myfield</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="n">myfield2</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">ALTER</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">myfield2</span><span class="w"> </span><span class="k">TYPE</span><span class="w"> </span><span class="nb">character</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">nation</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">myfield2</span>
</pre></div>
</div>
</section>
<section id="drop-table">
<h2>DROP TABLE<a class="headerlink" href="#drop-table" title="Link to this heading"></a></h2>
<p>OGR SQL DROP TABLE コマンドは, テーブルを削除するために使用できます. これは, ODsCDeleteLayer 機能を宣言しているデータソースでのみサポートされます.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">nation</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sql_sqlite_dialect.html" class="btn btn-neutral float-right" title="SQL SQLite方言" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ogr_sql_sqlite_dialect.html" class="btn btn-neutral float-left" title="OGR SQL方言とSQLITE SQL方言" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <div class="info">
      <a class="logo-link" href="https://osgeo.org">
        <div class="osgeo-logo"></div>
      </a>
      <div class="copyright">
      

      &copy; 1998-2024 <a href="https://github.com/warmerdam">Frank Warmerdam</a>,
      <a href="https://github.com/rouault">Even Rouault</a>, and
      <a href="https://github.com/OSGeo/gdal/graphs/contributors">others</a>


      
      </div>
    </div>
  </div>
</footer>
        </div>
      </div>
    </section>
  </div>
  
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>